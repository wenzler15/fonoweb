
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions

export type PrismaPromise<T> = $Public.PrismaPromise<T>


export type UserPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "User"
  objects: {
    patientData: PatientPayload<ExtArgs> | null
    doctorData: DoctorPayload<ExtArgs> | null
    addresses: UserAdressPayload<ExtArgs>[]
    contacts: UserContactPayload<ExtArgs>[]
    DoctorPatient: DoctorPatientPayload<ExtArgs>[]
    exercises: ExercisePayload<ExtArgs>[]
    courses: CoursePayload<ExtArgs>[]
    lessons: LessonPayload<ExtArgs>[]
    watched: WatchedVideoPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    numericId: number
    socialName: string | null
    email: string
    name: string
    gender: string | null
    customGender: string | null
    cpf: string | null
    birthDate: Date | null
    password: string
    type: UserType
    avatar: string | null
    facebookToken: string | null
    passwordResetToken: string | null
    passwordResetExpires: Date | null
    isAdmin: boolean
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
  }, ExtArgs["result"]["user"]>
  composites: {}
}

/**
 * Model User
 * 
 */
export type User = runtime.Types.DefaultSelection<UserPayload>
export type UserAdressPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "UserAdress"
  objects: {
    user: UserPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    numericId: number
    userId: string
    streetName: string
    zipCode: string
    district: string
    state: string
    city: string
    number: string
    complement: string | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
  }, ExtArgs["result"]["userAdress"]>
  composites: {}
}

/**
 * Model UserAdress
 * 
 */
export type UserAdress = runtime.Types.DefaultSelection<UserAdressPayload>
export type UserContactPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "UserContact"
  objects: {
    user: UserPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    numericId: number
    userId: string
    email: string | null
    area: string
    phone: string
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
  }, ExtArgs["result"]["userContact"]>
  composites: {}
}

/**
 * Model UserContact
 * 
 */
export type UserContact = runtime.Types.DefaultSelection<UserContactPayload>
export type PatientPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Patient"
  objects: {
    user: UserPayload<ExtArgs>
    anamnesis: AnamnesisPayload<ExtArgs>[]
    evaluations: EvaluationPayload<ExtArgs>[]
    doctorPatient: DoctorPatientPayload<ExtArgs>[]
    evolutions: EvolutionPayload<ExtArgs>[]
    appointment: AppointmentPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    numericId: number
    userId: string
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
  }, ExtArgs["result"]["patient"]>
  composites: {}
}

/**
 * Model Patient
 * 
 */
export type Patient = runtime.Types.DefaultSelection<PatientPayload>
export type AppointmentPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Appointment"
  objects: {
    doctor: DoctorPayload<ExtArgs>
    patient: PatientPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    numericId: number
    doctorId: string
    patientId: string
    when: Date
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    status: AppointmentStatus
  }, ExtArgs["result"]["appointment"]>
  composites: {}
}

/**
 * Model Appointment
 * 
 */
export type Appointment = runtime.Types.DefaultSelection<AppointmentPayload>
export type DoctorPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Doctor"
  objects: {
    specialty: SpecialtyPayload<ExtArgs>
    user: UserPayload<ExtArgs>
    anamnesis: AnamnesisPayload<ExtArgs>[]
    evaluations: EvaluationPayload<ExtArgs>[]
    doctorPatient: DoctorPatientPayload<ExtArgs>[]
    templates: TemplatePayload<ExtArgs>[]
    evolutions: EvolutionPayload<ExtArgs>[]
    appointments: AppointmentPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    numericId: number
    userId: string
    specialtyId: string
    crfa: string | null
    availability: Prisma.JsonValue
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
  }, ExtArgs["result"]["doctor"]>
  composites: {}
}

/**
 * Model Doctor
 * 
 */
export type Doctor = runtime.Types.DefaultSelection<DoctorPayload>
export type DoctorPatientPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "DoctorPatient"
  objects: {
    doctor: DoctorPayload<ExtArgs>
    patient: PatientPayload<ExtArgs>
    assignedBy: UserPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    doctorId: string
    patientId: string
    assignedById: string
    createdAt: Date
    active: boolean
  }, ExtArgs["result"]["doctorPatient"]>
  composites: {}
}

/**
 * Model DoctorPatient
 * 
 */
export type DoctorPatient = runtime.Types.DefaultSelection<DoctorPatientPayload>
export type SpecialtyPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Specialty"
  objects: {
    doctors: DoctorPayload<ExtArgs>[]
    templates: TemplatePayload<ExtArgs>[]
    evaluations: EvaluationPayload<ExtArgs>[]
    anamnesis: AnamnesisPayload<ExtArgs>[]
    evolution: EvolutionPayload<ExtArgs>[]
    exercise: ExercisePayload<ExtArgs>[]
    course: CoursePayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    numericId: number
    name: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["specialty"]>
  composites: {}
}

/**
 * Model Specialty
 * 
 */
export type Specialty = runtime.Types.DefaultSelection<SpecialtyPayload>
export type AnamnesisPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Anamnesis"
  objects: {
    patient: PatientPayload<ExtArgs>
    doctor: DoctorPayload<ExtArgs>
    specialty: SpecialtyPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    numericId: number
    patientId: string
    doctorId: string
    specialtyId: string
    questions: Prisma.JsonValue
    title: string | null
    text: string | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
  }, ExtArgs["result"]["anamnesis"]>
  composites: {}
}

/**
 * Model Anamnesis
 * 
 */
export type Anamnesis = runtime.Types.DefaultSelection<AnamnesisPayload>
export type EvolutionPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Evolution"
  objects: {
    patient: PatientPayload<ExtArgs>
    doctor: DoctorPayload<ExtArgs>
    specialty: SpecialtyPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    numericId: number
    patientId: string
    doctorId: string
    specialtyId: string
    exercises: Prisma.JsonValue
    text: string | null
    title: string | null
    appointmentDate: Date
    comments: string | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
  }, ExtArgs["result"]["evolution"]>
  composites: {}
}

/**
 * Model Evolution
 * 
 */
export type Evolution = runtime.Types.DefaultSelection<EvolutionPayload>
export type EvaluationPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Evaluation"
  objects: {
    patient: PatientPayload<ExtArgs>
    doctor: DoctorPayload<ExtArgs>
    specialty: SpecialtyPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    numericId: number
    patientId: string
    doctorId: string
    specialtyId: string
    text: string | null
    title: string | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
  }, ExtArgs["result"]["evaluation"]>
  composites: {}
}

/**
 * Model Evaluation
 * 
 */
export type Evaluation = runtime.Types.DefaultSelection<EvaluationPayload>
export type ExercisePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Exercise"
  objects: {
    creator: UserPayload<ExtArgs>
    specialty: SpecialtyPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    numericId: number
    title: string
    description: string
    links: Prisma.JsonValue
    creatorId: string
    specialtyId: string
    createdAt: Date
    updatedAt: Date
  }, ExtArgs["result"]["exercise"]>
  composites: {}
}

/**
 * Model Exercise
 * 
 */
export type Exercise = runtime.Types.DefaultSelection<ExercisePayload>
export type TemplatePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Template"
  objects: {
    doctor: DoctorPayload<ExtArgs>
    specialty: SpecialtyPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    numericId: number
    doctorId: string
    type: TemplateType
    specialtyId: string
    title: string
    html: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
  }, ExtArgs["result"]["template"]>
  composites: {}
}

/**
 * Model Template
 * 
 */
export type Template = runtime.Types.DefaultSelection<TemplatePayload>
export type CoursePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Course"
  objects: {
    creator: UserPayload<ExtArgs>
    specialty: SpecialtyPayload<ExtArgs>
    lessons: LessonPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    numericId: number
    creatorId: string
    specialtyId: string
    order: number
    title: string
    cover: string | null
    description: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
  }, ExtArgs["result"]["course"]>
  composites: {}
}

/**
 * Model Course
 * 
 */
export type Course = runtime.Types.DefaultSelection<CoursePayload>
export type LessonPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Lesson"
  objects: {
    creator: UserPayload<ExtArgs>
    course: CoursePayload<ExtArgs>
    videos: LessonVideoPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    numericId: number
    creatorId: string
    courseId: string
    order: number
    title: string
    description: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
  }, ExtArgs["result"]["lesson"]>
  composites: {}
}

/**
 * Model Lesson
 * 
 */
export type Lesson = runtime.Types.DefaultSelection<LessonPayload>
export type LessonVideoPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "LessonVideo"
  objects: {
    lesson: LessonPayload<ExtArgs>
    watched: WatchedVideoPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    numericId: number
    lessonId: string
    order: number
    title: string
    video: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
  }, ExtArgs["result"]["lessonVideo"]>
  composites: {}
}

/**
 * Model LessonVideo
 * 
 */
export type LessonVideo = runtime.Types.DefaultSelection<LessonVideoPayload>
export type WatchedVideoPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "WatchedVideo"
  objects: {
    user: UserPayload<ExtArgs>
    video: LessonVideoPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    numericId: number
    userId: string
    videoId: string
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
  }, ExtArgs["result"]["watchedVideo"]>
  composites: {}
}

/**
 * Model WatchedVideo
 * 
 */
export type WatchedVideo = runtime.Types.DefaultSelection<WatchedVideoPayload>

/**
 * Enums
 */

export const AppointmentStatus: {
  SCHEDULED: 'SCHEDULED',
  CONFIRMED: 'CONFIRMED',
  CANCELED: 'CANCELED',
  FINISHED: 'FINISHED'
};

export type AppointmentStatus = (typeof AppointmentStatus)[keyof typeof AppointmentStatus]


export const TemplateType: {
  ANAMNESIS: 'ANAMNESIS',
  EVALUATION: 'EVALUATION'
};

export type TemplateType = (typeof TemplateType)[keyof typeof TemplateType]


export const UserType: {
  DOCTOR: 'DOCTOR',
  PATIENT: 'PATIENT'
};

export type UserType = (typeof UserType)[keyof typeof UserType]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false,
  ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => Promise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.userAdress`: Exposes CRUD operations for the **UserAdress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserAdresses
    * const userAdresses = await prisma.userAdress.findMany()
    * ```
    */
  get userAdress(): Prisma.UserAdressDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.userContact`: Exposes CRUD operations for the **UserContact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserContacts
    * const userContacts = await prisma.userContact.findMany()
    * ```
    */
  get userContact(): Prisma.UserContactDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.patient`: Exposes CRUD operations for the **Patient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Patients
    * const patients = await prisma.patient.findMany()
    * ```
    */
  get patient(): Prisma.PatientDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.appointment`: Exposes CRUD operations for the **Appointment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Appointments
    * const appointments = await prisma.appointment.findMany()
    * ```
    */
  get appointment(): Prisma.AppointmentDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.doctor`: Exposes CRUD operations for the **Doctor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Doctors
    * const doctors = await prisma.doctor.findMany()
    * ```
    */
  get doctor(): Prisma.DoctorDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.doctorPatient`: Exposes CRUD operations for the **DoctorPatient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DoctorPatients
    * const doctorPatients = await prisma.doctorPatient.findMany()
    * ```
    */
  get doctorPatient(): Prisma.DoctorPatientDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.specialty`: Exposes CRUD operations for the **Specialty** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Specialties
    * const specialties = await prisma.specialty.findMany()
    * ```
    */
  get specialty(): Prisma.SpecialtyDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.anamnesis`: Exposes CRUD operations for the **Anamnesis** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Anamneses
    * const anamneses = await prisma.anamnesis.findMany()
    * ```
    */
  get anamnesis(): Prisma.AnamnesisDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.evolution`: Exposes CRUD operations for the **Evolution** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Evolutions
    * const evolutions = await prisma.evolution.findMany()
    * ```
    */
  get evolution(): Prisma.EvolutionDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.evaluation`: Exposes CRUD operations for the **Evaluation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Evaluations
    * const evaluations = await prisma.evaluation.findMany()
    * ```
    */
  get evaluation(): Prisma.EvaluationDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.exercise`: Exposes CRUD operations for the **Exercise** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Exercises
    * const exercises = await prisma.exercise.findMany()
    * ```
    */
  get exercise(): Prisma.ExerciseDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.template`: Exposes CRUD operations for the **Template** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Templates
    * const templates = await prisma.template.findMany()
    * ```
    */
  get template(): Prisma.TemplateDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.course`: Exposes CRUD operations for the **Course** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Courses
    * const courses = await prisma.course.findMany()
    * ```
    */
  get course(): Prisma.CourseDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.lesson`: Exposes CRUD operations for the **Lesson** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lessons
    * const lessons = await prisma.lesson.findMany()
    * ```
    */
  get lesson(): Prisma.LessonDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.lessonVideo`: Exposes CRUD operations for the **LessonVideo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LessonVideos
    * const lessonVideos = await prisma.lessonVideo.findMany()
    * ```
    */
  get lessonVideo(): Prisma.LessonVideoDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.watchedVideo`: Exposes CRUD operations for the **WatchedVideo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WatchedVideos
    * const watchedVideos = await prisma.watchedVideo.findMany()
    * ```
    */
  get watchedVideo(): Prisma.WatchedVideoDelegate<GlobalReject, ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export type Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export type Args<T, F extends $Public.Operation> = $Public.Args<T, F>
  export type Payload<T, F extends $Public.Operation> = $Public.Payload<T, F>
  export type Result<T, A, F extends $Public.Operation> = $Public.Result<T, A, F>
  export type Exact<T, W> = $Public.Exact<T, W>

  /**
   * Prisma Client JS version: 4.16.2
   * Query Engine version: 8fde8fef4033376662cad983758335009d522acb
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    UserAdress: 'UserAdress',
    UserContact: 'UserContact',
    Patient: 'Patient',
    Appointment: 'Appointment',
    Doctor: 'Doctor',
    DoctorPatient: 'DoctorPatient',
    Specialty: 'Specialty',
    Anamnesis: 'Anamnesis',
    Evolution: 'Evolution',
    Evaluation: 'Evaluation',
    Exercise: 'Exercise',
    Template: 'Template',
    Course: 'Course',
    Lesson: 'Lesson',
    LessonVideo: 'LessonVideo',
    WatchedVideo: 'WatchedVideo'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.Args}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'user' | 'userAdress' | 'userContact' | 'patient' | 'appointment' | 'doctor' | 'doctorPatient' | 'specialty' | 'anamnesis' | 'evolution' | 'evaluation' | 'exercise' | 'template' | 'course' | 'lesson' | 'lessonVideo' | 'watchedVideo'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      User: {
        payload: UserPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>,
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      UserAdress: {
        payload: UserAdressPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.UserAdressFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserAdressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserAdressFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserAdressPayload>
          }
          findFirst: {
            args: Prisma.UserAdressFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserAdressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserAdressFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserAdressPayload>
          }
          findMany: {
            args: Prisma.UserAdressFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserAdressPayload>[]
          }
          create: {
            args: Prisma.UserAdressCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserAdressPayload>
          }
          createMany: {
            args: Prisma.UserAdressCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserAdressDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserAdressPayload>
          }
          update: {
            args: Prisma.UserAdressUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserAdressPayload>
          }
          deleteMany: {
            args: Prisma.UserAdressDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserAdressUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserAdressUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserAdressPayload>
          }
          aggregate: {
            args: Prisma.UserAdressAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUserAdress>
          }
          groupBy: {
            args: Prisma.UserAdressGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserAdressGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserAdressCountArgs<ExtArgs>,
            result: $Utils.Optional<UserAdressCountAggregateOutputType> | number
          }
        }
      }
      UserContact: {
        payload: UserContactPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.UserContactFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserContactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserContactFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserContactPayload>
          }
          findFirst: {
            args: Prisma.UserContactFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserContactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserContactFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserContactPayload>
          }
          findMany: {
            args: Prisma.UserContactFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserContactPayload>[]
          }
          create: {
            args: Prisma.UserContactCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserContactPayload>
          }
          createMany: {
            args: Prisma.UserContactCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserContactDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserContactPayload>
          }
          update: {
            args: Prisma.UserContactUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserContactPayload>
          }
          deleteMany: {
            args: Prisma.UserContactDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserContactUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserContactUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<UserContactPayload>
          }
          aggregate: {
            args: Prisma.UserContactAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUserContact>
          }
          groupBy: {
            args: Prisma.UserContactGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserContactGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserContactCountArgs<ExtArgs>,
            result: $Utils.Optional<UserContactCountAggregateOutputType> | number
          }
        }
      }
      Patient: {
        payload: PatientPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.PatientFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PatientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PatientFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PatientPayload>
          }
          findFirst: {
            args: Prisma.PatientFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PatientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PatientFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PatientPayload>
          }
          findMany: {
            args: Prisma.PatientFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PatientPayload>[]
          }
          create: {
            args: Prisma.PatientCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PatientPayload>
          }
          createMany: {
            args: Prisma.PatientCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PatientDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PatientPayload>
          }
          update: {
            args: Prisma.PatientUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PatientPayload>
          }
          deleteMany: {
            args: Prisma.PatientDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PatientUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PatientUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PatientPayload>
          }
          aggregate: {
            args: Prisma.PatientAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePatient>
          }
          groupBy: {
            args: Prisma.PatientGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PatientGroupByOutputType>[]
          }
          count: {
            args: Prisma.PatientCountArgs<ExtArgs>,
            result: $Utils.Optional<PatientCountAggregateOutputType> | number
          }
        }
      }
      Appointment: {
        payload: AppointmentPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.AppointmentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AppointmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AppointmentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AppointmentPayload>
          }
          findFirst: {
            args: Prisma.AppointmentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AppointmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AppointmentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AppointmentPayload>
          }
          findMany: {
            args: Prisma.AppointmentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AppointmentPayload>[]
          }
          create: {
            args: Prisma.AppointmentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AppointmentPayload>
          }
          createMany: {
            args: Prisma.AppointmentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AppointmentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AppointmentPayload>
          }
          update: {
            args: Prisma.AppointmentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AppointmentPayload>
          }
          deleteMany: {
            args: Prisma.AppointmentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AppointmentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AppointmentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AppointmentPayload>
          }
          aggregate: {
            args: Prisma.AppointmentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAppointment>
          }
          groupBy: {
            args: Prisma.AppointmentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AppointmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AppointmentCountArgs<ExtArgs>,
            result: $Utils.Optional<AppointmentCountAggregateOutputType> | number
          }
        }
      }
      Doctor: {
        payload: DoctorPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.DoctorFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DoctorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DoctorFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DoctorPayload>
          }
          findFirst: {
            args: Prisma.DoctorFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DoctorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DoctorFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DoctorPayload>
          }
          findMany: {
            args: Prisma.DoctorFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DoctorPayload>[]
          }
          create: {
            args: Prisma.DoctorCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DoctorPayload>
          }
          createMany: {
            args: Prisma.DoctorCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.DoctorDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DoctorPayload>
          }
          update: {
            args: Prisma.DoctorUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DoctorPayload>
          }
          deleteMany: {
            args: Prisma.DoctorDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DoctorUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DoctorUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DoctorPayload>
          }
          aggregate: {
            args: Prisma.DoctorAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDoctor>
          }
          groupBy: {
            args: Prisma.DoctorGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DoctorGroupByOutputType>[]
          }
          count: {
            args: Prisma.DoctorCountArgs<ExtArgs>,
            result: $Utils.Optional<DoctorCountAggregateOutputType> | number
          }
        }
      }
      DoctorPatient: {
        payload: DoctorPatientPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.DoctorPatientFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DoctorPatientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DoctorPatientFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DoctorPatientPayload>
          }
          findFirst: {
            args: Prisma.DoctorPatientFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DoctorPatientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DoctorPatientFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DoctorPatientPayload>
          }
          findMany: {
            args: Prisma.DoctorPatientFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DoctorPatientPayload>[]
          }
          create: {
            args: Prisma.DoctorPatientCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DoctorPatientPayload>
          }
          createMany: {
            args: Prisma.DoctorPatientCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.DoctorPatientDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DoctorPatientPayload>
          }
          update: {
            args: Prisma.DoctorPatientUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DoctorPatientPayload>
          }
          deleteMany: {
            args: Prisma.DoctorPatientDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DoctorPatientUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DoctorPatientUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<DoctorPatientPayload>
          }
          aggregate: {
            args: Prisma.DoctorPatientAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDoctorPatient>
          }
          groupBy: {
            args: Prisma.DoctorPatientGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DoctorPatientGroupByOutputType>[]
          }
          count: {
            args: Prisma.DoctorPatientCountArgs<ExtArgs>,
            result: $Utils.Optional<DoctorPatientCountAggregateOutputType> | number
          }
        }
      }
      Specialty: {
        payload: SpecialtyPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.SpecialtyFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SpecialtyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SpecialtyFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SpecialtyPayload>
          }
          findFirst: {
            args: Prisma.SpecialtyFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SpecialtyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SpecialtyFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SpecialtyPayload>
          }
          findMany: {
            args: Prisma.SpecialtyFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SpecialtyPayload>[]
          }
          create: {
            args: Prisma.SpecialtyCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SpecialtyPayload>
          }
          createMany: {
            args: Prisma.SpecialtyCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SpecialtyDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SpecialtyPayload>
          }
          update: {
            args: Prisma.SpecialtyUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SpecialtyPayload>
          }
          deleteMany: {
            args: Prisma.SpecialtyDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SpecialtyUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SpecialtyUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SpecialtyPayload>
          }
          aggregate: {
            args: Prisma.SpecialtyAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSpecialty>
          }
          groupBy: {
            args: Prisma.SpecialtyGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SpecialtyGroupByOutputType>[]
          }
          count: {
            args: Prisma.SpecialtyCountArgs<ExtArgs>,
            result: $Utils.Optional<SpecialtyCountAggregateOutputType> | number
          }
        }
      }
      Anamnesis: {
        payload: AnamnesisPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.AnamnesisFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AnamnesisPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnamnesisFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AnamnesisPayload>
          }
          findFirst: {
            args: Prisma.AnamnesisFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AnamnesisPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnamnesisFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AnamnesisPayload>
          }
          findMany: {
            args: Prisma.AnamnesisFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AnamnesisPayload>[]
          }
          create: {
            args: Prisma.AnamnesisCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AnamnesisPayload>
          }
          createMany: {
            args: Prisma.AnamnesisCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AnamnesisDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AnamnesisPayload>
          }
          update: {
            args: Prisma.AnamnesisUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AnamnesisPayload>
          }
          deleteMany: {
            args: Prisma.AnamnesisDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AnamnesisUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AnamnesisUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<AnamnesisPayload>
          }
          aggregate: {
            args: Prisma.AnamnesisAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAnamnesis>
          }
          groupBy: {
            args: Prisma.AnamnesisGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AnamnesisGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnamnesisCountArgs<ExtArgs>,
            result: $Utils.Optional<AnamnesisCountAggregateOutputType> | number
          }
        }
      }
      Evolution: {
        payload: EvolutionPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.EvolutionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<EvolutionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EvolutionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<EvolutionPayload>
          }
          findFirst: {
            args: Prisma.EvolutionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<EvolutionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EvolutionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<EvolutionPayload>
          }
          findMany: {
            args: Prisma.EvolutionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<EvolutionPayload>[]
          }
          create: {
            args: Prisma.EvolutionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<EvolutionPayload>
          }
          createMany: {
            args: Prisma.EvolutionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EvolutionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<EvolutionPayload>
          }
          update: {
            args: Prisma.EvolutionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<EvolutionPayload>
          }
          deleteMany: {
            args: Prisma.EvolutionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EvolutionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EvolutionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<EvolutionPayload>
          }
          aggregate: {
            args: Prisma.EvolutionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEvolution>
          }
          groupBy: {
            args: Prisma.EvolutionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EvolutionGroupByOutputType>[]
          }
          count: {
            args: Prisma.EvolutionCountArgs<ExtArgs>,
            result: $Utils.Optional<EvolutionCountAggregateOutputType> | number
          }
        }
      }
      Evaluation: {
        payload: EvaluationPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.EvaluationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<EvaluationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EvaluationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<EvaluationPayload>
          }
          findFirst: {
            args: Prisma.EvaluationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<EvaluationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EvaluationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<EvaluationPayload>
          }
          findMany: {
            args: Prisma.EvaluationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<EvaluationPayload>[]
          }
          create: {
            args: Prisma.EvaluationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<EvaluationPayload>
          }
          createMany: {
            args: Prisma.EvaluationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EvaluationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<EvaluationPayload>
          }
          update: {
            args: Prisma.EvaluationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<EvaluationPayload>
          }
          deleteMany: {
            args: Prisma.EvaluationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EvaluationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EvaluationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<EvaluationPayload>
          }
          aggregate: {
            args: Prisma.EvaluationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEvaluation>
          }
          groupBy: {
            args: Prisma.EvaluationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EvaluationGroupByOutputType>[]
          }
          count: {
            args: Prisma.EvaluationCountArgs<ExtArgs>,
            result: $Utils.Optional<EvaluationCountAggregateOutputType> | number
          }
        }
      }
      Exercise: {
        payload: ExercisePayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.ExerciseFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ExercisePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExerciseFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ExercisePayload>
          }
          findFirst: {
            args: Prisma.ExerciseFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ExercisePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExerciseFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ExercisePayload>
          }
          findMany: {
            args: Prisma.ExerciseFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ExercisePayload>[]
          }
          create: {
            args: Prisma.ExerciseCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ExercisePayload>
          }
          createMany: {
            args: Prisma.ExerciseCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ExerciseDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ExercisePayload>
          }
          update: {
            args: Prisma.ExerciseUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ExercisePayload>
          }
          deleteMany: {
            args: Prisma.ExerciseDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ExerciseUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ExerciseUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ExercisePayload>
          }
          aggregate: {
            args: Prisma.ExerciseAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateExercise>
          }
          groupBy: {
            args: Prisma.ExerciseGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ExerciseGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExerciseCountArgs<ExtArgs>,
            result: $Utils.Optional<ExerciseCountAggregateOutputType> | number
          }
        }
      }
      Template: {
        payload: TemplatePayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.TemplateFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TemplateFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TemplatePayload>
          }
          findFirst: {
            args: Prisma.TemplateFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TemplateFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TemplatePayload>
          }
          findMany: {
            args: Prisma.TemplateFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TemplatePayload>[]
          }
          create: {
            args: Prisma.TemplateCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TemplatePayload>
          }
          createMany: {
            args: Prisma.TemplateCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TemplateDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TemplatePayload>
          }
          update: {
            args: Prisma.TemplateUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TemplatePayload>
          }
          deleteMany: {
            args: Prisma.TemplateDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TemplateUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TemplateUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<TemplatePayload>
          }
          aggregate: {
            args: Prisma.TemplateAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTemplate>
          }
          groupBy: {
            args: Prisma.TemplateGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.TemplateCountArgs<ExtArgs>,
            result: $Utils.Optional<TemplateCountAggregateOutputType> | number
          }
        }
      }
      Course: {
        payload: CoursePayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.CourseFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CoursePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CoursePayload>
          }
          findFirst: {
            args: Prisma.CourseFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CoursePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CoursePayload>
          }
          findMany: {
            args: Prisma.CourseFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CoursePayload>[]
          }
          create: {
            args: Prisma.CourseCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CoursePayload>
          }
          createMany: {
            args: Prisma.CourseCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CourseDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CoursePayload>
          }
          update: {
            args: Prisma.CourseUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CoursePayload>
          }
          deleteMany: {
            args: Prisma.CourseDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CourseUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CourseUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<CoursePayload>
          }
          aggregate: {
            args: Prisma.CourseAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCourse>
          }
          groupBy: {
            args: Prisma.CourseGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CourseGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseCountArgs<ExtArgs>,
            result: $Utils.Optional<CourseCountAggregateOutputType> | number
          }
        }
      }
      Lesson: {
        payload: LessonPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.LessonFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LessonPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LessonFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LessonPayload>
          }
          findFirst: {
            args: Prisma.LessonFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LessonPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LessonFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LessonPayload>
          }
          findMany: {
            args: Prisma.LessonFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LessonPayload>[]
          }
          create: {
            args: Prisma.LessonCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LessonPayload>
          }
          createMany: {
            args: Prisma.LessonCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.LessonDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LessonPayload>
          }
          update: {
            args: Prisma.LessonUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LessonPayload>
          }
          deleteMany: {
            args: Prisma.LessonDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.LessonUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.LessonUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LessonPayload>
          }
          aggregate: {
            args: Prisma.LessonAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLesson>
          }
          groupBy: {
            args: Prisma.LessonGroupByArgs<ExtArgs>,
            result: $Utils.Optional<LessonGroupByOutputType>[]
          }
          count: {
            args: Prisma.LessonCountArgs<ExtArgs>,
            result: $Utils.Optional<LessonCountAggregateOutputType> | number
          }
        }
      }
      LessonVideo: {
        payload: LessonVideoPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.LessonVideoFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LessonVideoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LessonVideoFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LessonVideoPayload>
          }
          findFirst: {
            args: Prisma.LessonVideoFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LessonVideoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LessonVideoFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LessonVideoPayload>
          }
          findMany: {
            args: Prisma.LessonVideoFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LessonVideoPayload>[]
          }
          create: {
            args: Prisma.LessonVideoCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LessonVideoPayload>
          }
          createMany: {
            args: Prisma.LessonVideoCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.LessonVideoDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LessonVideoPayload>
          }
          update: {
            args: Prisma.LessonVideoUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LessonVideoPayload>
          }
          deleteMany: {
            args: Prisma.LessonVideoDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.LessonVideoUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.LessonVideoUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LessonVideoPayload>
          }
          aggregate: {
            args: Prisma.LessonVideoAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLessonVideo>
          }
          groupBy: {
            args: Prisma.LessonVideoGroupByArgs<ExtArgs>,
            result: $Utils.Optional<LessonVideoGroupByOutputType>[]
          }
          count: {
            args: Prisma.LessonVideoCountArgs<ExtArgs>,
            result: $Utils.Optional<LessonVideoCountAggregateOutputType> | number
          }
        }
      }
      WatchedVideo: {
        payload: WatchedVideoPayload<ExtArgs>
        operations: {
          findUnique: {
            args: Prisma.WatchedVideoFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<WatchedVideoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WatchedVideoFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<WatchedVideoPayload>
          }
          findFirst: {
            args: Prisma.WatchedVideoFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<WatchedVideoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WatchedVideoFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<WatchedVideoPayload>
          }
          findMany: {
            args: Prisma.WatchedVideoFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<WatchedVideoPayload>[]
          }
          create: {
            args: Prisma.WatchedVideoCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<WatchedVideoPayload>
          }
          createMany: {
            args: Prisma.WatchedVideoCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.WatchedVideoDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<WatchedVideoPayload>
          }
          update: {
            args: Prisma.WatchedVideoUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<WatchedVideoPayload>
          }
          deleteMany: {
            args: Prisma.WatchedVideoDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.WatchedVideoUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.WatchedVideoUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<WatchedVideoPayload>
          }
          aggregate: {
            args: Prisma.WatchedVideoAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateWatchedVideo>
          }
          groupBy: {
            args: Prisma.WatchedVideoGroupByArgs<ExtArgs>,
            result: $Utils.Optional<WatchedVideoGroupByOutputType>[]
          }
          count: {
            args: Prisma.WatchedVideoCountArgs<ExtArgs>,
            result: $Utils.Optional<WatchedVideoCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */


  export type UserCountOutputType = {
    addresses: number
    contacts: number
    DoctorPatient: number
    exercises: number
    courses: number
    lessons: number
    watched: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    addresses?: boolean
    contacts?: boolean
    DoctorPatient?: boolean
    exercises?: boolean
    courses?: boolean
    lessons?: boolean
    watched?: boolean
  }

  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }



  /**
   * Count Type PatientCountOutputType
   */


  export type PatientCountOutputType = {
    anamnesis: number
    evaluations: number
    doctorPatient: number
    evolutions: number
    appointment: number
  }

  export type PatientCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    anamnesis?: boolean
    evaluations?: boolean
    doctorPatient?: boolean
    evolutions?: boolean
    appointment?: boolean
  }

  // Custom InputTypes

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientCountOutputType
     */
    select?: PatientCountOutputTypeSelect<ExtArgs> | null
  }



  /**
   * Count Type DoctorCountOutputType
   */


  export type DoctorCountOutputType = {
    anamnesis: number
    evaluations: number
    doctorPatient: number
    templates: number
    evolutions: number
    appointments: number
  }

  export type DoctorCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    anamnesis?: boolean
    evaluations?: boolean
    doctorPatient?: boolean
    templates?: boolean
    evolutions?: boolean
    appointments?: boolean
  }

  // Custom InputTypes

  /**
   * DoctorCountOutputType without action
   */
  export type DoctorCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorCountOutputType
     */
    select?: DoctorCountOutputTypeSelect<ExtArgs> | null
  }



  /**
   * Count Type SpecialtyCountOutputType
   */


  export type SpecialtyCountOutputType = {
    doctors: number
    templates: number
    evaluations: number
    anamnesis: number
    evolution: number
    exercise: number
    course: number
  }

  export type SpecialtyCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    doctors?: boolean
    templates?: boolean
    evaluations?: boolean
    anamnesis?: boolean
    evolution?: boolean
    exercise?: boolean
    course?: boolean
  }

  // Custom InputTypes

  /**
   * SpecialtyCountOutputType without action
   */
  export type SpecialtyCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpecialtyCountOutputType
     */
    select?: SpecialtyCountOutputTypeSelect<ExtArgs> | null
  }



  /**
   * Count Type CourseCountOutputType
   */


  export type CourseCountOutputType = {
    lessons: number
  }

  export type CourseCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    lessons?: boolean
  }

  // Custom InputTypes

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseCountOutputType
     */
    select?: CourseCountOutputTypeSelect<ExtArgs> | null
  }



  /**
   * Count Type LessonCountOutputType
   */


  export type LessonCountOutputType = {
    videos: number
  }

  export type LessonCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    videos?: boolean
  }

  // Custom InputTypes

  /**
   * LessonCountOutputType without action
   */
  export type LessonCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonCountOutputType
     */
    select?: LessonCountOutputTypeSelect<ExtArgs> | null
  }



  /**
   * Count Type LessonVideoCountOutputType
   */


  export type LessonVideoCountOutputType = {
    watched: number
  }

  export type LessonVideoCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    watched?: boolean
  }

  // Custom InputTypes

  /**
   * LessonVideoCountOutputType without action
   */
  export type LessonVideoCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonVideoCountOutputType
     */
    select?: LessonVideoCountOutputTypeSelect<ExtArgs> | null
  }



  /**
   * Models
   */

  /**
   * Model User
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    numericId: number | null
  }

  export type UserSumAggregateOutputType = {
    numericId: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    numericId: number | null
    socialName: string | null
    email: string | null
    name: string | null
    gender: string | null
    customGender: string | null
    cpf: string | null
    birthDate: Date | null
    password: string | null
    type: UserType | null
    avatar: string | null
    facebookToken: string | null
    passwordResetToken: string | null
    passwordResetExpires: Date | null
    isAdmin: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    numericId: number | null
    socialName: string | null
    email: string | null
    name: string | null
    gender: string | null
    customGender: string | null
    cpf: string | null
    birthDate: Date | null
    password: string | null
    type: UserType | null
    avatar: string | null
    facebookToken: string | null
    passwordResetToken: string | null
    passwordResetExpires: Date | null
    isAdmin: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    numericId: number
    socialName: number
    email: number
    name: number
    gender: number
    customGender: number
    cpf: number
    birthDate: number
    password: number
    type: number
    avatar: number
    facebookToken: number
    passwordResetToken: number
    passwordResetExpires: number
    isAdmin: number
    isActive: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    numericId?: true
  }

  export type UserSumAggregateInputType = {
    numericId?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    numericId?: true
    socialName?: true
    email?: true
    name?: true
    gender?: true
    customGender?: true
    cpf?: true
    birthDate?: true
    password?: true
    type?: true
    avatar?: true
    facebookToken?: true
    passwordResetToken?: true
    passwordResetExpires?: true
    isAdmin?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    numericId?: true
    socialName?: true
    email?: true
    name?: true
    gender?: true
    customGender?: true
    cpf?: true
    birthDate?: true
    password?: true
    type?: true
    avatar?: true
    facebookToken?: true
    passwordResetToken?: true
    passwordResetExpires?: true
    isAdmin?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    numericId?: true
    socialName?: true
    email?: true
    name?: true
    gender?: true
    customGender?: true
    cpf?: true
    birthDate?: true
    password?: true
    type?: true
    avatar?: true
    facebookToken?: true
    passwordResetToken?: true
    passwordResetExpires?: true
    isAdmin?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithAggregationInput>
    by: UserScalarFieldEnum[]
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: string
    numericId: number
    socialName: string | null
    email: string
    name: string
    gender: string | null
    customGender: string | null
    cpf: string | null
    birthDate: Date | null
    password: string
    type: UserType
    avatar: string | null
    facebookToken: string | null
    passwordResetToken: string | null
    passwordResetExpires: Date | null
    isAdmin: boolean
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    numericId?: boolean
    socialName?: boolean
    email?: boolean
    name?: boolean
    gender?: boolean
    customGender?: boolean
    cpf?: boolean
    birthDate?: boolean
    password?: boolean
    type?: boolean
    avatar?: boolean
    facebookToken?: boolean
    passwordResetToken?: boolean
    passwordResetExpires?: boolean
    isAdmin?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    patientData?: boolean | PatientArgs<ExtArgs>
    doctorData?: boolean | DoctorArgs<ExtArgs>
    addresses?: boolean | User$addressesArgs<ExtArgs>
    contacts?: boolean | User$contactsArgs<ExtArgs>
    DoctorPatient?: boolean | User$DoctorPatientArgs<ExtArgs>
    exercises?: boolean | User$exercisesArgs<ExtArgs>
    courses?: boolean | User$coursesArgs<ExtArgs>
    lessons?: boolean | User$lessonsArgs<ExtArgs>
    watched?: boolean | User$watchedArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    numericId?: boolean
    socialName?: boolean
    email?: boolean
    name?: boolean
    gender?: boolean
    customGender?: boolean
    cpf?: boolean
    birthDate?: boolean
    password?: boolean
    type?: boolean
    avatar?: boolean
    facebookToken?: boolean
    passwordResetToken?: boolean
    passwordResetExpires?: boolean
    isAdmin?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    patientData?: boolean | PatientArgs<ExtArgs>
    doctorData?: boolean | DoctorArgs<ExtArgs>
    addresses?: boolean | User$addressesArgs<ExtArgs>
    contacts?: boolean | User$contactsArgs<ExtArgs>
    DoctorPatient?: boolean | User$DoctorPatientArgs<ExtArgs>
    exercises?: boolean | User$exercisesArgs<ExtArgs>
    courses?: boolean | User$coursesArgs<ExtArgs>
    lessons?: boolean | User$lessonsArgs<ExtArgs>
    watched?: boolean | User$watchedArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeArgs<ExtArgs>
  }


  type UserGetPayload<S extends boolean | null | undefined | UserArgs> = $Types.GetResult<UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<UserPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    patientData<T extends PatientArgs<ExtArgs> = {}>(args?: Subset<T, PatientArgs<ExtArgs>>): Prisma__PatientClient<$Types.GetResult<PatientPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    doctorData<T extends DoctorArgs<ExtArgs> = {}>(args?: Subset<T, DoctorArgs<ExtArgs>>): Prisma__DoctorClient<$Types.GetResult<DoctorPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    addresses<T extends User$addressesArgs<ExtArgs> = {}>(args?: Subset<T, User$addressesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<UserAdressPayload<ExtArgs>, T, 'findMany', never>| Null>;

    contacts<T extends User$contactsArgs<ExtArgs> = {}>(args?: Subset<T, User$contactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<UserContactPayload<ExtArgs>, T, 'findMany', never>| Null>;

    DoctorPatient<T extends User$DoctorPatientArgs<ExtArgs> = {}>(args?: Subset<T, User$DoctorPatientArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<DoctorPatientPayload<ExtArgs>, T, 'findMany', never>| Null>;

    exercises<T extends User$exercisesArgs<ExtArgs> = {}>(args?: Subset<T, User$exercisesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ExercisePayload<ExtArgs>, T, 'findMany', never>| Null>;

    courses<T extends User$coursesArgs<ExtArgs> = {}>(args?: Subset<T, User$coursesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<CoursePayload<ExtArgs>, T, 'findMany', never>| Null>;

    lessons<T extends User$lessonsArgs<ExtArgs> = {}>(args?: Subset<T, User$lessonsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<LessonPayload<ExtArgs>, T, 'findMany', never>| Null>;

    watched<T extends User$watchedArgs<ExtArgs> = {}>(args?: Subset<T, User$watchedArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<WatchedVideoPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * User base type for findUnique actions
   */
  export type UserFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUnique
   */
  export interface UserFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends UserFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User base type for findFirst actions
   */
  export type UserFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }

  /**
   * User findFirst
   */
  export interface UserFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends UserFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: Enumerable<UserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }


  /**
   * User.addresses
   */
  export type User$addressesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAdress
     */
    select?: UserAdressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserAdressInclude<ExtArgs> | null
    where?: UserAdressWhereInput
    orderBy?: Enumerable<UserAdressOrderByWithRelationInput>
    cursor?: UserAdressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserAdressScalarFieldEnum>
  }


  /**
   * User.contacts
   */
  export type User$contactsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserContact
     */
    select?: UserContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserContactInclude<ExtArgs> | null
    where?: UserContactWhereInput
    orderBy?: Enumerable<UserContactOrderByWithRelationInput>
    cursor?: UserContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserContactScalarFieldEnum>
  }


  /**
   * User.DoctorPatient
   */
  export type User$DoctorPatientArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorPatient
     */
    select?: DoctorPatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DoctorPatientInclude<ExtArgs> | null
    where?: DoctorPatientWhereInput
    orderBy?: Enumerable<DoctorPatientOrderByWithRelationInput>
    cursor?: DoctorPatientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<DoctorPatientScalarFieldEnum>
  }


  /**
   * User.exercises
   */
  export type User$exercisesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExerciseInclude<ExtArgs> | null
    where?: ExerciseWhereInput
    orderBy?: Enumerable<ExerciseOrderByWithRelationInput>
    cursor?: ExerciseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ExerciseScalarFieldEnum>
  }


  /**
   * User.courses
   */
  export type User$coursesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CourseInclude<ExtArgs> | null
    where?: CourseWhereInput
    orderBy?: Enumerable<CourseOrderByWithRelationInput>
    cursor?: CourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CourseScalarFieldEnum>
  }


  /**
   * User.lessons
   */
  export type User$lessonsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LessonInclude<ExtArgs> | null
    where?: LessonWhereInput
    orderBy?: Enumerable<LessonOrderByWithRelationInput>
    cursor?: LessonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<LessonScalarFieldEnum>
  }


  /**
   * User.watched
   */
  export type User$watchedArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchedVideo
     */
    select?: WatchedVideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WatchedVideoInclude<ExtArgs> | null
    where?: WatchedVideoWhereInput
    orderBy?: Enumerable<WatchedVideoOrderByWithRelationInput>
    cursor?: WatchedVideoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<WatchedVideoScalarFieldEnum>
  }


  /**
   * User without action
   */
  export type UserArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
  }



  /**
   * Model UserAdress
   */


  export type AggregateUserAdress = {
    _count: UserAdressCountAggregateOutputType | null
    _avg: UserAdressAvgAggregateOutputType | null
    _sum: UserAdressSumAggregateOutputType | null
    _min: UserAdressMinAggregateOutputType | null
    _max: UserAdressMaxAggregateOutputType | null
  }

  export type UserAdressAvgAggregateOutputType = {
    numericId: number | null
  }

  export type UserAdressSumAggregateOutputType = {
    numericId: number | null
  }

  export type UserAdressMinAggregateOutputType = {
    id: string | null
    numericId: number | null
    userId: string | null
    streetName: string | null
    zipCode: string | null
    district: string | null
    state: string | null
    city: string | null
    number: string | null
    complement: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type UserAdressMaxAggregateOutputType = {
    id: string | null
    numericId: number | null
    userId: string | null
    streetName: string | null
    zipCode: string | null
    district: string | null
    state: string | null
    city: string | null
    number: string | null
    complement: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type UserAdressCountAggregateOutputType = {
    id: number
    numericId: number
    userId: number
    streetName: number
    zipCode: number
    district: number
    state: number
    city: number
    number: number
    complement: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type UserAdressAvgAggregateInputType = {
    numericId?: true
  }

  export type UserAdressSumAggregateInputType = {
    numericId?: true
  }

  export type UserAdressMinAggregateInputType = {
    id?: true
    numericId?: true
    userId?: true
    streetName?: true
    zipCode?: true
    district?: true
    state?: true
    city?: true
    number?: true
    complement?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type UserAdressMaxAggregateInputType = {
    id?: true
    numericId?: true
    userId?: true
    streetName?: true
    zipCode?: true
    district?: true
    state?: true
    city?: true
    number?: true
    complement?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type UserAdressCountAggregateInputType = {
    id?: true
    numericId?: true
    userId?: true
    streetName?: true
    zipCode?: true
    district?: true
    state?: true
    city?: true
    number?: true
    complement?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type UserAdressAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAdress to aggregate.
     */
    where?: UserAdressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAdresses to fetch.
     */
    orderBy?: Enumerable<UserAdressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserAdressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAdresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAdresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserAdresses
    **/
    _count?: true | UserAdressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAdressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserAdressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserAdressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserAdressMaxAggregateInputType
  }

  export type GetUserAdressAggregateType<T extends UserAdressAggregateArgs> = {
        [P in keyof T & keyof AggregateUserAdress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserAdress[P]>
      : GetScalarType<T[P], AggregateUserAdress[P]>
  }




  export type UserAdressGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UserAdressWhereInput
    orderBy?: Enumerable<UserAdressOrderByWithAggregationInput>
    by: UserAdressScalarFieldEnum[]
    having?: UserAdressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserAdressCountAggregateInputType | true
    _avg?: UserAdressAvgAggregateInputType
    _sum?: UserAdressSumAggregateInputType
    _min?: UserAdressMinAggregateInputType
    _max?: UserAdressMaxAggregateInputType
  }


  export type UserAdressGroupByOutputType = {
    id: string
    numericId: number
    userId: string
    streetName: string
    zipCode: string
    district: string
    state: string
    city: string
    number: string
    complement: string | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: UserAdressCountAggregateOutputType | null
    _avg: UserAdressAvgAggregateOutputType | null
    _sum: UserAdressSumAggregateOutputType | null
    _min: UserAdressMinAggregateOutputType | null
    _max: UserAdressMaxAggregateOutputType | null
  }

  type GetUserAdressGroupByPayload<T extends UserAdressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UserAdressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserAdressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserAdressGroupByOutputType[P]>
            : GetScalarType<T[P], UserAdressGroupByOutputType[P]>
        }
      >
    >


  export type UserAdressSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    numericId?: boolean
    userId?: boolean
    streetName?: boolean
    zipCode?: boolean
    district?: boolean
    state?: boolean
    city?: boolean
    number?: boolean
    complement?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserArgs<ExtArgs>
  }, ExtArgs["result"]["userAdress"]>

  export type UserAdressSelectScalar = {
    id?: boolean
    numericId?: boolean
    userId?: boolean
    streetName?: boolean
    zipCode?: boolean
    district?: boolean
    state?: boolean
    city?: boolean
    number?: boolean
    complement?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type UserAdressInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserArgs<ExtArgs>
  }


  type UserAdressGetPayload<S extends boolean | null | undefined | UserAdressArgs> = $Types.GetResult<UserAdressPayload, S>

  type UserAdressCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<UserAdressFindManyArgs, 'select' | 'include'> & {
      select?: UserAdressCountAggregateInputType | true
    }

  export interface UserAdressDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserAdress'], meta: { name: 'UserAdress' } }
    /**
     * Find zero or one UserAdress that matches the filter.
     * @param {UserAdressFindUniqueArgs} args - Arguments to find a UserAdress
     * @example
     * // Get one UserAdress
     * const userAdress = await prisma.userAdress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserAdressFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserAdressFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserAdress'> extends True ? Prisma__UserAdressClient<$Types.GetResult<UserAdressPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__UserAdressClient<$Types.GetResult<UserAdressPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one UserAdress that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserAdressFindUniqueOrThrowArgs} args - Arguments to find a UserAdress
     * @example
     * // Get one UserAdress
     * const userAdress = await prisma.userAdress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserAdressFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserAdressFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserAdressClient<$Types.GetResult<UserAdressPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first UserAdress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAdressFindFirstArgs} args - Arguments to find a UserAdress
     * @example
     * // Get one UserAdress
     * const userAdress = await prisma.userAdress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserAdressFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserAdressFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserAdress'> extends True ? Prisma__UserAdressClient<$Types.GetResult<UserAdressPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__UserAdressClient<$Types.GetResult<UserAdressPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first UserAdress that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAdressFindFirstOrThrowArgs} args - Arguments to find a UserAdress
     * @example
     * // Get one UserAdress
     * const userAdress = await prisma.userAdress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserAdressFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserAdressFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserAdressClient<$Types.GetResult<UserAdressPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more UserAdresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAdressFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserAdresses
     * const userAdresses = await prisma.userAdress.findMany()
     * 
     * // Get first 10 UserAdresses
     * const userAdresses = await prisma.userAdress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userAdressWithIdOnly = await prisma.userAdress.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserAdressFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserAdressFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<UserAdressPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a UserAdress.
     * @param {UserAdressCreateArgs} args - Arguments to create a UserAdress.
     * @example
     * // Create one UserAdress
     * const UserAdress = await prisma.userAdress.create({
     *   data: {
     *     // ... data to create a UserAdress
     *   }
     * })
     * 
    **/
    create<T extends UserAdressCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserAdressCreateArgs<ExtArgs>>
    ): Prisma__UserAdressClient<$Types.GetResult<UserAdressPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many UserAdresses.
     *     @param {UserAdressCreateManyArgs} args - Arguments to create many UserAdresses.
     *     @example
     *     // Create many UserAdresses
     *     const userAdress = await prisma.userAdress.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserAdressCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserAdressCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserAdress.
     * @param {UserAdressDeleteArgs} args - Arguments to delete one UserAdress.
     * @example
     * // Delete one UserAdress
     * const UserAdress = await prisma.userAdress.delete({
     *   where: {
     *     // ... filter to delete one UserAdress
     *   }
     * })
     * 
    **/
    delete<T extends UserAdressDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserAdressDeleteArgs<ExtArgs>>
    ): Prisma__UserAdressClient<$Types.GetResult<UserAdressPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one UserAdress.
     * @param {UserAdressUpdateArgs} args - Arguments to update one UserAdress.
     * @example
     * // Update one UserAdress
     * const userAdress = await prisma.userAdress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserAdressUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserAdressUpdateArgs<ExtArgs>>
    ): Prisma__UserAdressClient<$Types.GetResult<UserAdressPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more UserAdresses.
     * @param {UserAdressDeleteManyArgs} args - Arguments to filter UserAdresses to delete.
     * @example
     * // Delete a few UserAdresses
     * const { count } = await prisma.userAdress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserAdressDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserAdressDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAdresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAdressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserAdresses
     * const userAdress = await prisma.userAdress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserAdressUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserAdressUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserAdress.
     * @param {UserAdressUpsertArgs} args - Arguments to update or create a UserAdress.
     * @example
     * // Update or create a UserAdress
     * const userAdress = await prisma.userAdress.upsert({
     *   create: {
     *     // ... data to create a UserAdress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserAdress we want to update
     *   }
     * })
    **/
    upsert<T extends UserAdressUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserAdressUpsertArgs<ExtArgs>>
    ): Prisma__UserAdressClient<$Types.GetResult<UserAdressPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of UserAdresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAdressCountArgs} args - Arguments to filter UserAdresses to count.
     * @example
     * // Count the number of UserAdresses
     * const count = await prisma.userAdress.count({
     *   where: {
     *     // ... the filter for the UserAdresses we want to count
     *   }
     * })
    **/
    count<T extends UserAdressCountArgs>(
      args?: Subset<T, UserAdressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserAdressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserAdress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAdressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAdressAggregateArgs>(args: Subset<T, UserAdressAggregateArgs>): Prisma.PrismaPromise<GetUserAdressAggregateType<T>>

    /**
     * Group by UserAdress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAdressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserAdressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserAdressGroupByArgs['orderBy'] }
        : { orderBy?: UserAdressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserAdressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserAdressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for UserAdress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserAdressClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * UserAdress base type for findUnique actions
   */
  export type UserAdressFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAdress
     */
    select?: UserAdressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserAdressInclude<ExtArgs> | null
    /**
     * Filter, which UserAdress to fetch.
     */
    where: UserAdressWhereUniqueInput
  }

  /**
   * UserAdress findUnique
   */
  export interface UserAdressFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends UserAdressFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserAdress findUniqueOrThrow
   */
  export type UserAdressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAdress
     */
    select?: UserAdressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserAdressInclude<ExtArgs> | null
    /**
     * Filter, which UserAdress to fetch.
     */
    where: UserAdressWhereUniqueInput
  }


  /**
   * UserAdress base type for findFirst actions
   */
  export type UserAdressFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAdress
     */
    select?: UserAdressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserAdressInclude<ExtArgs> | null
    /**
     * Filter, which UserAdress to fetch.
     */
    where?: UserAdressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAdresses to fetch.
     */
    orderBy?: Enumerable<UserAdressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAdresses.
     */
    cursor?: UserAdressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAdresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAdresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAdresses.
     */
    distinct?: Enumerable<UserAdressScalarFieldEnum>
  }

  /**
   * UserAdress findFirst
   */
  export interface UserAdressFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends UserAdressFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserAdress findFirstOrThrow
   */
  export type UserAdressFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAdress
     */
    select?: UserAdressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserAdressInclude<ExtArgs> | null
    /**
     * Filter, which UserAdress to fetch.
     */
    where?: UserAdressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAdresses to fetch.
     */
    orderBy?: Enumerable<UserAdressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAdresses.
     */
    cursor?: UserAdressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAdresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAdresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAdresses.
     */
    distinct?: Enumerable<UserAdressScalarFieldEnum>
  }


  /**
   * UserAdress findMany
   */
  export type UserAdressFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAdress
     */
    select?: UserAdressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserAdressInclude<ExtArgs> | null
    /**
     * Filter, which UserAdresses to fetch.
     */
    where?: UserAdressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAdresses to fetch.
     */
    orderBy?: Enumerable<UserAdressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserAdresses.
     */
    cursor?: UserAdressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAdresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAdresses.
     */
    skip?: number
    distinct?: Enumerable<UserAdressScalarFieldEnum>
  }


  /**
   * UserAdress create
   */
  export type UserAdressCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAdress
     */
    select?: UserAdressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserAdressInclude<ExtArgs> | null
    /**
     * The data needed to create a UserAdress.
     */
    data: XOR<UserAdressCreateInput, UserAdressUncheckedCreateInput>
  }


  /**
   * UserAdress createMany
   */
  export type UserAdressCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserAdresses.
     */
    data: Enumerable<UserAdressCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * UserAdress update
   */
  export type UserAdressUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAdress
     */
    select?: UserAdressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserAdressInclude<ExtArgs> | null
    /**
     * The data needed to update a UserAdress.
     */
    data: XOR<UserAdressUpdateInput, UserAdressUncheckedUpdateInput>
    /**
     * Choose, which UserAdress to update.
     */
    where: UserAdressWhereUniqueInput
  }


  /**
   * UserAdress updateMany
   */
  export type UserAdressUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserAdresses.
     */
    data: XOR<UserAdressUpdateManyMutationInput, UserAdressUncheckedUpdateManyInput>
    /**
     * Filter which UserAdresses to update
     */
    where?: UserAdressWhereInput
  }


  /**
   * UserAdress upsert
   */
  export type UserAdressUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAdress
     */
    select?: UserAdressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserAdressInclude<ExtArgs> | null
    /**
     * The filter to search for the UserAdress to update in case it exists.
     */
    where: UserAdressWhereUniqueInput
    /**
     * In case the UserAdress found by the `where` argument doesn't exist, create a new UserAdress with this data.
     */
    create: XOR<UserAdressCreateInput, UserAdressUncheckedCreateInput>
    /**
     * In case the UserAdress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserAdressUpdateInput, UserAdressUncheckedUpdateInput>
  }


  /**
   * UserAdress delete
   */
  export type UserAdressDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAdress
     */
    select?: UserAdressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserAdressInclude<ExtArgs> | null
    /**
     * Filter which UserAdress to delete.
     */
    where: UserAdressWhereUniqueInput
  }


  /**
   * UserAdress deleteMany
   */
  export type UserAdressDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAdresses to delete
     */
    where?: UserAdressWhereInput
  }


  /**
   * UserAdress without action
   */
  export type UserAdressArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAdress
     */
    select?: UserAdressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserAdressInclude<ExtArgs> | null
  }



  /**
   * Model UserContact
   */


  export type AggregateUserContact = {
    _count: UserContactCountAggregateOutputType | null
    _avg: UserContactAvgAggregateOutputType | null
    _sum: UserContactSumAggregateOutputType | null
    _min: UserContactMinAggregateOutputType | null
    _max: UserContactMaxAggregateOutputType | null
  }

  export type UserContactAvgAggregateOutputType = {
    numericId: number | null
  }

  export type UserContactSumAggregateOutputType = {
    numericId: number | null
  }

  export type UserContactMinAggregateOutputType = {
    id: string | null
    numericId: number | null
    userId: string | null
    email: string | null
    area: string | null
    phone: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type UserContactMaxAggregateOutputType = {
    id: string | null
    numericId: number | null
    userId: string | null
    email: string | null
    area: string | null
    phone: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type UserContactCountAggregateOutputType = {
    id: number
    numericId: number
    userId: number
    email: number
    area: number
    phone: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type UserContactAvgAggregateInputType = {
    numericId?: true
  }

  export type UserContactSumAggregateInputType = {
    numericId?: true
  }

  export type UserContactMinAggregateInputType = {
    id?: true
    numericId?: true
    userId?: true
    email?: true
    area?: true
    phone?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type UserContactMaxAggregateInputType = {
    id?: true
    numericId?: true
    userId?: true
    email?: true
    area?: true
    phone?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type UserContactCountAggregateInputType = {
    id?: true
    numericId?: true
    userId?: true
    email?: true
    area?: true
    phone?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type UserContactAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserContact to aggregate.
     */
    where?: UserContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserContacts to fetch.
     */
    orderBy?: Enumerable<UserContactOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserContacts
    **/
    _count?: true | UserContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserContactAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserContactSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserContactMaxAggregateInputType
  }

  export type GetUserContactAggregateType<T extends UserContactAggregateArgs> = {
        [P in keyof T & keyof AggregateUserContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserContact[P]>
      : GetScalarType<T[P], AggregateUserContact[P]>
  }




  export type UserContactGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UserContactWhereInput
    orderBy?: Enumerable<UserContactOrderByWithAggregationInput>
    by: UserContactScalarFieldEnum[]
    having?: UserContactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserContactCountAggregateInputType | true
    _avg?: UserContactAvgAggregateInputType
    _sum?: UserContactSumAggregateInputType
    _min?: UserContactMinAggregateInputType
    _max?: UserContactMaxAggregateInputType
  }


  export type UserContactGroupByOutputType = {
    id: string
    numericId: number
    userId: string
    email: string | null
    area: string
    phone: string
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: UserContactCountAggregateOutputType | null
    _avg: UserContactAvgAggregateOutputType | null
    _sum: UserContactSumAggregateOutputType | null
    _min: UserContactMinAggregateOutputType | null
    _max: UserContactMaxAggregateOutputType | null
  }

  type GetUserContactGroupByPayload<T extends UserContactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UserContactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserContactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserContactGroupByOutputType[P]>
            : GetScalarType<T[P], UserContactGroupByOutputType[P]>
        }
      >
    >


  export type UserContactSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    numericId?: boolean
    userId?: boolean
    email?: boolean
    area?: boolean
    phone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserArgs<ExtArgs>
  }, ExtArgs["result"]["userContact"]>

  export type UserContactSelectScalar = {
    id?: boolean
    numericId?: boolean
    userId?: boolean
    email?: boolean
    area?: boolean
    phone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type UserContactInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserArgs<ExtArgs>
  }


  type UserContactGetPayload<S extends boolean | null | undefined | UserContactArgs> = $Types.GetResult<UserContactPayload, S>

  type UserContactCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<UserContactFindManyArgs, 'select' | 'include'> & {
      select?: UserContactCountAggregateInputType | true
    }

  export interface UserContactDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserContact'], meta: { name: 'UserContact' } }
    /**
     * Find zero or one UserContact that matches the filter.
     * @param {UserContactFindUniqueArgs} args - Arguments to find a UserContact
     * @example
     * // Get one UserContact
     * const userContact = await prisma.userContact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserContactFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserContactFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserContact'> extends True ? Prisma__UserContactClient<$Types.GetResult<UserContactPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__UserContactClient<$Types.GetResult<UserContactPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one UserContact that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserContactFindUniqueOrThrowArgs} args - Arguments to find a UserContact
     * @example
     * // Get one UserContact
     * const userContact = await prisma.userContact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserContactFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserContactFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserContactClient<$Types.GetResult<UserContactPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first UserContact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserContactFindFirstArgs} args - Arguments to find a UserContact
     * @example
     * // Get one UserContact
     * const userContact = await prisma.userContact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserContactFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserContactFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserContact'> extends True ? Prisma__UserContactClient<$Types.GetResult<UserContactPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__UserContactClient<$Types.GetResult<UserContactPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first UserContact that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserContactFindFirstOrThrowArgs} args - Arguments to find a UserContact
     * @example
     * // Get one UserContact
     * const userContact = await prisma.userContact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserContactFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserContactFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserContactClient<$Types.GetResult<UserContactPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more UserContacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserContactFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserContacts
     * const userContacts = await prisma.userContact.findMany()
     * 
     * // Get first 10 UserContacts
     * const userContacts = await prisma.userContact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userContactWithIdOnly = await prisma.userContact.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserContactFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserContactFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<UserContactPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a UserContact.
     * @param {UserContactCreateArgs} args - Arguments to create a UserContact.
     * @example
     * // Create one UserContact
     * const UserContact = await prisma.userContact.create({
     *   data: {
     *     // ... data to create a UserContact
     *   }
     * })
     * 
    **/
    create<T extends UserContactCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserContactCreateArgs<ExtArgs>>
    ): Prisma__UserContactClient<$Types.GetResult<UserContactPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many UserContacts.
     *     @param {UserContactCreateManyArgs} args - Arguments to create many UserContacts.
     *     @example
     *     // Create many UserContacts
     *     const userContact = await prisma.userContact.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserContactCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserContactCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserContact.
     * @param {UserContactDeleteArgs} args - Arguments to delete one UserContact.
     * @example
     * // Delete one UserContact
     * const UserContact = await prisma.userContact.delete({
     *   where: {
     *     // ... filter to delete one UserContact
     *   }
     * })
     * 
    **/
    delete<T extends UserContactDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserContactDeleteArgs<ExtArgs>>
    ): Prisma__UserContactClient<$Types.GetResult<UserContactPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one UserContact.
     * @param {UserContactUpdateArgs} args - Arguments to update one UserContact.
     * @example
     * // Update one UserContact
     * const userContact = await prisma.userContact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserContactUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserContactUpdateArgs<ExtArgs>>
    ): Prisma__UserContactClient<$Types.GetResult<UserContactPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more UserContacts.
     * @param {UserContactDeleteManyArgs} args - Arguments to filter UserContacts to delete.
     * @example
     * // Delete a few UserContacts
     * const { count } = await prisma.userContact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserContactDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserContactDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserContactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserContacts
     * const userContact = await prisma.userContact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserContactUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserContactUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserContact.
     * @param {UserContactUpsertArgs} args - Arguments to update or create a UserContact.
     * @example
     * // Update or create a UserContact
     * const userContact = await prisma.userContact.upsert({
     *   create: {
     *     // ... data to create a UserContact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserContact we want to update
     *   }
     * })
    **/
    upsert<T extends UserContactUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserContactUpsertArgs<ExtArgs>>
    ): Prisma__UserContactClient<$Types.GetResult<UserContactPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of UserContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserContactCountArgs} args - Arguments to filter UserContacts to count.
     * @example
     * // Count the number of UserContacts
     * const count = await prisma.userContact.count({
     *   where: {
     *     // ... the filter for the UserContacts we want to count
     *   }
     * })
    **/
    count<T extends UserContactCountArgs>(
      args?: Subset<T, UserContactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserContact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserContactAggregateArgs>(args: Subset<T, UserContactAggregateArgs>): Prisma.PrismaPromise<GetUserContactAggregateType<T>>

    /**
     * Group by UserContact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserContactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserContactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserContactGroupByArgs['orderBy'] }
        : { orderBy?: UserContactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserContactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserContactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for UserContact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserContactClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * UserContact base type for findUnique actions
   */
  export type UserContactFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserContact
     */
    select?: UserContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserContactInclude<ExtArgs> | null
    /**
     * Filter, which UserContact to fetch.
     */
    where: UserContactWhereUniqueInput
  }

  /**
   * UserContact findUnique
   */
  export interface UserContactFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends UserContactFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserContact findUniqueOrThrow
   */
  export type UserContactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserContact
     */
    select?: UserContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserContactInclude<ExtArgs> | null
    /**
     * Filter, which UserContact to fetch.
     */
    where: UserContactWhereUniqueInput
  }


  /**
   * UserContact base type for findFirst actions
   */
  export type UserContactFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserContact
     */
    select?: UserContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserContactInclude<ExtArgs> | null
    /**
     * Filter, which UserContact to fetch.
     */
    where?: UserContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserContacts to fetch.
     */
    orderBy?: Enumerable<UserContactOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserContacts.
     */
    cursor?: UserContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserContacts.
     */
    distinct?: Enumerable<UserContactScalarFieldEnum>
  }

  /**
   * UserContact findFirst
   */
  export interface UserContactFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends UserContactFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserContact findFirstOrThrow
   */
  export type UserContactFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserContact
     */
    select?: UserContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserContactInclude<ExtArgs> | null
    /**
     * Filter, which UserContact to fetch.
     */
    where?: UserContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserContacts to fetch.
     */
    orderBy?: Enumerable<UserContactOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserContacts.
     */
    cursor?: UserContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserContacts.
     */
    distinct?: Enumerable<UserContactScalarFieldEnum>
  }


  /**
   * UserContact findMany
   */
  export type UserContactFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserContact
     */
    select?: UserContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserContactInclude<ExtArgs> | null
    /**
     * Filter, which UserContacts to fetch.
     */
    where?: UserContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserContacts to fetch.
     */
    orderBy?: Enumerable<UserContactOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserContacts.
     */
    cursor?: UserContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserContacts.
     */
    skip?: number
    distinct?: Enumerable<UserContactScalarFieldEnum>
  }


  /**
   * UserContact create
   */
  export type UserContactCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserContact
     */
    select?: UserContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserContactInclude<ExtArgs> | null
    /**
     * The data needed to create a UserContact.
     */
    data: XOR<UserContactCreateInput, UserContactUncheckedCreateInput>
  }


  /**
   * UserContact createMany
   */
  export type UserContactCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserContacts.
     */
    data: Enumerable<UserContactCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * UserContact update
   */
  export type UserContactUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserContact
     */
    select?: UserContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserContactInclude<ExtArgs> | null
    /**
     * The data needed to update a UserContact.
     */
    data: XOR<UserContactUpdateInput, UserContactUncheckedUpdateInput>
    /**
     * Choose, which UserContact to update.
     */
    where: UserContactWhereUniqueInput
  }


  /**
   * UserContact updateMany
   */
  export type UserContactUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserContacts.
     */
    data: XOR<UserContactUpdateManyMutationInput, UserContactUncheckedUpdateManyInput>
    /**
     * Filter which UserContacts to update
     */
    where?: UserContactWhereInput
  }


  /**
   * UserContact upsert
   */
  export type UserContactUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserContact
     */
    select?: UserContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserContactInclude<ExtArgs> | null
    /**
     * The filter to search for the UserContact to update in case it exists.
     */
    where: UserContactWhereUniqueInput
    /**
     * In case the UserContact found by the `where` argument doesn't exist, create a new UserContact with this data.
     */
    create: XOR<UserContactCreateInput, UserContactUncheckedCreateInput>
    /**
     * In case the UserContact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserContactUpdateInput, UserContactUncheckedUpdateInput>
  }


  /**
   * UserContact delete
   */
  export type UserContactDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserContact
     */
    select?: UserContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserContactInclude<ExtArgs> | null
    /**
     * Filter which UserContact to delete.
     */
    where: UserContactWhereUniqueInput
  }


  /**
   * UserContact deleteMany
   */
  export type UserContactDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserContacts to delete
     */
    where?: UserContactWhereInput
  }


  /**
   * UserContact without action
   */
  export type UserContactArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserContact
     */
    select?: UserContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserContactInclude<ExtArgs> | null
  }



  /**
   * Model Patient
   */


  export type AggregatePatient = {
    _count: PatientCountAggregateOutputType | null
    _avg: PatientAvgAggregateOutputType | null
    _sum: PatientSumAggregateOutputType | null
    _min: PatientMinAggregateOutputType | null
    _max: PatientMaxAggregateOutputType | null
  }

  export type PatientAvgAggregateOutputType = {
    numericId: number | null
  }

  export type PatientSumAggregateOutputType = {
    numericId: number | null
  }

  export type PatientMinAggregateOutputType = {
    id: string | null
    numericId: number | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type PatientMaxAggregateOutputType = {
    id: string | null
    numericId: number | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type PatientCountAggregateOutputType = {
    id: number
    numericId: number
    userId: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type PatientAvgAggregateInputType = {
    numericId?: true
  }

  export type PatientSumAggregateInputType = {
    numericId?: true
  }

  export type PatientMinAggregateInputType = {
    id?: true
    numericId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type PatientMaxAggregateInputType = {
    id?: true
    numericId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type PatientCountAggregateInputType = {
    id?: true
    numericId?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type PatientAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Patient to aggregate.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: Enumerable<PatientOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Patients
    **/
    _count?: true | PatientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PatientAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PatientSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PatientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PatientMaxAggregateInputType
  }

  export type GetPatientAggregateType<T extends PatientAggregateArgs> = {
        [P in keyof T & keyof AggregatePatient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePatient[P]>
      : GetScalarType<T[P], AggregatePatient[P]>
  }




  export type PatientGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PatientWhereInput
    orderBy?: Enumerable<PatientOrderByWithAggregationInput>
    by: PatientScalarFieldEnum[]
    having?: PatientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PatientCountAggregateInputType | true
    _avg?: PatientAvgAggregateInputType
    _sum?: PatientSumAggregateInputType
    _min?: PatientMinAggregateInputType
    _max?: PatientMaxAggregateInputType
  }


  export type PatientGroupByOutputType = {
    id: string
    numericId: number
    userId: string
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: PatientCountAggregateOutputType | null
    _avg: PatientAvgAggregateOutputType | null
    _sum: PatientSumAggregateOutputType | null
    _min: PatientMinAggregateOutputType | null
    _max: PatientMaxAggregateOutputType | null
  }

  type GetPatientGroupByPayload<T extends PatientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PatientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PatientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PatientGroupByOutputType[P]>
            : GetScalarType<T[P], PatientGroupByOutputType[P]>
        }
      >
    >


  export type PatientSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    numericId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserArgs<ExtArgs>
    anamnesis?: boolean | Patient$anamnesisArgs<ExtArgs>
    evaluations?: boolean | Patient$evaluationsArgs<ExtArgs>
    doctorPatient?: boolean | Patient$doctorPatientArgs<ExtArgs>
    evolutions?: boolean | Patient$evolutionsArgs<ExtArgs>
    appointment?: boolean | Patient$appointmentArgs<ExtArgs>
    _count?: boolean | PatientCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["patient"]>

  export type PatientSelectScalar = {
    id?: boolean
    numericId?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type PatientInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserArgs<ExtArgs>
    anamnesis?: boolean | Patient$anamnesisArgs<ExtArgs>
    evaluations?: boolean | Patient$evaluationsArgs<ExtArgs>
    doctorPatient?: boolean | Patient$doctorPatientArgs<ExtArgs>
    evolutions?: boolean | Patient$evolutionsArgs<ExtArgs>
    appointment?: boolean | Patient$appointmentArgs<ExtArgs>
    _count?: boolean | PatientCountOutputTypeArgs<ExtArgs>
  }


  type PatientGetPayload<S extends boolean | null | undefined | PatientArgs> = $Types.GetResult<PatientPayload, S>

  type PatientCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<PatientFindManyArgs, 'select' | 'include'> & {
      select?: PatientCountAggregateInputType | true
    }

  export interface PatientDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Patient'], meta: { name: 'Patient' } }
    /**
     * Find zero or one Patient that matches the filter.
     * @param {PatientFindUniqueArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PatientFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PatientFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Patient'> extends True ? Prisma__PatientClient<$Types.GetResult<PatientPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__PatientClient<$Types.GetResult<PatientPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Patient that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PatientFindUniqueOrThrowArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PatientFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PatientFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PatientClient<$Types.GetResult<PatientPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Patient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindFirstArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PatientFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PatientFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Patient'> extends True ? Prisma__PatientClient<$Types.GetResult<PatientPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__PatientClient<$Types.GetResult<PatientPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Patient that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindFirstOrThrowArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PatientFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PatientFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PatientClient<$Types.GetResult<PatientPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Patients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Patients
     * const patients = await prisma.patient.findMany()
     * 
     * // Get first 10 Patients
     * const patients = await prisma.patient.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const patientWithIdOnly = await prisma.patient.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PatientFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PatientFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<PatientPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Patient.
     * @param {PatientCreateArgs} args - Arguments to create a Patient.
     * @example
     * // Create one Patient
     * const Patient = await prisma.patient.create({
     *   data: {
     *     // ... data to create a Patient
     *   }
     * })
     * 
    **/
    create<T extends PatientCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PatientCreateArgs<ExtArgs>>
    ): Prisma__PatientClient<$Types.GetResult<PatientPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Patients.
     *     @param {PatientCreateManyArgs} args - Arguments to create many Patients.
     *     @example
     *     // Create many Patients
     *     const patient = await prisma.patient.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PatientCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PatientCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Patient.
     * @param {PatientDeleteArgs} args - Arguments to delete one Patient.
     * @example
     * // Delete one Patient
     * const Patient = await prisma.patient.delete({
     *   where: {
     *     // ... filter to delete one Patient
     *   }
     * })
     * 
    **/
    delete<T extends PatientDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PatientDeleteArgs<ExtArgs>>
    ): Prisma__PatientClient<$Types.GetResult<PatientPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Patient.
     * @param {PatientUpdateArgs} args - Arguments to update one Patient.
     * @example
     * // Update one Patient
     * const patient = await prisma.patient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PatientUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PatientUpdateArgs<ExtArgs>>
    ): Prisma__PatientClient<$Types.GetResult<PatientPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Patients.
     * @param {PatientDeleteManyArgs} args - Arguments to filter Patients to delete.
     * @example
     * // Delete a few Patients
     * const { count } = await prisma.patient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PatientDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PatientDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Patients
     * const patient = await prisma.patient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PatientUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PatientUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Patient.
     * @param {PatientUpsertArgs} args - Arguments to update or create a Patient.
     * @example
     * // Update or create a Patient
     * const patient = await prisma.patient.upsert({
     *   create: {
     *     // ... data to create a Patient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Patient we want to update
     *   }
     * })
    **/
    upsert<T extends PatientUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PatientUpsertArgs<ExtArgs>>
    ): Prisma__PatientClient<$Types.GetResult<PatientPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientCountArgs} args - Arguments to filter Patients to count.
     * @example
     * // Count the number of Patients
     * const count = await prisma.patient.count({
     *   where: {
     *     // ... the filter for the Patients we want to count
     *   }
     * })
    **/
    count<T extends PatientCountArgs>(
      args?: Subset<T, PatientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PatientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Patient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PatientAggregateArgs>(args: Subset<T, PatientAggregateArgs>): Prisma.PrismaPromise<GetPatientAggregateType<T>>

    /**
     * Group by Patient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PatientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PatientGroupByArgs['orderBy'] }
        : { orderBy?: PatientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PatientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPatientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Patient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PatientClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    anamnesis<T extends Patient$anamnesisArgs<ExtArgs> = {}>(args?: Subset<T, Patient$anamnesisArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<AnamnesisPayload<ExtArgs>, T, 'findMany', never>| Null>;

    evaluations<T extends Patient$evaluationsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$evaluationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<EvaluationPayload<ExtArgs>, T, 'findMany', never>| Null>;

    doctorPatient<T extends Patient$doctorPatientArgs<ExtArgs> = {}>(args?: Subset<T, Patient$doctorPatientArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<DoctorPatientPayload<ExtArgs>, T, 'findMany', never>| Null>;

    evolutions<T extends Patient$evolutionsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$evolutionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<EvolutionPayload<ExtArgs>, T, 'findMany', never>| Null>;

    appointment<T extends Patient$appointmentArgs<ExtArgs> = {}>(args?: Subset<T, Patient$appointmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<AppointmentPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Patient base type for findUnique actions
   */
  export type PatientFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient findUnique
   */
  export interface PatientFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends PatientFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Patient findUniqueOrThrow
   */
  export type PatientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where: PatientWhereUniqueInput
  }


  /**
   * Patient base type for findFirst actions
   */
  export type PatientFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: Enumerable<PatientOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Patients.
     */
    distinct?: Enumerable<PatientScalarFieldEnum>
  }

  /**
   * Patient findFirst
   */
  export interface PatientFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends PatientFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Patient findFirstOrThrow
   */
  export type PatientFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: Enumerable<PatientOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Patients.
     */
    distinct?: Enumerable<PatientScalarFieldEnum>
  }


  /**
   * Patient findMany
   */
  export type PatientFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patients to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: Enumerable<PatientOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    distinct?: Enumerable<PatientScalarFieldEnum>
  }


  /**
   * Patient create
   */
  export type PatientCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The data needed to create a Patient.
     */
    data: XOR<PatientCreateInput, PatientUncheckedCreateInput>
  }


  /**
   * Patient createMany
   */
  export type PatientCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Patients.
     */
    data: Enumerable<PatientCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Patient update
   */
  export type PatientUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The data needed to update a Patient.
     */
    data: XOR<PatientUpdateInput, PatientUncheckedUpdateInput>
    /**
     * Choose, which Patient to update.
     */
    where: PatientWhereUniqueInput
  }


  /**
   * Patient updateMany
   */
  export type PatientUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Patients.
     */
    data: XOR<PatientUpdateManyMutationInput, PatientUncheckedUpdateManyInput>
    /**
     * Filter which Patients to update
     */
    where?: PatientWhereInput
  }


  /**
   * Patient upsert
   */
  export type PatientUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The filter to search for the Patient to update in case it exists.
     */
    where: PatientWhereUniqueInput
    /**
     * In case the Patient found by the `where` argument doesn't exist, create a new Patient with this data.
     */
    create: XOR<PatientCreateInput, PatientUncheckedCreateInput>
    /**
     * In case the Patient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PatientUpdateInput, PatientUncheckedUpdateInput>
  }


  /**
   * Patient delete
   */
  export type PatientDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter which Patient to delete.
     */
    where: PatientWhereUniqueInput
  }


  /**
   * Patient deleteMany
   */
  export type PatientDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Patients to delete
     */
    where?: PatientWhereInput
  }


  /**
   * Patient.anamnesis
   */
  export type Patient$anamnesisArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anamnesis
     */
    select?: AnamnesisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnamnesisInclude<ExtArgs> | null
    where?: AnamnesisWhereInput
    orderBy?: Enumerable<AnamnesisOrderByWithRelationInput>
    cursor?: AnamnesisWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<AnamnesisScalarFieldEnum>
  }


  /**
   * Patient.evaluations
   */
  export type Patient$evaluationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EvaluationInclude<ExtArgs> | null
    where?: EvaluationWhereInput
    orderBy?: Enumerable<EvaluationOrderByWithRelationInput>
    cursor?: EvaluationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<EvaluationScalarFieldEnum>
  }


  /**
   * Patient.doctorPatient
   */
  export type Patient$doctorPatientArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorPatient
     */
    select?: DoctorPatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DoctorPatientInclude<ExtArgs> | null
    where?: DoctorPatientWhereInput
    orderBy?: Enumerable<DoctorPatientOrderByWithRelationInput>
    cursor?: DoctorPatientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<DoctorPatientScalarFieldEnum>
  }


  /**
   * Patient.evolutions
   */
  export type Patient$evolutionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evolution
     */
    select?: EvolutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EvolutionInclude<ExtArgs> | null
    where?: EvolutionWhereInput
    orderBy?: Enumerable<EvolutionOrderByWithRelationInput>
    cursor?: EvolutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<EvolutionScalarFieldEnum>
  }


  /**
   * Patient.appointment
   */
  export type Patient$appointmentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: Enumerable<AppointmentOrderByWithRelationInput>
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<AppointmentScalarFieldEnum>
  }


  /**
   * Patient without action
   */
  export type PatientArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PatientInclude<ExtArgs> | null
  }



  /**
   * Model Appointment
   */


  export type AggregateAppointment = {
    _count: AppointmentCountAggregateOutputType | null
    _avg: AppointmentAvgAggregateOutputType | null
    _sum: AppointmentSumAggregateOutputType | null
    _min: AppointmentMinAggregateOutputType | null
    _max: AppointmentMaxAggregateOutputType | null
  }

  export type AppointmentAvgAggregateOutputType = {
    numericId: number | null
  }

  export type AppointmentSumAggregateOutputType = {
    numericId: number | null
  }

  export type AppointmentMinAggregateOutputType = {
    id: string | null
    numericId: number | null
    doctorId: string | null
    patientId: string | null
    when: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    status: AppointmentStatus | null
  }

  export type AppointmentMaxAggregateOutputType = {
    id: string | null
    numericId: number | null
    doctorId: string | null
    patientId: string | null
    when: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    status: AppointmentStatus | null
  }

  export type AppointmentCountAggregateOutputType = {
    id: number
    numericId: number
    doctorId: number
    patientId: number
    when: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    status: number
    _all: number
  }


  export type AppointmentAvgAggregateInputType = {
    numericId?: true
  }

  export type AppointmentSumAggregateInputType = {
    numericId?: true
  }

  export type AppointmentMinAggregateInputType = {
    id?: true
    numericId?: true
    doctorId?: true
    patientId?: true
    when?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    status?: true
  }

  export type AppointmentMaxAggregateInputType = {
    id?: true
    numericId?: true
    doctorId?: true
    patientId?: true
    when?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    status?: true
  }

  export type AppointmentCountAggregateInputType = {
    id?: true
    numericId?: true
    doctorId?: true
    patientId?: true
    when?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    status?: true
    _all?: true
  }

  export type AppointmentAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Appointment to aggregate.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: Enumerable<AppointmentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Appointments
    **/
    _count?: true | AppointmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AppointmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AppointmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AppointmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AppointmentMaxAggregateInputType
  }

  export type GetAppointmentAggregateType<T extends AppointmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAppointment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAppointment[P]>
      : GetScalarType<T[P], AggregateAppointment[P]>
  }




  export type AppointmentGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
    orderBy?: Enumerable<AppointmentOrderByWithAggregationInput>
    by: AppointmentScalarFieldEnum[]
    having?: AppointmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AppointmentCountAggregateInputType | true
    _avg?: AppointmentAvgAggregateInputType
    _sum?: AppointmentSumAggregateInputType
    _min?: AppointmentMinAggregateInputType
    _max?: AppointmentMaxAggregateInputType
  }


  export type AppointmentGroupByOutputType = {
    id: string
    numericId: number
    doctorId: string
    patientId: string
    when: Date
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    status: AppointmentStatus
    _count: AppointmentCountAggregateOutputType | null
    _avg: AppointmentAvgAggregateOutputType | null
    _sum: AppointmentSumAggregateOutputType | null
    _min: AppointmentMinAggregateOutputType | null
    _max: AppointmentMaxAggregateOutputType | null
  }

  type GetAppointmentGroupByPayload<T extends AppointmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<AppointmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AppointmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AppointmentGroupByOutputType[P]>
            : GetScalarType<T[P], AppointmentGroupByOutputType[P]>
        }
      >
    >


  export type AppointmentSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    numericId?: boolean
    doctorId?: boolean
    patientId?: boolean
    when?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    status?: boolean
    doctor?: boolean | DoctorArgs<ExtArgs>
    patient?: boolean | PatientArgs<ExtArgs>
  }, ExtArgs["result"]["appointment"]>

  export type AppointmentSelectScalar = {
    id?: boolean
    numericId?: boolean
    doctorId?: boolean
    patientId?: boolean
    when?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    status?: boolean
  }

  export type AppointmentInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    doctor?: boolean | DoctorArgs<ExtArgs>
    patient?: boolean | PatientArgs<ExtArgs>
  }


  type AppointmentGetPayload<S extends boolean | null | undefined | AppointmentArgs> = $Types.GetResult<AppointmentPayload, S>

  type AppointmentCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<AppointmentFindManyArgs, 'select' | 'include'> & {
      select?: AppointmentCountAggregateInputType | true
    }

  export interface AppointmentDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Appointment'], meta: { name: 'Appointment' } }
    /**
     * Find zero or one Appointment that matches the filter.
     * @param {AppointmentFindUniqueArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AppointmentFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AppointmentFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Appointment'> extends True ? Prisma__AppointmentClient<$Types.GetResult<AppointmentPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__AppointmentClient<$Types.GetResult<AppointmentPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Appointment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AppointmentFindUniqueOrThrowArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AppointmentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AppointmentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AppointmentClient<$Types.GetResult<AppointmentPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Appointment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindFirstArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AppointmentFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AppointmentFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Appointment'> extends True ? Prisma__AppointmentClient<$Types.GetResult<AppointmentPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__AppointmentClient<$Types.GetResult<AppointmentPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Appointment that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindFirstOrThrowArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AppointmentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AppointmentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AppointmentClient<$Types.GetResult<AppointmentPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Appointments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Appointments
     * const appointments = await prisma.appointment.findMany()
     * 
     * // Get first 10 Appointments
     * const appointments = await prisma.appointment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const appointmentWithIdOnly = await prisma.appointment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AppointmentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AppointmentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<AppointmentPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Appointment.
     * @param {AppointmentCreateArgs} args - Arguments to create a Appointment.
     * @example
     * // Create one Appointment
     * const Appointment = await prisma.appointment.create({
     *   data: {
     *     // ... data to create a Appointment
     *   }
     * })
     * 
    **/
    create<T extends AppointmentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AppointmentCreateArgs<ExtArgs>>
    ): Prisma__AppointmentClient<$Types.GetResult<AppointmentPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Appointments.
     *     @param {AppointmentCreateManyArgs} args - Arguments to create many Appointments.
     *     @example
     *     // Create many Appointments
     *     const appointment = await prisma.appointment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AppointmentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AppointmentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Appointment.
     * @param {AppointmentDeleteArgs} args - Arguments to delete one Appointment.
     * @example
     * // Delete one Appointment
     * const Appointment = await prisma.appointment.delete({
     *   where: {
     *     // ... filter to delete one Appointment
     *   }
     * })
     * 
    **/
    delete<T extends AppointmentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AppointmentDeleteArgs<ExtArgs>>
    ): Prisma__AppointmentClient<$Types.GetResult<AppointmentPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Appointment.
     * @param {AppointmentUpdateArgs} args - Arguments to update one Appointment.
     * @example
     * // Update one Appointment
     * const appointment = await prisma.appointment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AppointmentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AppointmentUpdateArgs<ExtArgs>>
    ): Prisma__AppointmentClient<$Types.GetResult<AppointmentPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Appointments.
     * @param {AppointmentDeleteManyArgs} args - Arguments to filter Appointments to delete.
     * @example
     * // Delete a few Appointments
     * const { count } = await prisma.appointment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AppointmentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AppointmentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Appointments
     * const appointment = await prisma.appointment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AppointmentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AppointmentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Appointment.
     * @param {AppointmentUpsertArgs} args - Arguments to update or create a Appointment.
     * @example
     * // Update or create a Appointment
     * const appointment = await prisma.appointment.upsert({
     *   create: {
     *     // ... data to create a Appointment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Appointment we want to update
     *   }
     * })
    **/
    upsert<T extends AppointmentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AppointmentUpsertArgs<ExtArgs>>
    ): Prisma__AppointmentClient<$Types.GetResult<AppointmentPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentCountArgs} args - Arguments to filter Appointments to count.
     * @example
     * // Count the number of Appointments
     * const count = await prisma.appointment.count({
     *   where: {
     *     // ... the filter for the Appointments we want to count
     *   }
     * })
    **/
    count<T extends AppointmentCountArgs>(
      args?: Subset<T, AppointmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AppointmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Appointment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AppointmentAggregateArgs>(args: Subset<T, AppointmentAggregateArgs>): Prisma.PrismaPromise<GetAppointmentAggregateType<T>>

    /**
     * Group by Appointment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AppointmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AppointmentGroupByArgs['orderBy'] }
        : { orderBy?: AppointmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AppointmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAppointmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Appointment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AppointmentClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    doctor<T extends DoctorArgs<ExtArgs> = {}>(args?: Subset<T, DoctorArgs<ExtArgs>>): Prisma__DoctorClient<$Types.GetResult<DoctorPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    patient<T extends PatientArgs<ExtArgs> = {}>(args?: Subset<T, PatientArgs<ExtArgs>>): Prisma__PatientClient<$Types.GetResult<PatientPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Appointment base type for findUnique actions
   */
  export type AppointmentFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment findUnique
   */
  export interface AppointmentFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends AppointmentFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Appointment findUniqueOrThrow
   */
  export type AppointmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where: AppointmentWhereUniqueInput
  }


  /**
   * Appointment base type for findFirst actions
   */
  export type AppointmentFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: Enumerable<AppointmentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Appointments.
     */
    distinct?: Enumerable<AppointmentScalarFieldEnum>
  }

  /**
   * Appointment findFirst
   */
  export interface AppointmentFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends AppointmentFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Appointment findFirstOrThrow
   */
  export type AppointmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: Enumerable<AppointmentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Appointments.
     */
    distinct?: Enumerable<AppointmentScalarFieldEnum>
  }


  /**
   * Appointment findMany
   */
  export type AppointmentFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointments to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: Enumerable<AppointmentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    distinct?: Enumerable<AppointmentScalarFieldEnum>
  }


  /**
   * Appointment create
   */
  export type AppointmentCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Appointment.
     */
    data: XOR<AppointmentCreateInput, AppointmentUncheckedCreateInput>
  }


  /**
   * Appointment createMany
   */
  export type AppointmentCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Appointments.
     */
    data: Enumerable<AppointmentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Appointment update
   */
  export type AppointmentUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Appointment.
     */
    data: XOR<AppointmentUpdateInput, AppointmentUncheckedUpdateInput>
    /**
     * Choose, which Appointment to update.
     */
    where: AppointmentWhereUniqueInput
  }


  /**
   * Appointment updateMany
   */
  export type AppointmentUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Appointments.
     */
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyInput>
    /**
     * Filter which Appointments to update
     */
    where?: AppointmentWhereInput
  }


  /**
   * Appointment upsert
   */
  export type AppointmentUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Appointment to update in case it exists.
     */
    where: AppointmentWhereUniqueInput
    /**
     * In case the Appointment found by the `where` argument doesn't exist, create a new Appointment with this data.
     */
    create: XOR<AppointmentCreateInput, AppointmentUncheckedCreateInput>
    /**
     * In case the Appointment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AppointmentUpdateInput, AppointmentUncheckedUpdateInput>
  }


  /**
   * Appointment delete
   */
  export type AppointmentDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter which Appointment to delete.
     */
    where: AppointmentWhereUniqueInput
  }


  /**
   * Appointment deleteMany
   */
  export type AppointmentDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Appointments to delete
     */
    where?: AppointmentWhereInput
  }


  /**
   * Appointment without action
   */
  export type AppointmentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AppointmentInclude<ExtArgs> | null
  }



  /**
   * Model Doctor
   */


  export type AggregateDoctor = {
    _count: DoctorCountAggregateOutputType | null
    _avg: DoctorAvgAggregateOutputType | null
    _sum: DoctorSumAggregateOutputType | null
    _min: DoctorMinAggregateOutputType | null
    _max: DoctorMaxAggregateOutputType | null
  }

  export type DoctorAvgAggregateOutputType = {
    numericId: number | null
  }

  export type DoctorSumAggregateOutputType = {
    numericId: number | null
  }

  export type DoctorMinAggregateOutputType = {
    id: string | null
    numericId: number | null
    userId: string | null
    specialtyId: string | null
    crfa: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type DoctorMaxAggregateOutputType = {
    id: string | null
    numericId: number | null
    userId: string | null
    specialtyId: string | null
    crfa: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type DoctorCountAggregateOutputType = {
    id: number
    numericId: number
    userId: number
    specialtyId: number
    crfa: number
    availability: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type DoctorAvgAggregateInputType = {
    numericId?: true
  }

  export type DoctorSumAggregateInputType = {
    numericId?: true
  }

  export type DoctorMinAggregateInputType = {
    id?: true
    numericId?: true
    userId?: true
    specialtyId?: true
    crfa?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type DoctorMaxAggregateInputType = {
    id?: true
    numericId?: true
    userId?: true
    specialtyId?: true
    crfa?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type DoctorCountAggregateInputType = {
    id?: true
    numericId?: true
    userId?: true
    specialtyId?: true
    crfa?: true
    availability?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type DoctorAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Doctor to aggregate.
     */
    where?: DoctorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Doctors to fetch.
     */
    orderBy?: Enumerable<DoctorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DoctorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Doctors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Doctors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Doctors
    **/
    _count?: true | DoctorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DoctorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DoctorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DoctorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DoctorMaxAggregateInputType
  }

  export type GetDoctorAggregateType<T extends DoctorAggregateArgs> = {
        [P in keyof T & keyof AggregateDoctor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDoctor[P]>
      : GetScalarType<T[P], AggregateDoctor[P]>
  }




  export type DoctorGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DoctorWhereInput
    orderBy?: Enumerable<DoctorOrderByWithAggregationInput>
    by: DoctorScalarFieldEnum[]
    having?: DoctorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DoctorCountAggregateInputType | true
    _avg?: DoctorAvgAggregateInputType
    _sum?: DoctorSumAggregateInputType
    _min?: DoctorMinAggregateInputType
    _max?: DoctorMaxAggregateInputType
  }


  export type DoctorGroupByOutputType = {
    id: string
    numericId: number
    userId: string
    specialtyId: string
    crfa: string | null
    availability: JsonValue
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: DoctorCountAggregateOutputType | null
    _avg: DoctorAvgAggregateOutputType | null
    _sum: DoctorSumAggregateOutputType | null
    _min: DoctorMinAggregateOutputType | null
    _max: DoctorMaxAggregateOutputType | null
  }

  type GetDoctorGroupByPayload<T extends DoctorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<DoctorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DoctorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DoctorGroupByOutputType[P]>
            : GetScalarType<T[P], DoctorGroupByOutputType[P]>
        }
      >
    >


  export type DoctorSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    numericId?: boolean
    userId?: boolean
    specialtyId?: boolean
    crfa?: boolean
    availability?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    specialty?: boolean | SpecialtyArgs<ExtArgs>
    user?: boolean | UserArgs<ExtArgs>
    anamnesis?: boolean | Doctor$anamnesisArgs<ExtArgs>
    evaluations?: boolean | Doctor$evaluationsArgs<ExtArgs>
    doctorPatient?: boolean | Doctor$doctorPatientArgs<ExtArgs>
    templates?: boolean | Doctor$templatesArgs<ExtArgs>
    evolutions?: boolean | Doctor$evolutionsArgs<ExtArgs>
    appointments?: boolean | Doctor$appointmentsArgs<ExtArgs>
    _count?: boolean | DoctorCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["doctor"]>

  export type DoctorSelectScalar = {
    id?: boolean
    numericId?: boolean
    userId?: boolean
    specialtyId?: boolean
    crfa?: boolean
    availability?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type DoctorInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    specialty?: boolean | SpecialtyArgs<ExtArgs>
    user?: boolean | UserArgs<ExtArgs>
    anamnesis?: boolean | Doctor$anamnesisArgs<ExtArgs>
    evaluations?: boolean | Doctor$evaluationsArgs<ExtArgs>
    doctorPatient?: boolean | Doctor$doctorPatientArgs<ExtArgs>
    templates?: boolean | Doctor$templatesArgs<ExtArgs>
    evolutions?: boolean | Doctor$evolutionsArgs<ExtArgs>
    appointments?: boolean | Doctor$appointmentsArgs<ExtArgs>
    _count?: boolean | DoctorCountOutputTypeArgs<ExtArgs>
  }


  type DoctorGetPayload<S extends boolean | null | undefined | DoctorArgs> = $Types.GetResult<DoctorPayload, S>

  type DoctorCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<DoctorFindManyArgs, 'select' | 'include'> & {
      select?: DoctorCountAggregateInputType | true
    }

  export interface DoctorDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Doctor'], meta: { name: 'Doctor' } }
    /**
     * Find zero or one Doctor that matches the filter.
     * @param {DoctorFindUniqueArgs} args - Arguments to find a Doctor
     * @example
     * // Get one Doctor
     * const doctor = await prisma.doctor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DoctorFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DoctorFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Doctor'> extends True ? Prisma__DoctorClient<$Types.GetResult<DoctorPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__DoctorClient<$Types.GetResult<DoctorPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Doctor that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DoctorFindUniqueOrThrowArgs} args - Arguments to find a Doctor
     * @example
     * // Get one Doctor
     * const doctor = await prisma.doctor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DoctorFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DoctorFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DoctorClient<$Types.GetResult<DoctorPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Doctor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorFindFirstArgs} args - Arguments to find a Doctor
     * @example
     * // Get one Doctor
     * const doctor = await prisma.doctor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DoctorFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DoctorFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Doctor'> extends True ? Prisma__DoctorClient<$Types.GetResult<DoctorPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__DoctorClient<$Types.GetResult<DoctorPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Doctor that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorFindFirstOrThrowArgs} args - Arguments to find a Doctor
     * @example
     * // Get one Doctor
     * const doctor = await prisma.doctor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DoctorFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DoctorFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DoctorClient<$Types.GetResult<DoctorPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Doctors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Doctors
     * const doctors = await prisma.doctor.findMany()
     * 
     * // Get first 10 Doctors
     * const doctors = await prisma.doctor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const doctorWithIdOnly = await prisma.doctor.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DoctorFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DoctorFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<DoctorPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Doctor.
     * @param {DoctorCreateArgs} args - Arguments to create a Doctor.
     * @example
     * // Create one Doctor
     * const Doctor = await prisma.doctor.create({
     *   data: {
     *     // ... data to create a Doctor
     *   }
     * })
     * 
    **/
    create<T extends DoctorCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DoctorCreateArgs<ExtArgs>>
    ): Prisma__DoctorClient<$Types.GetResult<DoctorPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Doctors.
     *     @param {DoctorCreateManyArgs} args - Arguments to create many Doctors.
     *     @example
     *     // Create many Doctors
     *     const doctor = await prisma.doctor.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DoctorCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DoctorCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Doctor.
     * @param {DoctorDeleteArgs} args - Arguments to delete one Doctor.
     * @example
     * // Delete one Doctor
     * const Doctor = await prisma.doctor.delete({
     *   where: {
     *     // ... filter to delete one Doctor
     *   }
     * })
     * 
    **/
    delete<T extends DoctorDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DoctorDeleteArgs<ExtArgs>>
    ): Prisma__DoctorClient<$Types.GetResult<DoctorPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Doctor.
     * @param {DoctorUpdateArgs} args - Arguments to update one Doctor.
     * @example
     * // Update one Doctor
     * const doctor = await prisma.doctor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DoctorUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DoctorUpdateArgs<ExtArgs>>
    ): Prisma__DoctorClient<$Types.GetResult<DoctorPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Doctors.
     * @param {DoctorDeleteManyArgs} args - Arguments to filter Doctors to delete.
     * @example
     * // Delete a few Doctors
     * const { count } = await prisma.doctor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DoctorDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DoctorDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Doctors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Doctors
     * const doctor = await prisma.doctor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DoctorUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DoctorUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Doctor.
     * @param {DoctorUpsertArgs} args - Arguments to update or create a Doctor.
     * @example
     * // Update or create a Doctor
     * const doctor = await prisma.doctor.upsert({
     *   create: {
     *     // ... data to create a Doctor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Doctor we want to update
     *   }
     * })
    **/
    upsert<T extends DoctorUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DoctorUpsertArgs<ExtArgs>>
    ): Prisma__DoctorClient<$Types.GetResult<DoctorPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Doctors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorCountArgs} args - Arguments to filter Doctors to count.
     * @example
     * // Count the number of Doctors
     * const count = await prisma.doctor.count({
     *   where: {
     *     // ... the filter for the Doctors we want to count
     *   }
     * })
    **/
    count<T extends DoctorCountArgs>(
      args?: Subset<T, DoctorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DoctorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Doctor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DoctorAggregateArgs>(args: Subset<T, DoctorAggregateArgs>): Prisma.PrismaPromise<GetDoctorAggregateType<T>>

    /**
     * Group by Doctor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DoctorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DoctorGroupByArgs['orderBy'] }
        : { orderBy?: DoctorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DoctorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDoctorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Doctor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DoctorClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    specialty<T extends SpecialtyArgs<ExtArgs> = {}>(args?: Subset<T, SpecialtyArgs<ExtArgs>>): Prisma__SpecialtyClient<$Types.GetResult<SpecialtyPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    anamnesis<T extends Doctor$anamnesisArgs<ExtArgs> = {}>(args?: Subset<T, Doctor$anamnesisArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<AnamnesisPayload<ExtArgs>, T, 'findMany', never>| Null>;

    evaluations<T extends Doctor$evaluationsArgs<ExtArgs> = {}>(args?: Subset<T, Doctor$evaluationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<EvaluationPayload<ExtArgs>, T, 'findMany', never>| Null>;

    doctorPatient<T extends Doctor$doctorPatientArgs<ExtArgs> = {}>(args?: Subset<T, Doctor$doctorPatientArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<DoctorPatientPayload<ExtArgs>, T, 'findMany', never>| Null>;

    templates<T extends Doctor$templatesArgs<ExtArgs> = {}>(args?: Subset<T, Doctor$templatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<TemplatePayload<ExtArgs>, T, 'findMany', never>| Null>;

    evolutions<T extends Doctor$evolutionsArgs<ExtArgs> = {}>(args?: Subset<T, Doctor$evolutionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<EvolutionPayload<ExtArgs>, T, 'findMany', never>| Null>;

    appointments<T extends Doctor$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, Doctor$appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<AppointmentPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Doctor base type for findUnique actions
   */
  export type DoctorFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DoctorInclude<ExtArgs> | null
    /**
     * Filter, which Doctor to fetch.
     */
    where: DoctorWhereUniqueInput
  }

  /**
   * Doctor findUnique
   */
  export interface DoctorFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends DoctorFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Doctor findUniqueOrThrow
   */
  export type DoctorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DoctorInclude<ExtArgs> | null
    /**
     * Filter, which Doctor to fetch.
     */
    where: DoctorWhereUniqueInput
  }


  /**
   * Doctor base type for findFirst actions
   */
  export type DoctorFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DoctorInclude<ExtArgs> | null
    /**
     * Filter, which Doctor to fetch.
     */
    where?: DoctorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Doctors to fetch.
     */
    orderBy?: Enumerable<DoctorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Doctors.
     */
    cursor?: DoctorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Doctors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Doctors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Doctors.
     */
    distinct?: Enumerable<DoctorScalarFieldEnum>
  }

  /**
   * Doctor findFirst
   */
  export interface DoctorFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends DoctorFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Doctor findFirstOrThrow
   */
  export type DoctorFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DoctorInclude<ExtArgs> | null
    /**
     * Filter, which Doctor to fetch.
     */
    where?: DoctorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Doctors to fetch.
     */
    orderBy?: Enumerable<DoctorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Doctors.
     */
    cursor?: DoctorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Doctors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Doctors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Doctors.
     */
    distinct?: Enumerable<DoctorScalarFieldEnum>
  }


  /**
   * Doctor findMany
   */
  export type DoctorFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DoctorInclude<ExtArgs> | null
    /**
     * Filter, which Doctors to fetch.
     */
    where?: DoctorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Doctors to fetch.
     */
    orderBy?: Enumerable<DoctorOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Doctors.
     */
    cursor?: DoctorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Doctors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Doctors.
     */
    skip?: number
    distinct?: Enumerable<DoctorScalarFieldEnum>
  }


  /**
   * Doctor create
   */
  export type DoctorCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DoctorInclude<ExtArgs> | null
    /**
     * The data needed to create a Doctor.
     */
    data: XOR<DoctorCreateInput, DoctorUncheckedCreateInput>
  }


  /**
   * Doctor createMany
   */
  export type DoctorCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Doctors.
     */
    data: Enumerable<DoctorCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Doctor update
   */
  export type DoctorUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DoctorInclude<ExtArgs> | null
    /**
     * The data needed to update a Doctor.
     */
    data: XOR<DoctorUpdateInput, DoctorUncheckedUpdateInput>
    /**
     * Choose, which Doctor to update.
     */
    where: DoctorWhereUniqueInput
  }


  /**
   * Doctor updateMany
   */
  export type DoctorUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Doctors.
     */
    data: XOR<DoctorUpdateManyMutationInput, DoctorUncheckedUpdateManyInput>
    /**
     * Filter which Doctors to update
     */
    where?: DoctorWhereInput
  }


  /**
   * Doctor upsert
   */
  export type DoctorUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DoctorInclude<ExtArgs> | null
    /**
     * The filter to search for the Doctor to update in case it exists.
     */
    where: DoctorWhereUniqueInput
    /**
     * In case the Doctor found by the `where` argument doesn't exist, create a new Doctor with this data.
     */
    create: XOR<DoctorCreateInput, DoctorUncheckedCreateInput>
    /**
     * In case the Doctor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DoctorUpdateInput, DoctorUncheckedUpdateInput>
  }


  /**
   * Doctor delete
   */
  export type DoctorDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DoctorInclude<ExtArgs> | null
    /**
     * Filter which Doctor to delete.
     */
    where: DoctorWhereUniqueInput
  }


  /**
   * Doctor deleteMany
   */
  export type DoctorDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Doctors to delete
     */
    where?: DoctorWhereInput
  }


  /**
   * Doctor.anamnesis
   */
  export type Doctor$anamnesisArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anamnesis
     */
    select?: AnamnesisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnamnesisInclude<ExtArgs> | null
    where?: AnamnesisWhereInput
    orderBy?: Enumerable<AnamnesisOrderByWithRelationInput>
    cursor?: AnamnesisWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<AnamnesisScalarFieldEnum>
  }


  /**
   * Doctor.evaluations
   */
  export type Doctor$evaluationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EvaluationInclude<ExtArgs> | null
    where?: EvaluationWhereInput
    orderBy?: Enumerable<EvaluationOrderByWithRelationInput>
    cursor?: EvaluationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<EvaluationScalarFieldEnum>
  }


  /**
   * Doctor.doctorPatient
   */
  export type Doctor$doctorPatientArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorPatient
     */
    select?: DoctorPatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DoctorPatientInclude<ExtArgs> | null
    where?: DoctorPatientWhereInput
    orderBy?: Enumerable<DoctorPatientOrderByWithRelationInput>
    cursor?: DoctorPatientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<DoctorPatientScalarFieldEnum>
  }


  /**
   * Doctor.templates
   */
  export type Doctor$templatesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateInclude<ExtArgs> | null
    where?: TemplateWhereInput
    orderBy?: Enumerable<TemplateOrderByWithRelationInput>
    cursor?: TemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TemplateScalarFieldEnum>
  }


  /**
   * Doctor.evolutions
   */
  export type Doctor$evolutionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evolution
     */
    select?: EvolutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EvolutionInclude<ExtArgs> | null
    where?: EvolutionWhereInput
    orderBy?: Enumerable<EvolutionOrderByWithRelationInput>
    cursor?: EvolutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<EvolutionScalarFieldEnum>
  }


  /**
   * Doctor.appointments
   */
  export type Doctor$appointmentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: Enumerable<AppointmentOrderByWithRelationInput>
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<AppointmentScalarFieldEnum>
  }


  /**
   * Doctor without action
   */
  export type DoctorArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DoctorInclude<ExtArgs> | null
  }



  /**
   * Model DoctorPatient
   */


  export type AggregateDoctorPatient = {
    _count: DoctorPatientCountAggregateOutputType | null
    _min: DoctorPatientMinAggregateOutputType | null
    _max: DoctorPatientMaxAggregateOutputType | null
  }

  export type DoctorPatientMinAggregateOutputType = {
    doctorId: string | null
    patientId: string | null
    assignedById: string | null
    createdAt: Date | null
    active: boolean | null
  }

  export type DoctorPatientMaxAggregateOutputType = {
    doctorId: string | null
    patientId: string | null
    assignedById: string | null
    createdAt: Date | null
    active: boolean | null
  }

  export type DoctorPatientCountAggregateOutputType = {
    doctorId: number
    patientId: number
    assignedById: number
    createdAt: number
    active: number
    _all: number
  }


  export type DoctorPatientMinAggregateInputType = {
    doctorId?: true
    patientId?: true
    assignedById?: true
    createdAt?: true
    active?: true
  }

  export type DoctorPatientMaxAggregateInputType = {
    doctorId?: true
    patientId?: true
    assignedById?: true
    createdAt?: true
    active?: true
  }

  export type DoctorPatientCountAggregateInputType = {
    doctorId?: true
    patientId?: true
    assignedById?: true
    createdAt?: true
    active?: true
    _all?: true
  }

  export type DoctorPatientAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which DoctorPatient to aggregate.
     */
    where?: DoctorPatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DoctorPatients to fetch.
     */
    orderBy?: Enumerable<DoctorPatientOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DoctorPatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DoctorPatients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DoctorPatients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DoctorPatients
    **/
    _count?: true | DoctorPatientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DoctorPatientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DoctorPatientMaxAggregateInputType
  }

  export type GetDoctorPatientAggregateType<T extends DoctorPatientAggregateArgs> = {
        [P in keyof T & keyof AggregateDoctorPatient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDoctorPatient[P]>
      : GetScalarType<T[P], AggregateDoctorPatient[P]>
  }




  export type DoctorPatientGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DoctorPatientWhereInput
    orderBy?: Enumerable<DoctorPatientOrderByWithAggregationInput>
    by: DoctorPatientScalarFieldEnum[]
    having?: DoctorPatientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DoctorPatientCountAggregateInputType | true
    _min?: DoctorPatientMinAggregateInputType
    _max?: DoctorPatientMaxAggregateInputType
  }


  export type DoctorPatientGroupByOutputType = {
    doctorId: string
    patientId: string
    assignedById: string
    createdAt: Date
    active: boolean
    _count: DoctorPatientCountAggregateOutputType | null
    _min: DoctorPatientMinAggregateOutputType | null
    _max: DoctorPatientMaxAggregateOutputType | null
  }

  type GetDoctorPatientGroupByPayload<T extends DoctorPatientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<DoctorPatientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DoctorPatientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DoctorPatientGroupByOutputType[P]>
            : GetScalarType<T[P], DoctorPatientGroupByOutputType[P]>
        }
      >
    >


  export type DoctorPatientSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    doctorId?: boolean
    patientId?: boolean
    assignedById?: boolean
    createdAt?: boolean
    active?: boolean
    doctor?: boolean | DoctorArgs<ExtArgs>
    patient?: boolean | PatientArgs<ExtArgs>
    assignedBy?: boolean | UserArgs<ExtArgs>
  }, ExtArgs["result"]["doctorPatient"]>

  export type DoctorPatientSelectScalar = {
    doctorId?: boolean
    patientId?: boolean
    assignedById?: boolean
    createdAt?: boolean
    active?: boolean
  }

  export type DoctorPatientInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    doctor?: boolean | DoctorArgs<ExtArgs>
    patient?: boolean | PatientArgs<ExtArgs>
    assignedBy?: boolean | UserArgs<ExtArgs>
  }


  type DoctorPatientGetPayload<S extends boolean | null | undefined | DoctorPatientArgs> = $Types.GetResult<DoctorPatientPayload, S>

  type DoctorPatientCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<DoctorPatientFindManyArgs, 'select' | 'include'> & {
      select?: DoctorPatientCountAggregateInputType | true
    }

  export interface DoctorPatientDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DoctorPatient'], meta: { name: 'DoctorPatient' } }
    /**
     * Find zero or one DoctorPatient that matches the filter.
     * @param {DoctorPatientFindUniqueArgs} args - Arguments to find a DoctorPatient
     * @example
     * // Get one DoctorPatient
     * const doctorPatient = await prisma.doctorPatient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DoctorPatientFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DoctorPatientFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'DoctorPatient'> extends True ? Prisma__DoctorPatientClient<$Types.GetResult<DoctorPatientPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__DoctorPatientClient<$Types.GetResult<DoctorPatientPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one DoctorPatient that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DoctorPatientFindUniqueOrThrowArgs} args - Arguments to find a DoctorPatient
     * @example
     * // Get one DoctorPatient
     * const doctorPatient = await prisma.doctorPatient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DoctorPatientFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DoctorPatientFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DoctorPatientClient<$Types.GetResult<DoctorPatientPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first DoctorPatient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorPatientFindFirstArgs} args - Arguments to find a DoctorPatient
     * @example
     * // Get one DoctorPatient
     * const doctorPatient = await prisma.doctorPatient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DoctorPatientFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DoctorPatientFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'DoctorPatient'> extends True ? Prisma__DoctorPatientClient<$Types.GetResult<DoctorPatientPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__DoctorPatientClient<$Types.GetResult<DoctorPatientPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first DoctorPatient that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorPatientFindFirstOrThrowArgs} args - Arguments to find a DoctorPatient
     * @example
     * // Get one DoctorPatient
     * const doctorPatient = await prisma.doctorPatient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DoctorPatientFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DoctorPatientFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DoctorPatientClient<$Types.GetResult<DoctorPatientPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more DoctorPatients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorPatientFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DoctorPatients
     * const doctorPatients = await prisma.doctorPatient.findMany()
     * 
     * // Get first 10 DoctorPatients
     * const doctorPatients = await prisma.doctorPatient.findMany({ take: 10 })
     * 
     * // Only select the `doctorId`
     * const doctorPatientWithDoctorIdOnly = await prisma.doctorPatient.findMany({ select: { doctorId: true } })
     * 
    **/
    findMany<T extends DoctorPatientFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DoctorPatientFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<DoctorPatientPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a DoctorPatient.
     * @param {DoctorPatientCreateArgs} args - Arguments to create a DoctorPatient.
     * @example
     * // Create one DoctorPatient
     * const DoctorPatient = await prisma.doctorPatient.create({
     *   data: {
     *     // ... data to create a DoctorPatient
     *   }
     * })
     * 
    **/
    create<T extends DoctorPatientCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DoctorPatientCreateArgs<ExtArgs>>
    ): Prisma__DoctorPatientClient<$Types.GetResult<DoctorPatientPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many DoctorPatients.
     *     @param {DoctorPatientCreateManyArgs} args - Arguments to create many DoctorPatients.
     *     @example
     *     // Create many DoctorPatients
     *     const doctorPatient = await prisma.doctorPatient.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DoctorPatientCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DoctorPatientCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DoctorPatient.
     * @param {DoctorPatientDeleteArgs} args - Arguments to delete one DoctorPatient.
     * @example
     * // Delete one DoctorPatient
     * const DoctorPatient = await prisma.doctorPatient.delete({
     *   where: {
     *     // ... filter to delete one DoctorPatient
     *   }
     * })
     * 
    **/
    delete<T extends DoctorPatientDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DoctorPatientDeleteArgs<ExtArgs>>
    ): Prisma__DoctorPatientClient<$Types.GetResult<DoctorPatientPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one DoctorPatient.
     * @param {DoctorPatientUpdateArgs} args - Arguments to update one DoctorPatient.
     * @example
     * // Update one DoctorPatient
     * const doctorPatient = await prisma.doctorPatient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DoctorPatientUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DoctorPatientUpdateArgs<ExtArgs>>
    ): Prisma__DoctorPatientClient<$Types.GetResult<DoctorPatientPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more DoctorPatients.
     * @param {DoctorPatientDeleteManyArgs} args - Arguments to filter DoctorPatients to delete.
     * @example
     * // Delete a few DoctorPatients
     * const { count } = await prisma.doctorPatient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DoctorPatientDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DoctorPatientDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DoctorPatients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorPatientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DoctorPatients
     * const doctorPatient = await prisma.doctorPatient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DoctorPatientUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DoctorPatientUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DoctorPatient.
     * @param {DoctorPatientUpsertArgs} args - Arguments to update or create a DoctorPatient.
     * @example
     * // Update or create a DoctorPatient
     * const doctorPatient = await prisma.doctorPatient.upsert({
     *   create: {
     *     // ... data to create a DoctorPatient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DoctorPatient we want to update
     *   }
     * })
    **/
    upsert<T extends DoctorPatientUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DoctorPatientUpsertArgs<ExtArgs>>
    ): Prisma__DoctorPatientClient<$Types.GetResult<DoctorPatientPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of DoctorPatients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorPatientCountArgs} args - Arguments to filter DoctorPatients to count.
     * @example
     * // Count the number of DoctorPatients
     * const count = await prisma.doctorPatient.count({
     *   where: {
     *     // ... the filter for the DoctorPatients we want to count
     *   }
     * })
    **/
    count<T extends DoctorPatientCountArgs>(
      args?: Subset<T, DoctorPatientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DoctorPatientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DoctorPatient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorPatientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DoctorPatientAggregateArgs>(args: Subset<T, DoctorPatientAggregateArgs>): Prisma.PrismaPromise<GetDoctorPatientAggregateType<T>>

    /**
     * Group by DoctorPatient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorPatientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DoctorPatientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DoctorPatientGroupByArgs['orderBy'] }
        : { orderBy?: DoctorPatientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DoctorPatientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDoctorPatientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for DoctorPatient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DoctorPatientClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    doctor<T extends DoctorArgs<ExtArgs> = {}>(args?: Subset<T, DoctorArgs<ExtArgs>>): Prisma__DoctorClient<$Types.GetResult<DoctorPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    patient<T extends PatientArgs<ExtArgs> = {}>(args?: Subset<T, PatientArgs<ExtArgs>>): Prisma__PatientClient<$Types.GetResult<PatientPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    assignedBy<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * DoctorPatient base type for findUnique actions
   */
  export type DoctorPatientFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorPatient
     */
    select?: DoctorPatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DoctorPatientInclude<ExtArgs> | null
    /**
     * Filter, which DoctorPatient to fetch.
     */
    where: DoctorPatientWhereUniqueInput
  }

  /**
   * DoctorPatient findUnique
   */
  export interface DoctorPatientFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends DoctorPatientFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * DoctorPatient findUniqueOrThrow
   */
  export type DoctorPatientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorPatient
     */
    select?: DoctorPatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DoctorPatientInclude<ExtArgs> | null
    /**
     * Filter, which DoctorPatient to fetch.
     */
    where: DoctorPatientWhereUniqueInput
  }


  /**
   * DoctorPatient base type for findFirst actions
   */
  export type DoctorPatientFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorPatient
     */
    select?: DoctorPatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DoctorPatientInclude<ExtArgs> | null
    /**
     * Filter, which DoctorPatient to fetch.
     */
    where?: DoctorPatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DoctorPatients to fetch.
     */
    orderBy?: Enumerable<DoctorPatientOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DoctorPatients.
     */
    cursor?: DoctorPatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DoctorPatients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DoctorPatients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DoctorPatients.
     */
    distinct?: Enumerable<DoctorPatientScalarFieldEnum>
  }

  /**
   * DoctorPatient findFirst
   */
  export interface DoctorPatientFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends DoctorPatientFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * DoctorPatient findFirstOrThrow
   */
  export type DoctorPatientFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorPatient
     */
    select?: DoctorPatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DoctorPatientInclude<ExtArgs> | null
    /**
     * Filter, which DoctorPatient to fetch.
     */
    where?: DoctorPatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DoctorPatients to fetch.
     */
    orderBy?: Enumerable<DoctorPatientOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DoctorPatients.
     */
    cursor?: DoctorPatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DoctorPatients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DoctorPatients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DoctorPatients.
     */
    distinct?: Enumerable<DoctorPatientScalarFieldEnum>
  }


  /**
   * DoctorPatient findMany
   */
  export type DoctorPatientFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorPatient
     */
    select?: DoctorPatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DoctorPatientInclude<ExtArgs> | null
    /**
     * Filter, which DoctorPatients to fetch.
     */
    where?: DoctorPatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DoctorPatients to fetch.
     */
    orderBy?: Enumerable<DoctorPatientOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DoctorPatients.
     */
    cursor?: DoctorPatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DoctorPatients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DoctorPatients.
     */
    skip?: number
    distinct?: Enumerable<DoctorPatientScalarFieldEnum>
  }


  /**
   * DoctorPatient create
   */
  export type DoctorPatientCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorPatient
     */
    select?: DoctorPatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DoctorPatientInclude<ExtArgs> | null
    /**
     * The data needed to create a DoctorPatient.
     */
    data: XOR<DoctorPatientCreateInput, DoctorPatientUncheckedCreateInput>
  }


  /**
   * DoctorPatient createMany
   */
  export type DoctorPatientCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DoctorPatients.
     */
    data: Enumerable<DoctorPatientCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * DoctorPatient update
   */
  export type DoctorPatientUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorPatient
     */
    select?: DoctorPatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DoctorPatientInclude<ExtArgs> | null
    /**
     * The data needed to update a DoctorPatient.
     */
    data: XOR<DoctorPatientUpdateInput, DoctorPatientUncheckedUpdateInput>
    /**
     * Choose, which DoctorPatient to update.
     */
    where: DoctorPatientWhereUniqueInput
  }


  /**
   * DoctorPatient updateMany
   */
  export type DoctorPatientUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DoctorPatients.
     */
    data: XOR<DoctorPatientUpdateManyMutationInput, DoctorPatientUncheckedUpdateManyInput>
    /**
     * Filter which DoctorPatients to update
     */
    where?: DoctorPatientWhereInput
  }


  /**
   * DoctorPatient upsert
   */
  export type DoctorPatientUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorPatient
     */
    select?: DoctorPatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DoctorPatientInclude<ExtArgs> | null
    /**
     * The filter to search for the DoctorPatient to update in case it exists.
     */
    where: DoctorPatientWhereUniqueInput
    /**
     * In case the DoctorPatient found by the `where` argument doesn't exist, create a new DoctorPatient with this data.
     */
    create: XOR<DoctorPatientCreateInput, DoctorPatientUncheckedCreateInput>
    /**
     * In case the DoctorPatient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DoctorPatientUpdateInput, DoctorPatientUncheckedUpdateInput>
  }


  /**
   * DoctorPatient delete
   */
  export type DoctorPatientDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorPatient
     */
    select?: DoctorPatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DoctorPatientInclude<ExtArgs> | null
    /**
     * Filter which DoctorPatient to delete.
     */
    where: DoctorPatientWhereUniqueInput
  }


  /**
   * DoctorPatient deleteMany
   */
  export type DoctorPatientDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which DoctorPatients to delete
     */
    where?: DoctorPatientWhereInput
  }


  /**
   * DoctorPatient without action
   */
  export type DoctorPatientArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorPatient
     */
    select?: DoctorPatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DoctorPatientInclude<ExtArgs> | null
  }



  /**
   * Model Specialty
   */


  export type AggregateSpecialty = {
    _count: SpecialtyCountAggregateOutputType | null
    _avg: SpecialtyAvgAggregateOutputType | null
    _sum: SpecialtySumAggregateOutputType | null
    _min: SpecialtyMinAggregateOutputType | null
    _max: SpecialtyMaxAggregateOutputType | null
  }

  export type SpecialtyAvgAggregateOutputType = {
    numericId: number | null
  }

  export type SpecialtySumAggregateOutputType = {
    numericId: number | null
  }

  export type SpecialtyMinAggregateOutputType = {
    id: string | null
    numericId: number | null
    name: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SpecialtyMaxAggregateOutputType = {
    id: string | null
    numericId: number | null
    name: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SpecialtyCountAggregateOutputType = {
    id: number
    numericId: number
    name: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SpecialtyAvgAggregateInputType = {
    numericId?: true
  }

  export type SpecialtySumAggregateInputType = {
    numericId?: true
  }

  export type SpecialtyMinAggregateInputType = {
    id?: true
    numericId?: true
    name?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SpecialtyMaxAggregateInputType = {
    id?: true
    numericId?: true
    name?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SpecialtyCountAggregateInputType = {
    id?: true
    numericId?: true
    name?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SpecialtyAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Specialty to aggregate.
     */
    where?: SpecialtyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Specialties to fetch.
     */
    orderBy?: Enumerable<SpecialtyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SpecialtyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Specialties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Specialties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Specialties
    **/
    _count?: true | SpecialtyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SpecialtyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SpecialtySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpecialtyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpecialtyMaxAggregateInputType
  }

  export type GetSpecialtyAggregateType<T extends SpecialtyAggregateArgs> = {
        [P in keyof T & keyof AggregateSpecialty]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpecialty[P]>
      : GetScalarType<T[P], AggregateSpecialty[P]>
  }




  export type SpecialtyGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: SpecialtyWhereInput
    orderBy?: Enumerable<SpecialtyOrderByWithAggregationInput>
    by: SpecialtyScalarFieldEnum[]
    having?: SpecialtyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpecialtyCountAggregateInputType | true
    _avg?: SpecialtyAvgAggregateInputType
    _sum?: SpecialtySumAggregateInputType
    _min?: SpecialtyMinAggregateInputType
    _max?: SpecialtyMaxAggregateInputType
  }


  export type SpecialtyGroupByOutputType = {
    id: string
    numericId: number
    name: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: SpecialtyCountAggregateOutputType | null
    _avg: SpecialtyAvgAggregateOutputType | null
    _sum: SpecialtySumAggregateOutputType | null
    _min: SpecialtyMinAggregateOutputType | null
    _max: SpecialtyMaxAggregateOutputType | null
  }

  type GetSpecialtyGroupByPayload<T extends SpecialtyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<SpecialtyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpecialtyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpecialtyGroupByOutputType[P]>
            : GetScalarType<T[P], SpecialtyGroupByOutputType[P]>
        }
      >
    >


  export type SpecialtySelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    numericId?: boolean
    name?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    doctors?: boolean | Specialty$doctorsArgs<ExtArgs>
    templates?: boolean | Specialty$templatesArgs<ExtArgs>
    evaluations?: boolean | Specialty$evaluationsArgs<ExtArgs>
    anamnesis?: boolean | Specialty$anamnesisArgs<ExtArgs>
    evolution?: boolean | Specialty$evolutionArgs<ExtArgs>
    exercise?: boolean | Specialty$exerciseArgs<ExtArgs>
    course?: boolean | Specialty$courseArgs<ExtArgs>
    _count?: boolean | SpecialtyCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["specialty"]>

  export type SpecialtySelectScalar = {
    id?: boolean
    numericId?: boolean
    name?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SpecialtyInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    doctors?: boolean | Specialty$doctorsArgs<ExtArgs>
    templates?: boolean | Specialty$templatesArgs<ExtArgs>
    evaluations?: boolean | Specialty$evaluationsArgs<ExtArgs>
    anamnesis?: boolean | Specialty$anamnesisArgs<ExtArgs>
    evolution?: boolean | Specialty$evolutionArgs<ExtArgs>
    exercise?: boolean | Specialty$exerciseArgs<ExtArgs>
    course?: boolean | Specialty$courseArgs<ExtArgs>
    _count?: boolean | SpecialtyCountOutputTypeArgs<ExtArgs>
  }


  type SpecialtyGetPayload<S extends boolean | null | undefined | SpecialtyArgs> = $Types.GetResult<SpecialtyPayload, S>

  type SpecialtyCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<SpecialtyFindManyArgs, 'select' | 'include'> & {
      select?: SpecialtyCountAggregateInputType | true
    }

  export interface SpecialtyDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Specialty'], meta: { name: 'Specialty' } }
    /**
     * Find zero or one Specialty that matches the filter.
     * @param {SpecialtyFindUniqueArgs} args - Arguments to find a Specialty
     * @example
     * // Get one Specialty
     * const specialty = await prisma.specialty.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SpecialtyFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SpecialtyFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Specialty'> extends True ? Prisma__SpecialtyClient<$Types.GetResult<SpecialtyPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__SpecialtyClient<$Types.GetResult<SpecialtyPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Specialty that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SpecialtyFindUniqueOrThrowArgs} args - Arguments to find a Specialty
     * @example
     * // Get one Specialty
     * const specialty = await prisma.specialty.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SpecialtyFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SpecialtyFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SpecialtyClient<$Types.GetResult<SpecialtyPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Specialty that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialtyFindFirstArgs} args - Arguments to find a Specialty
     * @example
     * // Get one Specialty
     * const specialty = await prisma.specialty.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SpecialtyFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SpecialtyFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Specialty'> extends True ? Prisma__SpecialtyClient<$Types.GetResult<SpecialtyPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__SpecialtyClient<$Types.GetResult<SpecialtyPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Specialty that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialtyFindFirstOrThrowArgs} args - Arguments to find a Specialty
     * @example
     * // Get one Specialty
     * const specialty = await prisma.specialty.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SpecialtyFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SpecialtyFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SpecialtyClient<$Types.GetResult<SpecialtyPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Specialties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialtyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Specialties
     * const specialties = await prisma.specialty.findMany()
     * 
     * // Get first 10 Specialties
     * const specialties = await prisma.specialty.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const specialtyWithIdOnly = await prisma.specialty.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SpecialtyFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SpecialtyFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<SpecialtyPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Specialty.
     * @param {SpecialtyCreateArgs} args - Arguments to create a Specialty.
     * @example
     * // Create one Specialty
     * const Specialty = await prisma.specialty.create({
     *   data: {
     *     // ... data to create a Specialty
     *   }
     * })
     * 
    **/
    create<T extends SpecialtyCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SpecialtyCreateArgs<ExtArgs>>
    ): Prisma__SpecialtyClient<$Types.GetResult<SpecialtyPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Specialties.
     *     @param {SpecialtyCreateManyArgs} args - Arguments to create many Specialties.
     *     @example
     *     // Create many Specialties
     *     const specialty = await prisma.specialty.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SpecialtyCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SpecialtyCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Specialty.
     * @param {SpecialtyDeleteArgs} args - Arguments to delete one Specialty.
     * @example
     * // Delete one Specialty
     * const Specialty = await prisma.specialty.delete({
     *   where: {
     *     // ... filter to delete one Specialty
     *   }
     * })
     * 
    **/
    delete<T extends SpecialtyDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SpecialtyDeleteArgs<ExtArgs>>
    ): Prisma__SpecialtyClient<$Types.GetResult<SpecialtyPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Specialty.
     * @param {SpecialtyUpdateArgs} args - Arguments to update one Specialty.
     * @example
     * // Update one Specialty
     * const specialty = await prisma.specialty.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SpecialtyUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SpecialtyUpdateArgs<ExtArgs>>
    ): Prisma__SpecialtyClient<$Types.GetResult<SpecialtyPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Specialties.
     * @param {SpecialtyDeleteManyArgs} args - Arguments to filter Specialties to delete.
     * @example
     * // Delete a few Specialties
     * const { count } = await prisma.specialty.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SpecialtyDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SpecialtyDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Specialties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialtyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Specialties
     * const specialty = await prisma.specialty.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SpecialtyUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SpecialtyUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Specialty.
     * @param {SpecialtyUpsertArgs} args - Arguments to update or create a Specialty.
     * @example
     * // Update or create a Specialty
     * const specialty = await prisma.specialty.upsert({
     *   create: {
     *     // ... data to create a Specialty
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Specialty we want to update
     *   }
     * })
    **/
    upsert<T extends SpecialtyUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SpecialtyUpsertArgs<ExtArgs>>
    ): Prisma__SpecialtyClient<$Types.GetResult<SpecialtyPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Specialties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialtyCountArgs} args - Arguments to filter Specialties to count.
     * @example
     * // Count the number of Specialties
     * const count = await prisma.specialty.count({
     *   where: {
     *     // ... the filter for the Specialties we want to count
     *   }
     * })
    **/
    count<T extends SpecialtyCountArgs>(
      args?: Subset<T, SpecialtyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpecialtyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Specialty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialtyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpecialtyAggregateArgs>(args: Subset<T, SpecialtyAggregateArgs>): Prisma.PrismaPromise<GetSpecialtyAggregateType<T>>

    /**
     * Group by Specialty.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpecialtyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpecialtyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpecialtyGroupByArgs['orderBy'] }
        : { orderBy?: SpecialtyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpecialtyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpecialtyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Specialty.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SpecialtyClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    doctors<T extends Specialty$doctorsArgs<ExtArgs> = {}>(args?: Subset<T, Specialty$doctorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<DoctorPayload<ExtArgs>, T, 'findMany', never>| Null>;

    templates<T extends Specialty$templatesArgs<ExtArgs> = {}>(args?: Subset<T, Specialty$templatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<TemplatePayload<ExtArgs>, T, 'findMany', never>| Null>;

    evaluations<T extends Specialty$evaluationsArgs<ExtArgs> = {}>(args?: Subset<T, Specialty$evaluationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<EvaluationPayload<ExtArgs>, T, 'findMany', never>| Null>;

    anamnesis<T extends Specialty$anamnesisArgs<ExtArgs> = {}>(args?: Subset<T, Specialty$anamnesisArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<AnamnesisPayload<ExtArgs>, T, 'findMany', never>| Null>;

    evolution<T extends Specialty$evolutionArgs<ExtArgs> = {}>(args?: Subset<T, Specialty$evolutionArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<EvolutionPayload<ExtArgs>, T, 'findMany', never>| Null>;

    exercise<T extends Specialty$exerciseArgs<ExtArgs> = {}>(args?: Subset<T, Specialty$exerciseArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ExercisePayload<ExtArgs>, T, 'findMany', never>| Null>;

    course<T extends Specialty$courseArgs<ExtArgs> = {}>(args?: Subset<T, Specialty$courseArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<CoursePayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Specialty base type for findUnique actions
   */
  export type SpecialtyFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialty
     */
    select?: SpecialtySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpecialtyInclude<ExtArgs> | null
    /**
     * Filter, which Specialty to fetch.
     */
    where: SpecialtyWhereUniqueInput
  }

  /**
   * Specialty findUnique
   */
  export interface SpecialtyFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends SpecialtyFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Specialty findUniqueOrThrow
   */
  export type SpecialtyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialty
     */
    select?: SpecialtySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpecialtyInclude<ExtArgs> | null
    /**
     * Filter, which Specialty to fetch.
     */
    where: SpecialtyWhereUniqueInput
  }


  /**
   * Specialty base type for findFirst actions
   */
  export type SpecialtyFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialty
     */
    select?: SpecialtySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpecialtyInclude<ExtArgs> | null
    /**
     * Filter, which Specialty to fetch.
     */
    where?: SpecialtyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Specialties to fetch.
     */
    orderBy?: Enumerable<SpecialtyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Specialties.
     */
    cursor?: SpecialtyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Specialties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Specialties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Specialties.
     */
    distinct?: Enumerable<SpecialtyScalarFieldEnum>
  }

  /**
   * Specialty findFirst
   */
  export interface SpecialtyFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends SpecialtyFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Specialty findFirstOrThrow
   */
  export type SpecialtyFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialty
     */
    select?: SpecialtySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpecialtyInclude<ExtArgs> | null
    /**
     * Filter, which Specialty to fetch.
     */
    where?: SpecialtyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Specialties to fetch.
     */
    orderBy?: Enumerable<SpecialtyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Specialties.
     */
    cursor?: SpecialtyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Specialties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Specialties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Specialties.
     */
    distinct?: Enumerable<SpecialtyScalarFieldEnum>
  }


  /**
   * Specialty findMany
   */
  export type SpecialtyFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialty
     */
    select?: SpecialtySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpecialtyInclude<ExtArgs> | null
    /**
     * Filter, which Specialties to fetch.
     */
    where?: SpecialtyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Specialties to fetch.
     */
    orderBy?: Enumerable<SpecialtyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Specialties.
     */
    cursor?: SpecialtyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Specialties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Specialties.
     */
    skip?: number
    distinct?: Enumerable<SpecialtyScalarFieldEnum>
  }


  /**
   * Specialty create
   */
  export type SpecialtyCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialty
     */
    select?: SpecialtySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpecialtyInclude<ExtArgs> | null
    /**
     * The data needed to create a Specialty.
     */
    data: XOR<SpecialtyCreateInput, SpecialtyUncheckedCreateInput>
  }


  /**
   * Specialty createMany
   */
  export type SpecialtyCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Specialties.
     */
    data: Enumerable<SpecialtyCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Specialty update
   */
  export type SpecialtyUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialty
     */
    select?: SpecialtySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpecialtyInclude<ExtArgs> | null
    /**
     * The data needed to update a Specialty.
     */
    data: XOR<SpecialtyUpdateInput, SpecialtyUncheckedUpdateInput>
    /**
     * Choose, which Specialty to update.
     */
    where: SpecialtyWhereUniqueInput
  }


  /**
   * Specialty updateMany
   */
  export type SpecialtyUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Specialties.
     */
    data: XOR<SpecialtyUpdateManyMutationInput, SpecialtyUncheckedUpdateManyInput>
    /**
     * Filter which Specialties to update
     */
    where?: SpecialtyWhereInput
  }


  /**
   * Specialty upsert
   */
  export type SpecialtyUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialty
     */
    select?: SpecialtySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpecialtyInclude<ExtArgs> | null
    /**
     * The filter to search for the Specialty to update in case it exists.
     */
    where: SpecialtyWhereUniqueInput
    /**
     * In case the Specialty found by the `where` argument doesn't exist, create a new Specialty with this data.
     */
    create: XOR<SpecialtyCreateInput, SpecialtyUncheckedCreateInput>
    /**
     * In case the Specialty was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpecialtyUpdateInput, SpecialtyUncheckedUpdateInput>
  }


  /**
   * Specialty delete
   */
  export type SpecialtyDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialty
     */
    select?: SpecialtySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpecialtyInclude<ExtArgs> | null
    /**
     * Filter which Specialty to delete.
     */
    where: SpecialtyWhereUniqueInput
  }


  /**
   * Specialty deleteMany
   */
  export type SpecialtyDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Specialties to delete
     */
    where?: SpecialtyWhereInput
  }


  /**
   * Specialty.doctors
   */
  export type Specialty$doctorsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DoctorInclude<ExtArgs> | null
    where?: DoctorWhereInput
    orderBy?: Enumerable<DoctorOrderByWithRelationInput>
    cursor?: DoctorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<DoctorScalarFieldEnum>
  }


  /**
   * Specialty.templates
   */
  export type Specialty$templatesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateInclude<ExtArgs> | null
    where?: TemplateWhereInput
    orderBy?: Enumerable<TemplateOrderByWithRelationInput>
    cursor?: TemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TemplateScalarFieldEnum>
  }


  /**
   * Specialty.evaluations
   */
  export type Specialty$evaluationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EvaluationInclude<ExtArgs> | null
    where?: EvaluationWhereInput
    orderBy?: Enumerable<EvaluationOrderByWithRelationInput>
    cursor?: EvaluationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<EvaluationScalarFieldEnum>
  }


  /**
   * Specialty.anamnesis
   */
  export type Specialty$anamnesisArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anamnesis
     */
    select?: AnamnesisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnamnesisInclude<ExtArgs> | null
    where?: AnamnesisWhereInput
    orderBy?: Enumerable<AnamnesisOrderByWithRelationInput>
    cursor?: AnamnesisWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<AnamnesisScalarFieldEnum>
  }


  /**
   * Specialty.evolution
   */
  export type Specialty$evolutionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evolution
     */
    select?: EvolutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EvolutionInclude<ExtArgs> | null
    where?: EvolutionWhereInput
    orderBy?: Enumerable<EvolutionOrderByWithRelationInput>
    cursor?: EvolutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<EvolutionScalarFieldEnum>
  }


  /**
   * Specialty.exercise
   */
  export type Specialty$exerciseArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExerciseInclude<ExtArgs> | null
    where?: ExerciseWhereInput
    orderBy?: Enumerable<ExerciseOrderByWithRelationInput>
    cursor?: ExerciseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ExerciseScalarFieldEnum>
  }


  /**
   * Specialty.course
   */
  export type Specialty$courseArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CourseInclude<ExtArgs> | null
    where?: CourseWhereInput
    orderBy?: Enumerable<CourseOrderByWithRelationInput>
    cursor?: CourseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CourseScalarFieldEnum>
  }


  /**
   * Specialty without action
   */
  export type SpecialtyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Specialty
     */
    select?: SpecialtySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SpecialtyInclude<ExtArgs> | null
  }



  /**
   * Model Anamnesis
   */


  export type AggregateAnamnesis = {
    _count: AnamnesisCountAggregateOutputType | null
    _avg: AnamnesisAvgAggregateOutputType | null
    _sum: AnamnesisSumAggregateOutputType | null
    _min: AnamnesisMinAggregateOutputType | null
    _max: AnamnesisMaxAggregateOutputType | null
  }

  export type AnamnesisAvgAggregateOutputType = {
    numericId: number | null
  }

  export type AnamnesisSumAggregateOutputType = {
    numericId: number | null
  }

  export type AnamnesisMinAggregateOutputType = {
    id: string | null
    numericId: number | null
    patientId: string | null
    doctorId: string | null
    specialtyId: string | null
    title: string | null
    text: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type AnamnesisMaxAggregateOutputType = {
    id: string | null
    numericId: number | null
    patientId: string | null
    doctorId: string | null
    specialtyId: string | null
    title: string | null
    text: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type AnamnesisCountAggregateOutputType = {
    id: number
    numericId: number
    patientId: number
    doctorId: number
    specialtyId: number
    questions: number
    title: number
    text: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type AnamnesisAvgAggregateInputType = {
    numericId?: true
  }

  export type AnamnesisSumAggregateInputType = {
    numericId?: true
  }

  export type AnamnesisMinAggregateInputType = {
    id?: true
    numericId?: true
    patientId?: true
    doctorId?: true
    specialtyId?: true
    title?: true
    text?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type AnamnesisMaxAggregateInputType = {
    id?: true
    numericId?: true
    patientId?: true
    doctorId?: true
    specialtyId?: true
    title?: true
    text?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type AnamnesisCountAggregateInputType = {
    id?: true
    numericId?: true
    patientId?: true
    doctorId?: true
    specialtyId?: true
    questions?: true
    title?: true
    text?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type AnamnesisAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Anamnesis to aggregate.
     */
    where?: AnamnesisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Anamneses to fetch.
     */
    orderBy?: Enumerable<AnamnesisOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnamnesisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Anamneses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Anamneses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Anamneses
    **/
    _count?: true | AnamnesisCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AnamnesisAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AnamnesisSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnamnesisMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnamnesisMaxAggregateInputType
  }

  export type GetAnamnesisAggregateType<T extends AnamnesisAggregateArgs> = {
        [P in keyof T & keyof AggregateAnamnesis]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnamnesis[P]>
      : GetScalarType<T[P], AggregateAnamnesis[P]>
  }




  export type AnamnesisGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AnamnesisWhereInput
    orderBy?: Enumerable<AnamnesisOrderByWithAggregationInput>
    by: AnamnesisScalarFieldEnum[]
    having?: AnamnesisScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnamnesisCountAggregateInputType | true
    _avg?: AnamnesisAvgAggregateInputType
    _sum?: AnamnesisSumAggregateInputType
    _min?: AnamnesisMinAggregateInputType
    _max?: AnamnesisMaxAggregateInputType
  }


  export type AnamnesisGroupByOutputType = {
    id: string
    numericId: number
    patientId: string
    doctorId: string
    specialtyId: string
    questions: JsonValue
    title: string | null
    text: string | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: AnamnesisCountAggregateOutputType | null
    _avg: AnamnesisAvgAggregateOutputType | null
    _sum: AnamnesisSumAggregateOutputType | null
    _min: AnamnesisMinAggregateOutputType | null
    _max: AnamnesisMaxAggregateOutputType | null
  }

  type GetAnamnesisGroupByPayload<T extends AnamnesisGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<AnamnesisGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnamnesisGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnamnesisGroupByOutputType[P]>
            : GetScalarType<T[P], AnamnesisGroupByOutputType[P]>
        }
      >
    >


  export type AnamnesisSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    numericId?: boolean
    patientId?: boolean
    doctorId?: boolean
    specialtyId?: boolean
    questions?: boolean
    title?: boolean
    text?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    patient?: boolean | PatientArgs<ExtArgs>
    doctor?: boolean | DoctorArgs<ExtArgs>
    specialty?: boolean | SpecialtyArgs<ExtArgs>
  }, ExtArgs["result"]["anamnesis"]>

  export type AnamnesisSelectScalar = {
    id?: boolean
    numericId?: boolean
    patientId?: boolean
    doctorId?: boolean
    specialtyId?: boolean
    questions?: boolean
    title?: boolean
    text?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type AnamnesisInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientArgs<ExtArgs>
    doctor?: boolean | DoctorArgs<ExtArgs>
    specialty?: boolean | SpecialtyArgs<ExtArgs>
  }


  type AnamnesisGetPayload<S extends boolean | null | undefined | AnamnesisArgs> = $Types.GetResult<AnamnesisPayload, S>

  type AnamnesisCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<AnamnesisFindManyArgs, 'select' | 'include'> & {
      select?: AnamnesisCountAggregateInputType | true
    }

  export interface AnamnesisDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Anamnesis'], meta: { name: 'Anamnesis' } }
    /**
     * Find zero or one Anamnesis that matches the filter.
     * @param {AnamnesisFindUniqueArgs} args - Arguments to find a Anamnesis
     * @example
     * // Get one Anamnesis
     * const anamnesis = await prisma.anamnesis.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AnamnesisFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AnamnesisFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Anamnesis'> extends True ? Prisma__AnamnesisClient<$Types.GetResult<AnamnesisPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__AnamnesisClient<$Types.GetResult<AnamnesisPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Anamnesis that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AnamnesisFindUniqueOrThrowArgs} args - Arguments to find a Anamnesis
     * @example
     * // Get one Anamnesis
     * const anamnesis = await prisma.anamnesis.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AnamnesisFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AnamnesisFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AnamnesisClient<$Types.GetResult<AnamnesisPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Anamnesis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnamnesisFindFirstArgs} args - Arguments to find a Anamnesis
     * @example
     * // Get one Anamnesis
     * const anamnesis = await prisma.anamnesis.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AnamnesisFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AnamnesisFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Anamnesis'> extends True ? Prisma__AnamnesisClient<$Types.GetResult<AnamnesisPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__AnamnesisClient<$Types.GetResult<AnamnesisPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Anamnesis that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnamnesisFindFirstOrThrowArgs} args - Arguments to find a Anamnesis
     * @example
     * // Get one Anamnesis
     * const anamnesis = await prisma.anamnesis.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AnamnesisFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AnamnesisFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AnamnesisClient<$Types.GetResult<AnamnesisPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Anamneses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnamnesisFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Anamneses
     * const anamneses = await prisma.anamnesis.findMany()
     * 
     * // Get first 10 Anamneses
     * const anamneses = await prisma.anamnesis.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const anamnesisWithIdOnly = await prisma.anamnesis.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AnamnesisFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AnamnesisFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<AnamnesisPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Anamnesis.
     * @param {AnamnesisCreateArgs} args - Arguments to create a Anamnesis.
     * @example
     * // Create one Anamnesis
     * const Anamnesis = await prisma.anamnesis.create({
     *   data: {
     *     // ... data to create a Anamnesis
     *   }
     * })
     * 
    **/
    create<T extends AnamnesisCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AnamnesisCreateArgs<ExtArgs>>
    ): Prisma__AnamnesisClient<$Types.GetResult<AnamnesisPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Anamneses.
     *     @param {AnamnesisCreateManyArgs} args - Arguments to create many Anamneses.
     *     @example
     *     // Create many Anamneses
     *     const anamnesis = await prisma.anamnesis.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AnamnesisCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AnamnesisCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Anamnesis.
     * @param {AnamnesisDeleteArgs} args - Arguments to delete one Anamnesis.
     * @example
     * // Delete one Anamnesis
     * const Anamnesis = await prisma.anamnesis.delete({
     *   where: {
     *     // ... filter to delete one Anamnesis
     *   }
     * })
     * 
    **/
    delete<T extends AnamnesisDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AnamnesisDeleteArgs<ExtArgs>>
    ): Prisma__AnamnesisClient<$Types.GetResult<AnamnesisPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Anamnesis.
     * @param {AnamnesisUpdateArgs} args - Arguments to update one Anamnesis.
     * @example
     * // Update one Anamnesis
     * const anamnesis = await prisma.anamnesis.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AnamnesisUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AnamnesisUpdateArgs<ExtArgs>>
    ): Prisma__AnamnesisClient<$Types.GetResult<AnamnesisPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Anamneses.
     * @param {AnamnesisDeleteManyArgs} args - Arguments to filter Anamneses to delete.
     * @example
     * // Delete a few Anamneses
     * const { count } = await prisma.anamnesis.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AnamnesisDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AnamnesisDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Anamneses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnamnesisUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Anamneses
     * const anamnesis = await prisma.anamnesis.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AnamnesisUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AnamnesisUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Anamnesis.
     * @param {AnamnesisUpsertArgs} args - Arguments to update or create a Anamnesis.
     * @example
     * // Update or create a Anamnesis
     * const anamnesis = await prisma.anamnesis.upsert({
     *   create: {
     *     // ... data to create a Anamnesis
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Anamnesis we want to update
     *   }
     * })
    **/
    upsert<T extends AnamnesisUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AnamnesisUpsertArgs<ExtArgs>>
    ): Prisma__AnamnesisClient<$Types.GetResult<AnamnesisPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Anamneses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnamnesisCountArgs} args - Arguments to filter Anamneses to count.
     * @example
     * // Count the number of Anamneses
     * const count = await prisma.anamnesis.count({
     *   where: {
     *     // ... the filter for the Anamneses we want to count
     *   }
     * })
    **/
    count<T extends AnamnesisCountArgs>(
      args?: Subset<T, AnamnesisCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnamnesisCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Anamnesis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnamnesisAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnamnesisAggregateArgs>(args: Subset<T, AnamnesisAggregateArgs>): Prisma.PrismaPromise<GetAnamnesisAggregateType<T>>

    /**
     * Group by Anamnesis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnamnesisGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnamnesisGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnamnesisGroupByArgs['orderBy'] }
        : { orderBy?: AnamnesisGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnamnesisGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnamnesisGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Anamnesis.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AnamnesisClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    patient<T extends PatientArgs<ExtArgs> = {}>(args?: Subset<T, PatientArgs<ExtArgs>>): Prisma__PatientClient<$Types.GetResult<PatientPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    doctor<T extends DoctorArgs<ExtArgs> = {}>(args?: Subset<T, DoctorArgs<ExtArgs>>): Prisma__DoctorClient<$Types.GetResult<DoctorPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    specialty<T extends SpecialtyArgs<ExtArgs> = {}>(args?: Subset<T, SpecialtyArgs<ExtArgs>>): Prisma__SpecialtyClient<$Types.GetResult<SpecialtyPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Anamnesis base type for findUnique actions
   */
  export type AnamnesisFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anamnesis
     */
    select?: AnamnesisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnamnesisInclude<ExtArgs> | null
    /**
     * Filter, which Anamnesis to fetch.
     */
    where: AnamnesisWhereUniqueInput
  }

  /**
   * Anamnesis findUnique
   */
  export interface AnamnesisFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends AnamnesisFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Anamnesis findUniqueOrThrow
   */
  export type AnamnesisFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anamnesis
     */
    select?: AnamnesisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnamnesisInclude<ExtArgs> | null
    /**
     * Filter, which Anamnesis to fetch.
     */
    where: AnamnesisWhereUniqueInput
  }


  /**
   * Anamnesis base type for findFirst actions
   */
  export type AnamnesisFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anamnesis
     */
    select?: AnamnesisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnamnesisInclude<ExtArgs> | null
    /**
     * Filter, which Anamnesis to fetch.
     */
    where?: AnamnesisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Anamneses to fetch.
     */
    orderBy?: Enumerable<AnamnesisOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Anamneses.
     */
    cursor?: AnamnesisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Anamneses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Anamneses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Anamneses.
     */
    distinct?: Enumerable<AnamnesisScalarFieldEnum>
  }

  /**
   * Anamnesis findFirst
   */
  export interface AnamnesisFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends AnamnesisFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Anamnesis findFirstOrThrow
   */
  export type AnamnesisFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anamnesis
     */
    select?: AnamnesisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnamnesisInclude<ExtArgs> | null
    /**
     * Filter, which Anamnesis to fetch.
     */
    where?: AnamnesisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Anamneses to fetch.
     */
    orderBy?: Enumerable<AnamnesisOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Anamneses.
     */
    cursor?: AnamnesisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Anamneses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Anamneses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Anamneses.
     */
    distinct?: Enumerable<AnamnesisScalarFieldEnum>
  }


  /**
   * Anamnesis findMany
   */
  export type AnamnesisFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anamnesis
     */
    select?: AnamnesisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnamnesisInclude<ExtArgs> | null
    /**
     * Filter, which Anamneses to fetch.
     */
    where?: AnamnesisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Anamneses to fetch.
     */
    orderBy?: Enumerable<AnamnesisOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Anamneses.
     */
    cursor?: AnamnesisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Anamneses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Anamneses.
     */
    skip?: number
    distinct?: Enumerable<AnamnesisScalarFieldEnum>
  }


  /**
   * Anamnesis create
   */
  export type AnamnesisCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anamnesis
     */
    select?: AnamnesisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnamnesisInclude<ExtArgs> | null
    /**
     * The data needed to create a Anamnesis.
     */
    data: XOR<AnamnesisCreateInput, AnamnesisUncheckedCreateInput>
  }


  /**
   * Anamnesis createMany
   */
  export type AnamnesisCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Anamneses.
     */
    data: Enumerable<AnamnesisCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Anamnesis update
   */
  export type AnamnesisUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anamnesis
     */
    select?: AnamnesisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnamnesisInclude<ExtArgs> | null
    /**
     * The data needed to update a Anamnesis.
     */
    data: XOR<AnamnesisUpdateInput, AnamnesisUncheckedUpdateInput>
    /**
     * Choose, which Anamnesis to update.
     */
    where: AnamnesisWhereUniqueInput
  }


  /**
   * Anamnesis updateMany
   */
  export type AnamnesisUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Anamneses.
     */
    data: XOR<AnamnesisUpdateManyMutationInput, AnamnesisUncheckedUpdateManyInput>
    /**
     * Filter which Anamneses to update
     */
    where?: AnamnesisWhereInput
  }


  /**
   * Anamnesis upsert
   */
  export type AnamnesisUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anamnesis
     */
    select?: AnamnesisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnamnesisInclude<ExtArgs> | null
    /**
     * The filter to search for the Anamnesis to update in case it exists.
     */
    where: AnamnesisWhereUniqueInput
    /**
     * In case the Anamnesis found by the `where` argument doesn't exist, create a new Anamnesis with this data.
     */
    create: XOR<AnamnesisCreateInput, AnamnesisUncheckedCreateInput>
    /**
     * In case the Anamnesis was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnamnesisUpdateInput, AnamnesisUncheckedUpdateInput>
  }


  /**
   * Anamnesis delete
   */
  export type AnamnesisDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anamnesis
     */
    select?: AnamnesisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnamnesisInclude<ExtArgs> | null
    /**
     * Filter which Anamnesis to delete.
     */
    where: AnamnesisWhereUniqueInput
  }


  /**
   * Anamnesis deleteMany
   */
  export type AnamnesisDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Anamneses to delete
     */
    where?: AnamnesisWhereInput
  }


  /**
   * Anamnesis without action
   */
  export type AnamnesisArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anamnesis
     */
    select?: AnamnesisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnamnesisInclude<ExtArgs> | null
  }



  /**
   * Model Evolution
   */


  export type AggregateEvolution = {
    _count: EvolutionCountAggregateOutputType | null
    _avg: EvolutionAvgAggregateOutputType | null
    _sum: EvolutionSumAggregateOutputType | null
    _min: EvolutionMinAggregateOutputType | null
    _max: EvolutionMaxAggregateOutputType | null
  }

  export type EvolutionAvgAggregateOutputType = {
    numericId: number | null
  }

  export type EvolutionSumAggregateOutputType = {
    numericId: number | null
  }

  export type EvolutionMinAggregateOutputType = {
    id: string | null
    numericId: number | null
    patientId: string | null
    doctorId: string | null
    specialtyId: string | null
    text: string | null
    title: string | null
    appointmentDate: Date | null
    comments: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type EvolutionMaxAggregateOutputType = {
    id: string | null
    numericId: number | null
    patientId: string | null
    doctorId: string | null
    specialtyId: string | null
    text: string | null
    title: string | null
    appointmentDate: Date | null
    comments: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type EvolutionCountAggregateOutputType = {
    id: number
    numericId: number
    patientId: number
    doctorId: number
    specialtyId: number
    exercises: number
    text: number
    title: number
    appointmentDate: number
    comments: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type EvolutionAvgAggregateInputType = {
    numericId?: true
  }

  export type EvolutionSumAggregateInputType = {
    numericId?: true
  }

  export type EvolutionMinAggregateInputType = {
    id?: true
    numericId?: true
    patientId?: true
    doctorId?: true
    specialtyId?: true
    text?: true
    title?: true
    appointmentDate?: true
    comments?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type EvolutionMaxAggregateInputType = {
    id?: true
    numericId?: true
    patientId?: true
    doctorId?: true
    specialtyId?: true
    text?: true
    title?: true
    appointmentDate?: true
    comments?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type EvolutionCountAggregateInputType = {
    id?: true
    numericId?: true
    patientId?: true
    doctorId?: true
    specialtyId?: true
    exercises?: true
    text?: true
    title?: true
    appointmentDate?: true
    comments?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type EvolutionAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Evolution to aggregate.
     */
    where?: EvolutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evolutions to fetch.
     */
    orderBy?: Enumerable<EvolutionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EvolutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evolutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evolutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Evolutions
    **/
    _count?: true | EvolutionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EvolutionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EvolutionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EvolutionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EvolutionMaxAggregateInputType
  }

  export type GetEvolutionAggregateType<T extends EvolutionAggregateArgs> = {
        [P in keyof T & keyof AggregateEvolution]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvolution[P]>
      : GetScalarType<T[P], AggregateEvolution[P]>
  }




  export type EvolutionGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: EvolutionWhereInput
    orderBy?: Enumerable<EvolutionOrderByWithAggregationInput>
    by: EvolutionScalarFieldEnum[]
    having?: EvolutionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EvolutionCountAggregateInputType | true
    _avg?: EvolutionAvgAggregateInputType
    _sum?: EvolutionSumAggregateInputType
    _min?: EvolutionMinAggregateInputType
    _max?: EvolutionMaxAggregateInputType
  }


  export type EvolutionGroupByOutputType = {
    id: string
    numericId: number
    patientId: string
    doctorId: string
    specialtyId: string
    exercises: JsonValue
    text: string | null
    title: string | null
    appointmentDate: Date
    comments: string | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: EvolutionCountAggregateOutputType | null
    _avg: EvolutionAvgAggregateOutputType | null
    _sum: EvolutionSumAggregateOutputType | null
    _min: EvolutionMinAggregateOutputType | null
    _max: EvolutionMaxAggregateOutputType | null
  }

  type GetEvolutionGroupByPayload<T extends EvolutionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<EvolutionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EvolutionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EvolutionGroupByOutputType[P]>
            : GetScalarType<T[P], EvolutionGroupByOutputType[P]>
        }
      >
    >


  export type EvolutionSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    numericId?: boolean
    patientId?: boolean
    doctorId?: boolean
    specialtyId?: boolean
    exercises?: boolean
    text?: boolean
    title?: boolean
    appointmentDate?: boolean
    comments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    patient?: boolean | PatientArgs<ExtArgs>
    doctor?: boolean | DoctorArgs<ExtArgs>
    specialty?: boolean | SpecialtyArgs<ExtArgs>
  }, ExtArgs["result"]["evolution"]>

  export type EvolutionSelectScalar = {
    id?: boolean
    numericId?: boolean
    patientId?: boolean
    doctorId?: boolean
    specialtyId?: boolean
    exercises?: boolean
    text?: boolean
    title?: boolean
    appointmentDate?: boolean
    comments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type EvolutionInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientArgs<ExtArgs>
    doctor?: boolean | DoctorArgs<ExtArgs>
    specialty?: boolean | SpecialtyArgs<ExtArgs>
  }


  type EvolutionGetPayload<S extends boolean | null | undefined | EvolutionArgs> = $Types.GetResult<EvolutionPayload, S>

  type EvolutionCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<EvolutionFindManyArgs, 'select' | 'include'> & {
      select?: EvolutionCountAggregateInputType | true
    }

  export interface EvolutionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Evolution'], meta: { name: 'Evolution' } }
    /**
     * Find zero or one Evolution that matches the filter.
     * @param {EvolutionFindUniqueArgs} args - Arguments to find a Evolution
     * @example
     * // Get one Evolution
     * const evolution = await prisma.evolution.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EvolutionFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, EvolutionFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Evolution'> extends True ? Prisma__EvolutionClient<$Types.GetResult<EvolutionPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__EvolutionClient<$Types.GetResult<EvolutionPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Evolution that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EvolutionFindUniqueOrThrowArgs} args - Arguments to find a Evolution
     * @example
     * // Get one Evolution
     * const evolution = await prisma.evolution.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EvolutionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EvolutionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EvolutionClient<$Types.GetResult<EvolutionPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Evolution that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvolutionFindFirstArgs} args - Arguments to find a Evolution
     * @example
     * // Get one Evolution
     * const evolution = await prisma.evolution.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EvolutionFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, EvolutionFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Evolution'> extends True ? Prisma__EvolutionClient<$Types.GetResult<EvolutionPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__EvolutionClient<$Types.GetResult<EvolutionPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Evolution that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvolutionFindFirstOrThrowArgs} args - Arguments to find a Evolution
     * @example
     * // Get one Evolution
     * const evolution = await prisma.evolution.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EvolutionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EvolutionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EvolutionClient<$Types.GetResult<EvolutionPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Evolutions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvolutionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Evolutions
     * const evolutions = await prisma.evolution.findMany()
     * 
     * // Get first 10 Evolutions
     * const evolutions = await prisma.evolution.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const evolutionWithIdOnly = await prisma.evolution.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EvolutionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EvolutionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<EvolutionPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Evolution.
     * @param {EvolutionCreateArgs} args - Arguments to create a Evolution.
     * @example
     * // Create one Evolution
     * const Evolution = await prisma.evolution.create({
     *   data: {
     *     // ... data to create a Evolution
     *   }
     * })
     * 
    **/
    create<T extends EvolutionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EvolutionCreateArgs<ExtArgs>>
    ): Prisma__EvolutionClient<$Types.GetResult<EvolutionPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Evolutions.
     *     @param {EvolutionCreateManyArgs} args - Arguments to create many Evolutions.
     *     @example
     *     // Create many Evolutions
     *     const evolution = await prisma.evolution.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EvolutionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EvolutionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Evolution.
     * @param {EvolutionDeleteArgs} args - Arguments to delete one Evolution.
     * @example
     * // Delete one Evolution
     * const Evolution = await prisma.evolution.delete({
     *   where: {
     *     // ... filter to delete one Evolution
     *   }
     * })
     * 
    **/
    delete<T extends EvolutionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EvolutionDeleteArgs<ExtArgs>>
    ): Prisma__EvolutionClient<$Types.GetResult<EvolutionPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Evolution.
     * @param {EvolutionUpdateArgs} args - Arguments to update one Evolution.
     * @example
     * // Update one Evolution
     * const evolution = await prisma.evolution.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EvolutionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EvolutionUpdateArgs<ExtArgs>>
    ): Prisma__EvolutionClient<$Types.GetResult<EvolutionPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Evolutions.
     * @param {EvolutionDeleteManyArgs} args - Arguments to filter Evolutions to delete.
     * @example
     * // Delete a few Evolutions
     * const { count } = await prisma.evolution.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EvolutionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EvolutionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Evolutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvolutionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Evolutions
     * const evolution = await prisma.evolution.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EvolutionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EvolutionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Evolution.
     * @param {EvolutionUpsertArgs} args - Arguments to update or create a Evolution.
     * @example
     * // Update or create a Evolution
     * const evolution = await prisma.evolution.upsert({
     *   create: {
     *     // ... data to create a Evolution
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Evolution we want to update
     *   }
     * })
    **/
    upsert<T extends EvolutionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EvolutionUpsertArgs<ExtArgs>>
    ): Prisma__EvolutionClient<$Types.GetResult<EvolutionPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Evolutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvolutionCountArgs} args - Arguments to filter Evolutions to count.
     * @example
     * // Count the number of Evolutions
     * const count = await prisma.evolution.count({
     *   where: {
     *     // ... the filter for the Evolutions we want to count
     *   }
     * })
    **/
    count<T extends EvolutionCountArgs>(
      args?: Subset<T, EvolutionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EvolutionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Evolution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvolutionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EvolutionAggregateArgs>(args: Subset<T, EvolutionAggregateArgs>): Prisma.PrismaPromise<GetEvolutionAggregateType<T>>

    /**
     * Group by Evolution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvolutionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EvolutionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EvolutionGroupByArgs['orderBy'] }
        : { orderBy?: EvolutionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EvolutionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEvolutionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Evolution.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__EvolutionClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    patient<T extends PatientArgs<ExtArgs> = {}>(args?: Subset<T, PatientArgs<ExtArgs>>): Prisma__PatientClient<$Types.GetResult<PatientPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    doctor<T extends DoctorArgs<ExtArgs> = {}>(args?: Subset<T, DoctorArgs<ExtArgs>>): Prisma__DoctorClient<$Types.GetResult<DoctorPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    specialty<T extends SpecialtyArgs<ExtArgs> = {}>(args?: Subset<T, SpecialtyArgs<ExtArgs>>): Prisma__SpecialtyClient<$Types.GetResult<SpecialtyPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Evolution base type for findUnique actions
   */
  export type EvolutionFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evolution
     */
    select?: EvolutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EvolutionInclude<ExtArgs> | null
    /**
     * Filter, which Evolution to fetch.
     */
    where: EvolutionWhereUniqueInput
  }

  /**
   * Evolution findUnique
   */
  export interface EvolutionFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends EvolutionFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Evolution findUniqueOrThrow
   */
  export type EvolutionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evolution
     */
    select?: EvolutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EvolutionInclude<ExtArgs> | null
    /**
     * Filter, which Evolution to fetch.
     */
    where: EvolutionWhereUniqueInput
  }


  /**
   * Evolution base type for findFirst actions
   */
  export type EvolutionFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evolution
     */
    select?: EvolutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EvolutionInclude<ExtArgs> | null
    /**
     * Filter, which Evolution to fetch.
     */
    where?: EvolutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evolutions to fetch.
     */
    orderBy?: Enumerable<EvolutionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Evolutions.
     */
    cursor?: EvolutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evolutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evolutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Evolutions.
     */
    distinct?: Enumerable<EvolutionScalarFieldEnum>
  }

  /**
   * Evolution findFirst
   */
  export interface EvolutionFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends EvolutionFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Evolution findFirstOrThrow
   */
  export type EvolutionFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evolution
     */
    select?: EvolutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EvolutionInclude<ExtArgs> | null
    /**
     * Filter, which Evolution to fetch.
     */
    where?: EvolutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evolutions to fetch.
     */
    orderBy?: Enumerable<EvolutionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Evolutions.
     */
    cursor?: EvolutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evolutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evolutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Evolutions.
     */
    distinct?: Enumerable<EvolutionScalarFieldEnum>
  }


  /**
   * Evolution findMany
   */
  export type EvolutionFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evolution
     */
    select?: EvolutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EvolutionInclude<ExtArgs> | null
    /**
     * Filter, which Evolutions to fetch.
     */
    where?: EvolutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evolutions to fetch.
     */
    orderBy?: Enumerable<EvolutionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Evolutions.
     */
    cursor?: EvolutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evolutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evolutions.
     */
    skip?: number
    distinct?: Enumerable<EvolutionScalarFieldEnum>
  }


  /**
   * Evolution create
   */
  export type EvolutionCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evolution
     */
    select?: EvolutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EvolutionInclude<ExtArgs> | null
    /**
     * The data needed to create a Evolution.
     */
    data: XOR<EvolutionCreateInput, EvolutionUncheckedCreateInput>
  }


  /**
   * Evolution createMany
   */
  export type EvolutionCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Evolutions.
     */
    data: Enumerable<EvolutionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Evolution update
   */
  export type EvolutionUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evolution
     */
    select?: EvolutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EvolutionInclude<ExtArgs> | null
    /**
     * The data needed to update a Evolution.
     */
    data: XOR<EvolutionUpdateInput, EvolutionUncheckedUpdateInput>
    /**
     * Choose, which Evolution to update.
     */
    where: EvolutionWhereUniqueInput
  }


  /**
   * Evolution updateMany
   */
  export type EvolutionUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Evolutions.
     */
    data: XOR<EvolutionUpdateManyMutationInput, EvolutionUncheckedUpdateManyInput>
    /**
     * Filter which Evolutions to update
     */
    where?: EvolutionWhereInput
  }


  /**
   * Evolution upsert
   */
  export type EvolutionUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evolution
     */
    select?: EvolutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EvolutionInclude<ExtArgs> | null
    /**
     * The filter to search for the Evolution to update in case it exists.
     */
    where: EvolutionWhereUniqueInput
    /**
     * In case the Evolution found by the `where` argument doesn't exist, create a new Evolution with this data.
     */
    create: XOR<EvolutionCreateInput, EvolutionUncheckedCreateInput>
    /**
     * In case the Evolution was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EvolutionUpdateInput, EvolutionUncheckedUpdateInput>
  }


  /**
   * Evolution delete
   */
  export type EvolutionDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evolution
     */
    select?: EvolutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EvolutionInclude<ExtArgs> | null
    /**
     * Filter which Evolution to delete.
     */
    where: EvolutionWhereUniqueInput
  }


  /**
   * Evolution deleteMany
   */
  export type EvolutionDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Evolutions to delete
     */
    where?: EvolutionWhereInput
  }


  /**
   * Evolution without action
   */
  export type EvolutionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evolution
     */
    select?: EvolutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EvolutionInclude<ExtArgs> | null
  }



  /**
   * Model Evaluation
   */


  export type AggregateEvaluation = {
    _count: EvaluationCountAggregateOutputType | null
    _avg: EvaluationAvgAggregateOutputType | null
    _sum: EvaluationSumAggregateOutputType | null
    _min: EvaluationMinAggregateOutputType | null
    _max: EvaluationMaxAggregateOutputType | null
  }

  export type EvaluationAvgAggregateOutputType = {
    numericId: number | null
  }

  export type EvaluationSumAggregateOutputType = {
    numericId: number | null
  }

  export type EvaluationMinAggregateOutputType = {
    id: string | null
    numericId: number | null
    patientId: string | null
    doctorId: string | null
    specialtyId: string | null
    text: string | null
    title: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type EvaluationMaxAggregateOutputType = {
    id: string | null
    numericId: number | null
    patientId: string | null
    doctorId: string | null
    specialtyId: string | null
    text: string | null
    title: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type EvaluationCountAggregateOutputType = {
    id: number
    numericId: number
    patientId: number
    doctorId: number
    specialtyId: number
    text: number
    title: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type EvaluationAvgAggregateInputType = {
    numericId?: true
  }

  export type EvaluationSumAggregateInputType = {
    numericId?: true
  }

  export type EvaluationMinAggregateInputType = {
    id?: true
    numericId?: true
    patientId?: true
    doctorId?: true
    specialtyId?: true
    text?: true
    title?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type EvaluationMaxAggregateInputType = {
    id?: true
    numericId?: true
    patientId?: true
    doctorId?: true
    specialtyId?: true
    text?: true
    title?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type EvaluationCountAggregateInputType = {
    id?: true
    numericId?: true
    patientId?: true
    doctorId?: true
    specialtyId?: true
    text?: true
    title?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type EvaluationAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Evaluation to aggregate.
     */
    where?: EvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evaluations to fetch.
     */
    orderBy?: Enumerable<EvaluationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evaluations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Evaluations
    **/
    _count?: true | EvaluationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EvaluationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EvaluationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EvaluationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EvaluationMaxAggregateInputType
  }

  export type GetEvaluationAggregateType<T extends EvaluationAggregateArgs> = {
        [P in keyof T & keyof AggregateEvaluation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvaluation[P]>
      : GetScalarType<T[P], AggregateEvaluation[P]>
  }




  export type EvaluationGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: EvaluationWhereInput
    orderBy?: Enumerable<EvaluationOrderByWithAggregationInput>
    by: EvaluationScalarFieldEnum[]
    having?: EvaluationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EvaluationCountAggregateInputType | true
    _avg?: EvaluationAvgAggregateInputType
    _sum?: EvaluationSumAggregateInputType
    _min?: EvaluationMinAggregateInputType
    _max?: EvaluationMaxAggregateInputType
  }


  export type EvaluationGroupByOutputType = {
    id: string
    numericId: number
    patientId: string
    doctorId: string
    specialtyId: string
    text: string | null
    title: string | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: EvaluationCountAggregateOutputType | null
    _avg: EvaluationAvgAggregateOutputType | null
    _sum: EvaluationSumAggregateOutputType | null
    _min: EvaluationMinAggregateOutputType | null
    _max: EvaluationMaxAggregateOutputType | null
  }

  type GetEvaluationGroupByPayload<T extends EvaluationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<EvaluationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EvaluationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EvaluationGroupByOutputType[P]>
            : GetScalarType<T[P], EvaluationGroupByOutputType[P]>
        }
      >
    >


  export type EvaluationSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    numericId?: boolean
    patientId?: boolean
    doctorId?: boolean
    specialtyId?: boolean
    text?: boolean
    title?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    patient?: boolean | PatientArgs<ExtArgs>
    doctor?: boolean | DoctorArgs<ExtArgs>
    specialty?: boolean | SpecialtyArgs<ExtArgs>
  }, ExtArgs["result"]["evaluation"]>

  export type EvaluationSelectScalar = {
    id?: boolean
    numericId?: boolean
    patientId?: boolean
    doctorId?: boolean
    specialtyId?: boolean
    text?: boolean
    title?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type EvaluationInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientArgs<ExtArgs>
    doctor?: boolean | DoctorArgs<ExtArgs>
    specialty?: boolean | SpecialtyArgs<ExtArgs>
  }


  type EvaluationGetPayload<S extends boolean | null | undefined | EvaluationArgs> = $Types.GetResult<EvaluationPayload, S>

  type EvaluationCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<EvaluationFindManyArgs, 'select' | 'include'> & {
      select?: EvaluationCountAggregateInputType | true
    }

  export interface EvaluationDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Evaluation'], meta: { name: 'Evaluation' } }
    /**
     * Find zero or one Evaluation that matches the filter.
     * @param {EvaluationFindUniqueArgs} args - Arguments to find a Evaluation
     * @example
     * // Get one Evaluation
     * const evaluation = await prisma.evaluation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EvaluationFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, EvaluationFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Evaluation'> extends True ? Prisma__EvaluationClient<$Types.GetResult<EvaluationPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__EvaluationClient<$Types.GetResult<EvaluationPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Evaluation that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EvaluationFindUniqueOrThrowArgs} args - Arguments to find a Evaluation
     * @example
     * // Get one Evaluation
     * const evaluation = await prisma.evaluation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EvaluationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EvaluationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EvaluationClient<$Types.GetResult<EvaluationPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Evaluation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationFindFirstArgs} args - Arguments to find a Evaluation
     * @example
     * // Get one Evaluation
     * const evaluation = await prisma.evaluation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EvaluationFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, EvaluationFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Evaluation'> extends True ? Prisma__EvaluationClient<$Types.GetResult<EvaluationPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__EvaluationClient<$Types.GetResult<EvaluationPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Evaluation that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationFindFirstOrThrowArgs} args - Arguments to find a Evaluation
     * @example
     * // Get one Evaluation
     * const evaluation = await prisma.evaluation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EvaluationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EvaluationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EvaluationClient<$Types.GetResult<EvaluationPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Evaluations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Evaluations
     * const evaluations = await prisma.evaluation.findMany()
     * 
     * // Get first 10 Evaluations
     * const evaluations = await prisma.evaluation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const evaluationWithIdOnly = await prisma.evaluation.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EvaluationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EvaluationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<EvaluationPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Evaluation.
     * @param {EvaluationCreateArgs} args - Arguments to create a Evaluation.
     * @example
     * // Create one Evaluation
     * const Evaluation = await prisma.evaluation.create({
     *   data: {
     *     // ... data to create a Evaluation
     *   }
     * })
     * 
    **/
    create<T extends EvaluationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EvaluationCreateArgs<ExtArgs>>
    ): Prisma__EvaluationClient<$Types.GetResult<EvaluationPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Evaluations.
     *     @param {EvaluationCreateManyArgs} args - Arguments to create many Evaluations.
     *     @example
     *     // Create many Evaluations
     *     const evaluation = await prisma.evaluation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EvaluationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EvaluationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Evaluation.
     * @param {EvaluationDeleteArgs} args - Arguments to delete one Evaluation.
     * @example
     * // Delete one Evaluation
     * const Evaluation = await prisma.evaluation.delete({
     *   where: {
     *     // ... filter to delete one Evaluation
     *   }
     * })
     * 
    **/
    delete<T extends EvaluationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EvaluationDeleteArgs<ExtArgs>>
    ): Prisma__EvaluationClient<$Types.GetResult<EvaluationPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Evaluation.
     * @param {EvaluationUpdateArgs} args - Arguments to update one Evaluation.
     * @example
     * // Update one Evaluation
     * const evaluation = await prisma.evaluation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EvaluationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EvaluationUpdateArgs<ExtArgs>>
    ): Prisma__EvaluationClient<$Types.GetResult<EvaluationPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Evaluations.
     * @param {EvaluationDeleteManyArgs} args - Arguments to filter Evaluations to delete.
     * @example
     * // Delete a few Evaluations
     * const { count } = await prisma.evaluation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EvaluationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EvaluationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Evaluations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Evaluations
     * const evaluation = await prisma.evaluation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EvaluationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EvaluationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Evaluation.
     * @param {EvaluationUpsertArgs} args - Arguments to update or create a Evaluation.
     * @example
     * // Update or create a Evaluation
     * const evaluation = await prisma.evaluation.upsert({
     *   create: {
     *     // ... data to create a Evaluation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Evaluation we want to update
     *   }
     * })
    **/
    upsert<T extends EvaluationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EvaluationUpsertArgs<ExtArgs>>
    ): Prisma__EvaluationClient<$Types.GetResult<EvaluationPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Evaluations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationCountArgs} args - Arguments to filter Evaluations to count.
     * @example
     * // Count the number of Evaluations
     * const count = await prisma.evaluation.count({
     *   where: {
     *     // ... the filter for the Evaluations we want to count
     *   }
     * })
    **/
    count<T extends EvaluationCountArgs>(
      args?: Subset<T, EvaluationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EvaluationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Evaluation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EvaluationAggregateArgs>(args: Subset<T, EvaluationAggregateArgs>): Prisma.PrismaPromise<GetEvaluationAggregateType<T>>

    /**
     * Group by Evaluation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EvaluationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EvaluationGroupByArgs['orderBy'] }
        : { orderBy?: EvaluationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EvaluationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEvaluationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Evaluation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__EvaluationClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    patient<T extends PatientArgs<ExtArgs> = {}>(args?: Subset<T, PatientArgs<ExtArgs>>): Prisma__PatientClient<$Types.GetResult<PatientPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    doctor<T extends DoctorArgs<ExtArgs> = {}>(args?: Subset<T, DoctorArgs<ExtArgs>>): Prisma__DoctorClient<$Types.GetResult<DoctorPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    specialty<T extends SpecialtyArgs<ExtArgs> = {}>(args?: Subset<T, SpecialtyArgs<ExtArgs>>): Prisma__SpecialtyClient<$Types.GetResult<SpecialtyPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Evaluation base type for findUnique actions
   */
  export type EvaluationFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * Filter, which Evaluation to fetch.
     */
    where: EvaluationWhereUniqueInput
  }

  /**
   * Evaluation findUnique
   */
  export interface EvaluationFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends EvaluationFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Evaluation findUniqueOrThrow
   */
  export type EvaluationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * Filter, which Evaluation to fetch.
     */
    where: EvaluationWhereUniqueInput
  }


  /**
   * Evaluation base type for findFirst actions
   */
  export type EvaluationFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * Filter, which Evaluation to fetch.
     */
    where?: EvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evaluations to fetch.
     */
    orderBy?: Enumerable<EvaluationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Evaluations.
     */
    cursor?: EvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evaluations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Evaluations.
     */
    distinct?: Enumerable<EvaluationScalarFieldEnum>
  }

  /**
   * Evaluation findFirst
   */
  export interface EvaluationFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends EvaluationFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Evaluation findFirstOrThrow
   */
  export type EvaluationFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * Filter, which Evaluation to fetch.
     */
    where?: EvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evaluations to fetch.
     */
    orderBy?: Enumerable<EvaluationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Evaluations.
     */
    cursor?: EvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evaluations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Evaluations.
     */
    distinct?: Enumerable<EvaluationScalarFieldEnum>
  }


  /**
   * Evaluation findMany
   */
  export type EvaluationFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * Filter, which Evaluations to fetch.
     */
    where?: EvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evaluations to fetch.
     */
    orderBy?: Enumerable<EvaluationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Evaluations.
     */
    cursor?: EvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evaluations.
     */
    skip?: number
    distinct?: Enumerable<EvaluationScalarFieldEnum>
  }


  /**
   * Evaluation create
   */
  export type EvaluationCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * The data needed to create a Evaluation.
     */
    data: XOR<EvaluationCreateInput, EvaluationUncheckedCreateInput>
  }


  /**
   * Evaluation createMany
   */
  export type EvaluationCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Evaluations.
     */
    data: Enumerable<EvaluationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Evaluation update
   */
  export type EvaluationUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * The data needed to update a Evaluation.
     */
    data: XOR<EvaluationUpdateInput, EvaluationUncheckedUpdateInput>
    /**
     * Choose, which Evaluation to update.
     */
    where: EvaluationWhereUniqueInput
  }


  /**
   * Evaluation updateMany
   */
  export type EvaluationUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Evaluations.
     */
    data: XOR<EvaluationUpdateManyMutationInput, EvaluationUncheckedUpdateManyInput>
    /**
     * Filter which Evaluations to update
     */
    where?: EvaluationWhereInput
  }


  /**
   * Evaluation upsert
   */
  export type EvaluationUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * The filter to search for the Evaluation to update in case it exists.
     */
    where: EvaluationWhereUniqueInput
    /**
     * In case the Evaluation found by the `where` argument doesn't exist, create a new Evaluation with this data.
     */
    create: XOR<EvaluationCreateInput, EvaluationUncheckedCreateInput>
    /**
     * In case the Evaluation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EvaluationUpdateInput, EvaluationUncheckedUpdateInput>
  }


  /**
   * Evaluation delete
   */
  export type EvaluationDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * Filter which Evaluation to delete.
     */
    where: EvaluationWhereUniqueInput
  }


  /**
   * Evaluation deleteMany
   */
  export type EvaluationDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Evaluations to delete
     */
    where?: EvaluationWhereInput
  }


  /**
   * Evaluation without action
   */
  export type EvaluationArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EvaluationInclude<ExtArgs> | null
  }



  /**
   * Model Exercise
   */


  export type AggregateExercise = {
    _count: ExerciseCountAggregateOutputType | null
    _avg: ExerciseAvgAggregateOutputType | null
    _sum: ExerciseSumAggregateOutputType | null
    _min: ExerciseMinAggregateOutputType | null
    _max: ExerciseMaxAggregateOutputType | null
  }

  export type ExerciseAvgAggregateOutputType = {
    numericId: number | null
  }

  export type ExerciseSumAggregateOutputType = {
    numericId: number | null
  }

  export type ExerciseMinAggregateOutputType = {
    id: string | null
    numericId: number | null
    title: string | null
    description: string | null
    creatorId: string | null
    specialtyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExerciseMaxAggregateOutputType = {
    id: string | null
    numericId: number | null
    title: string | null
    description: string | null
    creatorId: string | null
    specialtyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExerciseCountAggregateOutputType = {
    id: number
    numericId: number
    title: number
    description: number
    links: number
    creatorId: number
    specialtyId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExerciseAvgAggregateInputType = {
    numericId?: true
  }

  export type ExerciseSumAggregateInputType = {
    numericId?: true
  }

  export type ExerciseMinAggregateInputType = {
    id?: true
    numericId?: true
    title?: true
    description?: true
    creatorId?: true
    specialtyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExerciseMaxAggregateInputType = {
    id?: true
    numericId?: true
    title?: true
    description?: true
    creatorId?: true
    specialtyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExerciseCountAggregateInputType = {
    id?: true
    numericId?: true
    title?: true
    description?: true
    links?: true
    creatorId?: true
    specialtyId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExerciseAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Exercise to aggregate.
     */
    where?: ExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exercises to fetch.
     */
    orderBy?: Enumerable<ExerciseOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exercises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Exercises
    **/
    _count?: true | ExerciseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExerciseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExerciseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExerciseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExerciseMaxAggregateInputType
  }

  export type GetExerciseAggregateType<T extends ExerciseAggregateArgs> = {
        [P in keyof T & keyof AggregateExercise]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExercise[P]>
      : GetScalarType<T[P], AggregateExercise[P]>
  }




  export type ExerciseGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ExerciseWhereInput
    orderBy?: Enumerable<ExerciseOrderByWithAggregationInput>
    by: ExerciseScalarFieldEnum[]
    having?: ExerciseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExerciseCountAggregateInputType | true
    _avg?: ExerciseAvgAggregateInputType
    _sum?: ExerciseSumAggregateInputType
    _min?: ExerciseMinAggregateInputType
    _max?: ExerciseMaxAggregateInputType
  }


  export type ExerciseGroupByOutputType = {
    id: string
    numericId: number
    title: string
    description: string
    links: JsonValue
    creatorId: string
    specialtyId: string
    createdAt: Date
    updatedAt: Date
    _count: ExerciseCountAggregateOutputType | null
    _avg: ExerciseAvgAggregateOutputType | null
    _sum: ExerciseSumAggregateOutputType | null
    _min: ExerciseMinAggregateOutputType | null
    _max: ExerciseMaxAggregateOutputType | null
  }

  type GetExerciseGroupByPayload<T extends ExerciseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ExerciseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExerciseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExerciseGroupByOutputType[P]>
            : GetScalarType<T[P], ExerciseGroupByOutputType[P]>
        }
      >
    >


  export type ExerciseSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    numericId?: boolean
    title?: boolean
    description?: boolean
    links?: boolean
    creatorId?: boolean
    specialtyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | UserArgs<ExtArgs>
    specialty?: boolean | SpecialtyArgs<ExtArgs>
  }, ExtArgs["result"]["exercise"]>

  export type ExerciseSelectScalar = {
    id?: boolean
    numericId?: boolean
    title?: boolean
    description?: boolean
    links?: boolean
    creatorId?: boolean
    specialtyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ExerciseInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    creator?: boolean | UserArgs<ExtArgs>
    specialty?: boolean | SpecialtyArgs<ExtArgs>
  }


  type ExerciseGetPayload<S extends boolean | null | undefined | ExerciseArgs> = $Types.GetResult<ExercisePayload, S>

  type ExerciseCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ExerciseFindManyArgs, 'select' | 'include'> & {
      select?: ExerciseCountAggregateInputType | true
    }

  export interface ExerciseDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Exercise'], meta: { name: 'Exercise' } }
    /**
     * Find zero or one Exercise that matches the filter.
     * @param {ExerciseFindUniqueArgs} args - Arguments to find a Exercise
     * @example
     * // Get one Exercise
     * const exercise = await prisma.exercise.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ExerciseFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ExerciseFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Exercise'> extends True ? Prisma__ExerciseClient<$Types.GetResult<ExercisePayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ExerciseClient<$Types.GetResult<ExercisePayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Exercise that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ExerciseFindUniqueOrThrowArgs} args - Arguments to find a Exercise
     * @example
     * // Get one Exercise
     * const exercise = await prisma.exercise.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ExerciseFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ExerciseFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ExerciseClient<$Types.GetResult<ExercisePayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Exercise that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseFindFirstArgs} args - Arguments to find a Exercise
     * @example
     * // Get one Exercise
     * const exercise = await prisma.exercise.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ExerciseFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ExerciseFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Exercise'> extends True ? Prisma__ExerciseClient<$Types.GetResult<ExercisePayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ExerciseClient<$Types.GetResult<ExercisePayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Exercise that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseFindFirstOrThrowArgs} args - Arguments to find a Exercise
     * @example
     * // Get one Exercise
     * const exercise = await prisma.exercise.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ExerciseFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ExerciseFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ExerciseClient<$Types.GetResult<ExercisePayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Exercises that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Exercises
     * const exercises = await prisma.exercise.findMany()
     * 
     * // Get first 10 Exercises
     * const exercises = await prisma.exercise.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const exerciseWithIdOnly = await prisma.exercise.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ExerciseFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ExerciseFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ExercisePayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Exercise.
     * @param {ExerciseCreateArgs} args - Arguments to create a Exercise.
     * @example
     * // Create one Exercise
     * const Exercise = await prisma.exercise.create({
     *   data: {
     *     // ... data to create a Exercise
     *   }
     * })
     * 
    **/
    create<T extends ExerciseCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ExerciseCreateArgs<ExtArgs>>
    ): Prisma__ExerciseClient<$Types.GetResult<ExercisePayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Exercises.
     *     @param {ExerciseCreateManyArgs} args - Arguments to create many Exercises.
     *     @example
     *     // Create many Exercises
     *     const exercise = await prisma.exercise.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ExerciseCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ExerciseCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Exercise.
     * @param {ExerciseDeleteArgs} args - Arguments to delete one Exercise.
     * @example
     * // Delete one Exercise
     * const Exercise = await prisma.exercise.delete({
     *   where: {
     *     // ... filter to delete one Exercise
     *   }
     * })
     * 
    **/
    delete<T extends ExerciseDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ExerciseDeleteArgs<ExtArgs>>
    ): Prisma__ExerciseClient<$Types.GetResult<ExercisePayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Exercise.
     * @param {ExerciseUpdateArgs} args - Arguments to update one Exercise.
     * @example
     * // Update one Exercise
     * const exercise = await prisma.exercise.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ExerciseUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ExerciseUpdateArgs<ExtArgs>>
    ): Prisma__ExerciseClient<$Types.GetResult<ExercisePayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Exercises.
     * @param {ExerciseDeleteManyArgs} args - Arguments to filter Exercises to delete.
     * @example
     * // Delete a few Exercises
     * const { count } = await prisma.exercise.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ExerciseDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ExerciseDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Exercises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Exercises
     * const exercise = await prisma.exercise.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ExerciseUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ExerciseUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Exercise.
     * @param {ExerciseUpsertArgs} args - Arguments to update or create a Exercise.
     * @example
     * // Update or create a Exercise
     * const exercise = await prisma.exercise.upsert({
     *   create: {
     *     // ... data to create a Exercise
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Exercise we want to update
     *   }
     * })
    **/
    upsert<T extends ExerciseUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ExerciseUpsertArgs<ExtArgs>>
    ): Prisma__ExerciseClient<$Types.GetResult<ExercisePayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Exercises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseCountArgs} args - Arguments to filter Exercises to count.
     * @example
     * // Count the number of Exercises
     * const count = await prisma.exercise.count({
     *   where: {
     *     // ... the filter for the Exercises we want to count
     *   }
     * })
    **/
    count<T extends ExerciseCountArgs>(
      args?: Subset<T, ExerciseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExerciseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Exercise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExerciseAggregateArgs>(args: Subset<T, ExerciseAggregateArgs>): Prisma.PrismaPromise<GetExerciseAggregateType<T>>

    /**
     * Group by Exercise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExerciseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExerciseGroupByArgs['orderBy'] }
        : { orderBy?: ExerciseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExerciseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExerciseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Exercise.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ExerciseClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    creator<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    specialty<T extends SpecialtyArgs<ExtArgs> = {}>(args?: Subset<T, SpecialtyArgs<ExtArgs>>): Prisma__SpecialtyClient<$Types.GetResult<SpecialtyPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Exercise base type for findUnique actions
   */
  export type ExerciseFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * Filter, which Exercise to fetch.
     */
    where: ExerciseWhereUniqueInput
  }

  /**
   * Exercise findUnique
   */
  export interface ExerciseFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ExerciseFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Exercise findUniqueOrThrow
   */
  export type ExerciseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * Filter, which Exercise to fetch.
     */
    where: ExerciseWhereUniqueInput
  }


  /**
   * Exercise base type for findFirst actions
   */
  export type ExerciseFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * Filter, which Exercise to fetch.
     */
    where?: ExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exercises to fetch.
     */
    orderBy?: Enumerable<ExerciseOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Exercises.
     */
    cursor?: ExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exercises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Exercises.
     */
    distinct?: Enumerable<ExerciseScalarFieldEnum>
  }

  /**
   * Exercise findFirst
   */
  export interface ExerciseFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ExerciseFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Exercise findFirstOrThrow
   */
  export type ExerciseFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * Filter, which Exercise to fetch.
     */
    where?: ExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exercises to fetch.
     */
    orderBy?: Enumerable<ExerciseOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Exercises.
     */
    cursor?: ExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exercises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Exercises.
     */
    distinct?: Enumerable<ExerciseScalarFieldEnum>
  }


  /**
   * Exercise findMany
   */
  export type ExerciseFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * Filter, which Exercises to fetch.
     */
    where?: ExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exercises to fetch.
     */
    orderBy?: Enumerable<ExerciseOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Exercises.
     */
    cursor?: ExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exercises.
     */
    skip?: number
    distinct?: Enumerable<ExerciseScalarFieldEnum>
  }


  /**
   * Exercise create
   */
  export type ExerciseCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * The data needed to create a Exercise.
     */
    data: XOR<ExerciseCreateInput, ExerciseUncheckedCreateInput>
  }


  /**
   * Exercise createMany
   */
  export type ExerciseCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Exercises.
     */
    data: Enumerable<ExerciseCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Exercise update
   */
  export type ExerciseUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * The data needed to update a Exercise.
     */
    data: XOR<ExerciseUpdateInput, ExerciseUncheckedUpdateInput>
    /**
     * Choose, which Exercise to update.
     */
    where: ExerciseWhereUniqueInput
  }


  /**
   * Exercise updateMany
   */
  export type ExerciseUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Exercises.
     */
    data: XOR<ExerciseUpdateManyMutationInput, ExerciseUncheckedUpdateManyInput>
    /**
     * Filter which Exercises to update
     */
    where?: ExerciseWhereInput
  }


  /**
   * Exercise upsert
   */
  export type ExerciseUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * The filter to search for the Exercise to update in case it exists.
     */
    where: ExerciseWhereUniqueInput
    /**
     * In case the Exercise found by the `where` argument doesn't exist, create a new Exercise with this data.
     */
    create: XOR<ExerciseCreateInput, ExerciseUncheckedCreateInput>
    /**
     * In case the Exercise was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExerciseUpdateInput, ExerciseUncheckedUpdateInput>
  }


  /**
   * Exercise delete
   */
  export type ExerciseDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExerciseInclude<ExtArgs> | null
    /**
     * Filter which Exercise to delete.
     */
    where: ExerciseWhereUniqueInput
  }


  /**
   * Exercise deleteMany
   */
  export type ExerciseDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Exercises to delete
     */
    where?: ExerciseWhereInput
  }


  /**
   * Exercise without action
   */
  export type ExerciseArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExerciseInclude<ExtArgs> | null
  }



  /**
   * Model Template
   */


  export type AggregateTemplate = {
    _count: TemplateCountAggregateOutputType | null
    _avg: TemplateAvgAggregateOutputType | null
    _sum: TemplateSumAggregateOutputType | null
    _min: TemplateMinAggregateOutputType | null
    _max: TemplateMaxAggregateOutputType | null
  }

  export type TemplateAvgAggregateOutputType = {
    numericId: number | null
  }

  export type TemplateSumAggregateOutputType = {
    numericId: number | null
  }

  export type TemplateMinAggregateOutputType = {
    id: string | null
    numericId: number | null
    doctorId: string | null
    type: TemplateType | null
    specialtyId: string | null
    title: string | null
    html: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type TemplateMaxAggregateOutputType = {
    id: string | null
    numericId: number | null
    doctorId: string | null
    type: TemplateType | null
    specialtyId: string | null
    title: string | null
    html: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type TemplateCountAggregateOutputType = {
    id: number
    numericId: number
    doctorId: number
    type: number
    specialtyId: number
    title: number
    html: number
    isActive: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type TemplateAvgAggregateInputType = {
    numericId?: true
  }

  export type TemplateSumAggregateInputType = {
    numericId?: true
  }

  export type TemplateMinAggregateInputType = {
    id?: true
    numericId?: true
    doctorId?: true
    type?: true
    specialtyId?: true
    title?: true
    html?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type TemplateMaxAggregateInputType = {
    id?: true
    numericId?: true
    doctorId?: true
    type?: true
    specialtyId?: true
    title?: true
    html?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type TemplateCountAggregateInputType = {
    id?: true
    numericId?: true
    doctorId?: true
    type?: true
    specialtyId?: true
    title?: true
    html?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type TemplateAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Template to aggregate.
     */
    where?: TemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Templates to fetch.
     */
    orderBy?: Enumerable<TemplateOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Templates
    **/
    _count?: true | TemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TemplateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TemplateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TemplateMaxAggregateInputType
  }

  export type GetTemplateAggregateType<T extends TemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTemplate[P]>
      : GetScalarType<T[P], AggregateTemplate[P]>
  }




  export type TemplateGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: TemplateWhereInput
    orderBy?: Enumerable<TemplateOrderByWithAggregationInput>
    by: TemplateScalarFieldEnum[]
    having?: TemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TemplateCountAggregateInputType | true
    _avg?: TemplateAvgAggregateInputType
    _sum?: TemplateSumAggregateInputType
    _min?: TemplateMinAggregateInputType
    _max?: TemplateMaxAggregateInputType
  }


  export type TemplateGroupByOutputType = {
    id: string
    numericId: number
    doctorId: string
    type: TemplateType
    specialtyId: string
    title: string
    html: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: TemplateCountAggregateOutputType | null
    _avg: TemplateAvgAggregateOutputType | null
    _sum: TemplateSumAggregateOutputType | null
    _min: TemplateMinAggregateOutputType | null
    _max: TemplateMaxAggregateOutputType | null
  }

  type GetTemplateGroupByPayload<T extends TemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TemplateGroupByOutputType[P]>
            : GetScalarType<T[P], TemplateGroupByOutputType[P]>
        }
      >
    >


  export type TemplateSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    numericId?: boolean
    doctorId?: boolean
    type?: boolean
    specialtyId?: boolean
    title?: boolean
    html?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    doctor?: boolean | DoctorArgs<ExtArgs>
    specialty?: boolean | SpecialtyArgs<ExtArgs>
  }, ExtArgs["result"]["template"]>

  export type TemplateSelectScalar = {
    id?: boolean
    numericId?: boolean
    doctorId?: boolean
    type?: boolean
    specialtyId?: boolean
    title?: boolean
    html?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type TemplateInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    doctor?: boolean | DoctorArgs<ExtArgs>
    specialty?: boolean | SpecialtyArgs<ExtArgs>
  }


  type TemplateGetPayload<S extends boolean | null | undefined | TemplateArgs> = $Types.GetResult<TemplatePayload, S>

  type TemplateCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<TemplateFindManyArgs, 'select' | 'include'> & {
      select?: TemplateCountAggregateInputType | true
    }

  export interface TemplateDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Template'], meta: { name: 'Template' } }
    /**
     * Find zero or one Template that matches the filter.
     * @param {TemplateFindUniqueArgs} args - Arguments to find a Template
     * @example
     * // Get one Template
     * const template = await prisma.template.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TemplateFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TemplateFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Template'> extends True ? Prisma__TemplateClient<$Types.GetResult<TemplatePayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__TemplateClient<$Types.GetResult<TemplatePayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Template that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TemplateFindUniqueOrThrowArgs} args - Arguments to find a Template
     * @example
     * // Get one Template
     * const template = await prisma.template.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TemplateFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TemplateFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TemplateClient<$Types.GetResult<TemplatePayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Template that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateFindFirstArgs} args - Arguments to find a Template
     * @example
     * // Get one Template
     * const template = await prisma.template.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TemplateFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TemplateFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Template'> extends True ? Prisma__TemplateClient<$Types.GetResult<TemplatePayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__TemplateClient<$Types.GetResult<TemplatePayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Template that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateFindFirstOrThrowArgs} args - Arguments to find a Template
     * @example
     * // Get one Template
     * const template = await prisma.template.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TemplateFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TemplateFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TemplateClient<$Types.GetResult<TemplatePayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Templates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Templates
     * const templates = await prisma.template.findMany()
     * 
     * // Get first 10 Templates
     * const templates = await prisma.template.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const templateWithIdOnly = await prisma.template.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TemplateFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TemplateFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<TemplatePayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Template.
     * @param {TemplateCreateArgs} args - Arguments to create a Template.
     * @example
     * // Create one Template
     * const Template = await prisma.template.create({
     *   data: {
     *     // ... data to create a Template
     *   }
     * })
     * 
    **/
    create<T extends TemplateCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TemplateCreateArgs<ExtArgs>>
    ): Prisma__TemplateClient<$Types.GetResult<TemplatePayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Templates.
     *     @param {TemplateCreateManyArgs} args - Arguments to create many Templates.
     *     @example
     *     // Create many Templates
     *     const template = await prisma.template.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TemplateCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TemplateCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Template.
     * @param {TemplateDeleteArgs} args - Arguments to delete one Template.
     * @example
     * // Delete one Template
     * const Template = await prisma.template.delete({
     *   where: {
     *     // ... filter to delete one Template
     *   }
     * })
     * 
    **/
    delete<T extends TemplateDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TemplateDeleteArgs<ExtArgs>>
    ): Prisma__TemplateClient<$Types.GetResult<TemplatePayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Template.
     * @param {TemplateUpdateArgs} args - Arguments to update one Template.
     * @example
     * // Update one Template
     * const template = await prisma.template.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TemplateUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TemplateUpdateArgs<ExtArgs>>
    ): Prisma__TemplateClient<$Types.GetResult<TemplatePayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Templates.
     * @param {TemplateDeleteManyArgs} args - Arguments to filter Templates to delete.
     * @example
     * // Delete a few Templates
     * const { count } = await prisma.template.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TemplateDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TemplateDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Templates
     * const template = await prisma.template.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TemplateUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TemplateUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Template.
     * @param {TemplateUpsertArgs} args - Arguments to update or create a Template.
     * @example
     * // Update or create a Template
     * const template = await prisma.template.upsert({
     *   create: {
     *     // ... data to create a Template
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Template we want to update
     *   }
     * })
    **/
    upsert<T extends TemplateUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TemplateUpsertArgs<ExtArgs>>
    ): Prisma__TemplateClient<$Types.GetResult<TemplatePayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateCountArgs} args - Arguments to filter Templates to count.
     * @example
     * // Count the number of Templates
     * const count = await prisma.template.count({
     *   where: {
     *     // ... the filter for the Templates we want to count
     *   }
     * })
    **/
    count<T extends TemplateCountArgs>(
      args?: Subset<T, TemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Template.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TemplateAggregateArgs>(args: Subset<T, TemplateAggregateArgs>): Prisma.PrismaPromise<GetTemplateAggregateType<T>>

    /**
     * Group by Template.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TemplateGroupByArgs['orderBy'] }
        : { orderBy?: TemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Template.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TemplateClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    doctor<T extends DoctorArgs<ExtArgs> = {}>(args?: Subset<T, DoctorArgs<ExtArgs>>): Prisma__DoctorClient<$Types.GetResult<DoctorPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    specialty<T extends SpecialtyArgs<ExtArgs> = {}>(args?: Subset<T, SpecialtyArgs<ExtArgs>>): Prisma__SpecialtyClient<$Types.GetResult<SpecialtyPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Template base type for findUnique actions
   */
  export type TemplateFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateInclude<ExtArgs> | null
    /**
     * Filter, which Template to fetch.
     */
    where: TemplateWhereUniqueInput
  }

  /**
   * Template findUnique
   */
  export interface TemplateFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends TemplateFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Template findUniqueOrThrow
   */
  export type TemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateInclude<ExtArgs> | null
    /**
     * Filter, which Template to fetch.
     */
    where: TemplateWhereUniqueInput
  }


  /**
   * Template base type for findFirst actions
   */
  export type TemplateFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateInclude<ExtArgs> | null
    /**
     * Filter, which Template to fetch.
     */
    where?: TemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Templates to fetch.
     */
    orderBy?: Enumerable<TemplateOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Templates.
     */
    cursor?: TemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Templates.
     */
    distinct?: Enumerable<TemplateScalarFieldEnum>
  }

  /**
   * Template findFirst
   */
  export interface TemplateFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends TemplateFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Template findFirstOrThrow
   */
  export type TemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateInclude<ExtArgs> | null
    /**
     * Filter, which Template to fetch.
     */
    where?: TemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Templates to fetch.
     */
    orderBy?: Enumerable<TemplateOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Templates.
     */
    cursor?: TemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Templates.
     */
    distinct?: Enumerable<TemplateScalarFieldEnum>
  }


  /**
   * Template findMany
   */
  export type TemplateFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateInclude<ExtArgs> | null
    /**
     * Filter, which Templates to fetch.
     */
    where?: TemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Templates to fetch.
     */
    orderBy?: Enumerable<TemplateOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Templates.
     */
    cursor?: TemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Templates.
     */
    skip?: number
    distinct?: Enumerable<TemplateScalarFieldEnum>
  }


  /**
   * Template create
   */
  export type TemplateCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a Template.
     */
    data: XOR<TemplateCreateInput, TemplateUncheckedCreateInput>
  }


  /**
   * Template createMany
   */
  export type TemplateCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Templates.
     */
    data: Enumerable<TemplateCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Template update
   */
  export type TemplateUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a Template.
     */
    data: XOR<TemplateUpdateInput, TemplateUncheckedUpdateInput>
    /**
     * Choose, which Template to update.
     */
    where: TemplateWhereUniqueInput
  }


  /**
   * Template updateMany
   */
  export type TemplateUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Templates.
     */
    data: XOR<TemplateUpdateManyMutationInput, TemplateUncheckedUpdateManyInput>
    /**
     * Filter which Templates to update
     */
    where?: TemplateWhereInput
  }


  /**
   * Template upsert
   */
  export type TemplateUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the Template to update in case it exists.
     */
    where: TemplateWhereUniqueInput
    /**
     * In case the Template found by the `where` argument doesn't exist, create a new Template with this data.
     */
    create: XOR<TemplateCreateInput, TemplateUncheckedCreateInput>
    /**
     * In case the Template was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TemplateUpdateInput, TemplateUncheckedUpdateInput>
  }


  /**
   * Template delete
   */
  export type TemplateDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateInclude<ExtArgs> | null
    /**
     * Filter which Template to delete.
     */
    where: TemplateWhereUniqueInput
  }


  /**
   * Template deleteMany
   */
  export type TemplateDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Templates to delete
     */
    where?: TemplateWhereInput
  }


  /**
   * Template without action
   */
  export type TemplateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TemplateInclude<ExtArgs> | null
  }



  /**
   * Model Course
   */


  export type AggregateCourse = {
    _count: CourseCountAggregateOutputType | null
    _avg: CourseAvgAggregateOutputType | null
    _sum: CourseSumAggregateOutputType | null
    _min: CourseMinAggregateOutputType | null
    _max: CourseMaxAggregateOutputType | null
  }

  export type CourseAvgAggregateOutputType = {
    numericId: number | null
    order: number | null
  }

  export type CourseSumAggregateOutputType = {
    numericId: number | null
    order: number | null
  }

  export type CourseMinAggregateOutputType = {
    id: string | null
    numericId: number | null
    creatorId: string | null
    specialtyId: string | null
    order: number | null
    title: string | null
    cover: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type CourseMaxAggregateOutputType = {
    id: string | null
    numericId: number | null
    creatorId: string | null
    specialtyId: string | null
    order: number | null
    title: string | null
    cover: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type CourseCountAggregateOutputType = {
    id: number
    numericId: number
    creatorId: number
    specialtyId: number
    order: number
    title: number
    cover: number
    description: number
    isActive: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type CourseAvgAggregateInputType = {
    numericId?: true
    order?: true
  }

  export type CourseSumAggregateInputType = {
    numericId?: true
    order?: true
  }

  export type CourseMinAggregateInputType = {
    id?: true
    numericId?: true
    creatorId?: true
    specialtyId?: true
    order?: true
    title?: true
    cover?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type CourseMaxAggregateInputType = {
    id?: true
    numericId?: true
    creatorId?: true
    specialtyId?: true
    order?: true
    title?: true
    cover?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type CourseCountAggregateInputType = {
    id?: true
    numericId?: true
    creatorId?: true
    specialtyId?: true
    order?: true
    title?: true
    cover?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type CourseAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Course to aggregate.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: Enumerable<CourseOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Courses
    **/
    _count?: true | CourseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CourseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CourseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseMaxAggregateInputType
  }

  export type GetCourseAggregateType<T extends CourseAggregateArgs> = {
        [P in keyof T & keyof AggregateCourse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourse[P]>
      : GetScalarType<T[P], AggregateCourse[P]>
  }




  export type CourseGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CourseWhereInput
    orderBy?: Enumerable<CourseOrderByWithAggregationInput>
    by: CourseScalarFieldEnum[]
    having?: CourseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseCountAggregateInputType | true
    _avg?: CourseAvgAggregateInputType
    _sum?: CourseSumAggregateInputType
    _min?: CourseMinAggregateInputType
    _max?: CourseMaxAggregateInputType
  }


  export type CourseGroupByOutputType = {
    id: string
    numericId: number
    creatorId: string
    specialtyId: string
    order: number
    title: string
    cover: string | null
    description: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: CourseCountAggregateOutputType | null
    _avg: CourseAvgAggregateOutputType | null
    _sum: CourseSumAggregateOutputType | null
    _min: CourseMinAggregateOutputType | null
    _max: CourseMaxAggregateOutputType | null
  }

  type GetCourseGroupByPayload<T extends CourseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CourseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseGroupByOutputType[P]>
            : GetScalarType<T[P], CourseGroupByOutputType[P]>
        }
      >
    >


  export type CourseSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    numericId?: boolean
    creatorId?: boolean
    specialtyId?: boolean
    order?: boolean
    title?: boolean
    cover?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    creator?: boolean | UserArgs<ExtArgs>
    specialty?: boolean | SpecialtyArgs<ExtArgs>
    lessons?: boolean | Course$lessonsArgs<ExtArgs>
    _count?: boolean | CourseCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["course"]>

  export type CourseSelectScalar = {
    id?: boolean
    numericId?: boolean
    creatorId?: boolean
    specialtyId?: boolean
    order?: boolean
    title?: boolean
    cover?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type CourseInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    creator?: boolean | UserArgs<ExtArgs>
    specialty?: boolean | SpecialtyArgs<ExtArgs>
    lessons?: boolean | Course$lessonsArgs<ExtArgs>
    _count?: boolean | CourseCountOutputTypeArgs<ExtArgs>
  }


  type CourseGetPayload<S extends boolean | null | undefined | CourseArgs> = $Types.GetResult<CoursePayload, S>

  type CourseCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<CourseFindManyArgs, 'select' | 'include'> & {
      select?: CourseCountAggregateInputType | true
    }

  export interface CourseDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Course'], meta: { name: 'Course' } }
    /**
     * Find zero or one Course that matches the filter.
     * @param {CourseFindUniqueArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CourseFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CourseFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Course'> extends True ? Prisma__CourseClient<$Types.GetResult<CoursePayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__CourseClient<$Types.GetResult<CoursePayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Course that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CourseFindUniqueOrThrowArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CourseFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CourseFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CourseClient<$Types.GetResult<CoursePayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Course that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindFirstArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CourseFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CourseFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Course'> extends True ? Prisma__CourseClient<$Types.GetResult<CoursePayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__CourseClient<$Types.GetResult<CoursePayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Course that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindFirstOrThrowArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CourseFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CourseFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CourseClient<$Types.GetResult<CoursePayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Courses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Courses
     * const courses = await prisma.course.findMany()
     * 
     * // Get first 10 Courses
     * const courses = await prisma.course.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courseWithIdOnly = await prisma.course.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CourseFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CourseFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<CoursePayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Course.
     * @param {CourseCreateArgs} args - Arguments to create a Course.
     * @example
     * // Create one Course
     * const Course = await prisma.course.create({
     *   data: {
     *     // ... data to create a Course
     *   }
     * })
     * 
    **/
    create<T extends CourseCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CourseCreateArgs<ExtArgs>>
    ): Prisma__CourseClient<$Types.GetResult<CoursePayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Courses.
     *     @param {CourseCreateManyArgs} args - Arguments to create many Courses.
     *     @example
     *     // Create many Courses
     *     const course = await prisma.course.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CourseCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CourseCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Course.
     * @param {CourseDeleteArgs} args - Arguments to delete one Course.
     * @example
     * // Delete one Course
     * const Course = await prisma.course.delete({
     *   where: {
     *     // ... filter to delete one Course
     *   }
     * })
     * 
    **/
    delete<T extends CourseDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CourseDeleteArgs<ExtArgs>>
    ): Prisma__CourseClient<$Types.GetResult<CoursePayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Course.
     * @param {CourseUpdateArgs} args - Arguments to update one Course.
     * @example
     * // Update one Course
     * const course = await prisma.course.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CourseUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CourseUpdateArgs<ExtArgs>>
    ): Prisma__CourseClient<$Types.GetResult<CoursePayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Courses.
     * @param {CourseDeleteManyArgs} args - Arguments to filter Courses to delete.
     * @example
     * // Delete a few Courses
     * const { count } = await prisma.course.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CourseDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CourseDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Courses
     * const course = await prisma.course.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CourseUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CourseUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Course.
     * @param {CourseUpsertArgs} args - Arguments to update or create a Course.
     * @example
     * // Update or create a Course
     * const course = await prisma.course.upsert({
     *   create: {
     *     // ... data to create a Course
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Course we want to update
     *   }
     * })
    **/
    upsert<T extends CourseUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CourseUpsertArgs<ExtArgs>>
    ): Prisma__CourseClient<$Types.GetResult<CoursePayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseCountArgs} args - Arguments to filter Courses to count.
     * @example
     * // Count the number of Courses
     * const count = await prisma.course.count({
     *   where: {
     *     // ... the filter for the Courses we want to count
     *   }
     * })
    **/
    count<T extends CourseCountArgs>(
      args?: Subset<T, CourseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseAggregateArgs>(args: Subset<T, CourseAggregateArgs>): Prisma.PrismaPromise<GetCourseAggregateType<T>>

    /**
     * Group by Course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseGroupByArgs['orderBy'] }
        : { orderBy?: CourseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Course.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CourseClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    creator<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    specialty<T extends SpecialtyArgs<ExtArgs> = {}>(args?: Subset<T, SpecialtyArgs<ExtArgs>>): Prisma__SpecialtyClient<$Types.GetResult<SpecialtyPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    lessons<T extends Course$lessonsArgs<ExtArgs> = {}>(args?: Subset<T, Course$lessonsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<LessonPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Course base type for findUnique actions
   */
  export type CourseFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course findUnique
   */
  export interface CourseFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends CourseFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Course findUniqueOrThrow
   */
  export type CourseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where: CourseWhereUniqueInput
  }


  /**
   * Course base type for findFirst actions
   */
  export type CourseFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: Enumerable<CourseOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courses.
     */
    distinct?: Enumerable<CourseScalarFieldEnum>
  }

  /**
   * Course findFirst
   */
  export interface CourseFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends CourseFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Course findFirstOrThrow
   */
  export type CourseFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: Enumerable<CourseOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courses.
     */
    distinct?: Enumerable<CourseScalarFieldEnum>
  }


  /**
   * Course findMany
   */
  export type CourseFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Courses to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: Enumerable<CourseOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    distinct?: Enumerable<CourseScalarFieldEnum>
  }


  /**
   * Course create
   */
  export type CourseCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The data needed to create a Course.
     */
    data: XOR<CourseCreateInput, CourseUncheckedCreateInput>
  }


  /**
   * Course createMany
   */
  export type CourseCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Courses.
     */
    data: Enumerable<CourseCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Course update
   */
  export type CourseUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The data needed to update a Course.
     */
    data: XOR<CourseUpdateInput, CourseUncheckedUpdateInput>
    /**
     * Choose, which Course to update.
     */
    where: CourseWhereUniqueInput
  }


  /**
   * Course updateMany
   */
  export type CourseUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Courses.
     */
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyInput>
    /**
     * Filter which Courses to update
     */
    where?: CourseWhereInput
  }


  /**
   * Course upsert
   */
  export type CourseUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The filter to search for the Course to update in case it exists.
     */
    where: CourseWhereUniqueInput
    /**
     * In case the Course found by the `where` argument doesn't exist, create a new Course with this data.
     */
    create: XOR<CourseCreateInput, CourseUncheckedCreateInput>
    /**
     * In case the Course was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseUpdateInput, CourseUncheckedUpdateInput>
  }


  /**
   * Course delete
   */
  export type CourseDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter which Course to delete.
     */
    where: CourseWhereUniqueInput
  }


  /**
   * Course deleteMany
   */
  export type CourseDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Courses to delete
     */
    where?: CourseWhereInput
  }


  /**
   * Course.lessons
   */
  export type Course$lessonsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LessonInclude<ExtArgs> | null
    where?: LessonWhereInput
    orderBy?: Enumerable<LessonOrderByWithRelationInput>
    cursor?: LessonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<LessonScalarFieldEnum>
  }


  /**
   * Course without action
   */
  export type CourseArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CourseInclude<ExtArgs> | null
  }



  /**
   * Model Lesson
   */


  export type AggregateLesson = {
    _count: LessonCountAggregateOutputType | null
    _avg: LessonAvgAggregateOutputType | null
    _sum: LessonSumAggregateOutputType | null
    _min: LessonMinAggregateOutputType | null
    _max: LessonMaxAggregateOutputType | null
  }

  export type LessonAvgAggregateOutputType = {
    numericId: number | null
    order: number | null
  }

  export type LessonSumAggregateOutputType = {
    numericId: number | null
    order: number | null
  }

  export type LessonMinAggregateOutputType = {
    id: string | null
    numericId: number | null
    creatorId: string | null
    courseId: string | null
    order: number | null
    title: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type LessonMaxAggregateOutputType = {
    id: string | null
    numericId: number | null
    creatorId: string | null
    courseId: string | null
    order: number | null
    title: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type LessonCountAggregateOutputType = {
    id: number
    numericId: number
    creatorId: number
    courseId: number
    order: number
    title: number
    description: number
    isActive: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type LessonAvgAggregateInputType = {
    numericId?: true
    order?: true
  }

  export type LessonSumAggregateInputType = {
    numericId?: true
    order?: true
  }

  export type LessonMinAggregateInputType = {
    id?: true
    numericId?: true
    creatorId?: true
    courseId?: true
    order?: true
    title?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type LessonMaxAggregateInputType = {
    id?: true
    numericId?: true
    creatorId?: true
    courseId?: true
    order?: true
    title?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type LessonCountAggregateInputType = {
    id?: true
    numericId?: true
    creatorId?: true
    courseId?: true
    order?: true
    title?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type LessonAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lesson to aggregate.
     */
    where?: LessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: Enumerable<LessonOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Lessons
    **/
    _count?: true | LessonCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LessonAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LessonSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LessonMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LessonMaxAggregateInputType
  }

  export type GetLessonAggregateType<T extends LessonAggregateArgs> = {
        [P in keyof T & keyof AggregateLesson]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLesson[P]>
      : GetScalarType<T[P], AggregateLesson[P]>
  }




  export type LessonGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: LessonWhereInput
    orderBy?: Enumerable<LessonOrderByWithAggregationInput>
    by: LessonScalarFieldEnum[]
    having?: LessonScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LessonCountAggregateInputType | true
    _avg?: LessonAvgAggregateInputType
    _sum?: LessonSumAggregateInputType
    _min?: LessonMinAggregateInputType
    _max?: LessonMaxAggregateInputType
  }


  export type LessonGroupByOutputType = {
    id: string
    numericId: number
    creatorId: string
    courseId: string
    order: number
    title: string
    description: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: LessonCountAggregateOutputType | null
    _avg: LessonAvgAggregateOutputType | null
    _sum: LessonSumAggregateOutputType | null
    _min: LessonMinAggregateOutputType | null
    _max: LessonMaxAggregateOutputType | null
  }

  type GetLessonGroupByPayload<T extends LessonGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<LessonGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LessonGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LessonGroupByOutputType[P]>
            : GetScalarType<T[P], LessonGroupByOutputType[P]>
        }
      >
    >


  export type LessonSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    numericId?: boolean
    creatorId?: boolean
    courseId?: boolean
    order?: boolean
    title?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    creator?: boolean | UserArgs<ExtArgs>
    course?: boolean | CourseArgs<ExtArgs>
    videos?: boolean | Lesson$videosArgs<ExtArgs>
    _count?: boolean | LessonCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["lesson"]>

  export type LessonSelectScalar = {
    id?: boolean
    numericId?: boolean
    creatorId?: boolean
    courseId?: boolean
    order?: boolean
    title?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type LessonInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    creator?: boolean | UserArgs<ExtArgs>
    course?: boolean | CourseArgs<ExtArgs>
    videos?: boolean | Lesson$videosArgs<ExtArgs>
    _count?: boolean | LessonCountOutputTypeArgs<ExtArgs>
  }


  type LessonGetPayload<S extends boolean | null | undefined | LessonArgs> = $Types.GetResult<LessonPayload, S>

  type LessonCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<LessonFindManyArgs, 'select' | 'include'> & {
      select?: LessonCountAggregateInputType | true
    }

  export interface LessonDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lesson'], meta: { name: 'Lesson' } }
    /**
     * Find zero or one Lesson that matches the filter.
     * @param {LessonFindUniqueArgs} args - Arguments to find a Lesson
     * @example
     * // Get one Lesson
     * const lesson = await prisma.lesson.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LessonFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LessonFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Lesson'> extends True ? Prisma__LessonClient<$Types.GetResult<LessonPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__LessonClient<$Types.GetResult<LessonPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Lesson that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LessonFindUniqueOrThrowArgs} args - Arguments to find a Lesson
     * @example
     * // Get one Lesson
     * const lesson = await prisma.lesson.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LessonFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LessonFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__LessonClient<$Types.GetResult<LessonPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Lesson that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonFindFirstArgs} args - Arguments to find a Lesson
     * @example
     * // Get one Lesson
     * const lesson = await prisma.lesson.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LessonFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LessonFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Lesson'> extends True ? Prisma__LessonClient<$Types.GetResult<LessonPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__LessonClient<$Types.GetResult<LessonPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Lesson that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonFindFirstOrThrowArgs} args - Arguments to find a Lesson
     * @example
     * // Get one Lesson
     * const lesson = await prisma.lesson.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LessonFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LessonFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__LessonClient<$Types.GetResult<LessonPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Lessons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lessons
     * const lessons = await prisma.lesson.findMany()
     * 
     * // Get first 10 Lessons
     * const lessons = await prisma.lesson.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lessonWithIdOnly = await prisma.lesson.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LessonFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LessonFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<LessonPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Lesson.
     * @param {LessonCreateArgs} args - Arguments to create a Lesson.
     * @example
     * // Create one Lesson
     * const Lesson = await prisma.lesson.create({
     *   data: {
     *     // ... data to create a Lesson
     *   }
     * })
     * 
    **/
    create<T extends LessonCreateArgs<ExtArgs>>(
      args: SelectSubset<T, LessonCreateArgs<ExtArgs>>
    ): Prisma__LessonClient<$Types.GetResult<LessonPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Lessons.
     *     @param {LessonCreateManyArgs} args - Arguments to create many Lessons.
     *     @example
     *     // Create many Lessons
     *     const lesson = await prisma.lesson.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LessonCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LessonCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Lesson.
     * @param {LessonDeleteArgs} args - Arguments to delete one Lesson.
     * @example
     * // Delete one Lesson
     * const Lesson = await prisma.lesson.delete({
     *   where: {
     *     // ... filter to delete one Lesson
     *   }
     * })
     * 
    **/
    delete<T extends LessonDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, LessonDeleteArgs<ExtArgs>>
    ): Prisma__LessonClient<$Types.GetResult<LessonPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Lesson.
     * @param {LessonUpdateArgs} args - Arguments to update one Lesson.
     * @example
     * // Update one Lesson
     * const lesson = await prisma.lesson.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LessonUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, LessonUpdateArgs<ExtArgs>>
    ): Prisma__LessonClient<$Types.GetResult<LessonPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Lessons.
     * @param {LessonDeleteManyArgs} args - Arguments to filter Lessons to delete.
     * @example
     * // Delete a few Lessons
     * const { count } = await prisma.lesson.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LessonDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LessonDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lessons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lessons
     * const lesson = await prisma.lesson.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LessonUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, LessonUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Lesson.
     * @param {LessonUpsertArgs} args - Arguments to update or create a Lesson.
     * @example
     * // Update or create a Lesson
     * const lesson = await prisma.lesson.upsert({
     *   create: {
     *     // ... data to create a Lesson
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lesson we want to update
     *   }
     * })
    **/
    upsert<T extends LessonUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, LessonUpsertArgs<ExtArgs>>
    ): Prisma__LessonClient<$Types.GetResult<LessonPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Lessons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonCountArgs} args - Arguments to filter Lessons to count.
     * @example
     * // Count the number of Lessons
     * const count = await prisma.lesson.count({
     *   where: {
     *     // ... the filter for the Lessons we want to count
     *   }
     * })
    **/
    count<T extends LessonCountArgs>(
      args?: Subset<T, LessonCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LessonCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lesson.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LessonAggregateArgs>(args: Subset<T, LessonAggregateArgs>): Prisma.PrismaPromise<GetLessonAggregateType<T>>

    /**
     * Group by Lesson.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LessonGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LessonGroupByArgs['orderBy'] }
        : { orderBy?: LessonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LessonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLessonGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Lesson.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LessonClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    creator<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    course<T extends CourseArgs<ExtArgs> = {}>(args?: Subset<T, CourseArgs<ExtArgs>>): Prisma__CourseClient<$Types.GetResult<CoursePayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    videos<T extends Lesson$videosArgs<ExtArgs> = {}>(args?: Subset<T, Lesson$videosArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<LessonVideoPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Lesson base type for findUnique actions
   */
  export type LessonFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lesson to fetch.
     */
    where: LessonWhereUniqueInput
  }

  /**
   * Lesson findUnique
   */
  export interface LessonFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends LessonFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Lesson findUniqueOrThrow
   */
  export type LessonFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lesson to fetch.
     */
    where: LessonWhereUniqueInput
  }


  /**
   * Lesson base type for findFirst actions
   */
  export type LessonFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lesson to fetch.
     */
    where?: LessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: Enumerable<LessonOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lessons.
     */
    cursor?: LessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lessons.
     */
    distinct?: Enumerable<LessonScalarFieldEnum>
  }

  /**
   * Lesson findFirst
   */
  export interface LessonFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends LessonFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Lesson findFirstOrThrow
   */
  export type LessonFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lesson to fetch.
     */
    where?: LessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: Enumerable<LessonOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lessons.
     */
    cursor?: LessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lessons.
     */
    distinct?: Enumerable<LessonScalarFieldEnum>
  }


  /**
   * Lesson findMany
   */
  export type LessonFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lessons to fetch.
     */
    where?: LessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: Enumerable<LessonOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Lessons.
     */
    cursor?: LessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    distinct?: Enumerable<LessonScalarFieldEnum>
  }


  /**
   * Lesson create
   */
  export type LessonCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * The data needed to create a Lesson.
     */
    data: XOR<LessonCreateInput, LessonUncheckedCreateInput>
  }


  /**
   * Lesson createMany
   */
  export type LessonCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Lessons.
     */
    data: Enumerable<LessonCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Lesson update
   */
  export type LessonUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * The data needed to update a Lesson.
     */
    data: XOR<LessonUpdateInput, LessonUncheckedUpdateInput>
    /**
     * Choose, which Lesson to update.
     */
    where: LessonWhereUniqueInput
  }


  /**
   * Lesson updateMany
   */
  export type LessonUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Lessons.
     */
    data: XOR<LessonUpdateManyMutationInput, LessonUncheckedUpdateManyInput>
    /**
     * Filter which Lessons to update
     */
    where?: LessonWhereInput
  }


  /**
   * Lesson upsert
   */
  export type LessonUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * The filter to search for the Lesson to update in case it exists.
     */
    where: LessonWhereUniqueInput
    /**
     * In case the Lesson found by the `where` argument doesn't exist, create a new Lesson with this data.
     */
    create: XOR<LessonCreateInput, LessonUncheckedCreateInput>
    /**
     * In case the Lesson was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LessonUpdateInput, LessonUncheckedUpdateInput>
  }


  /**
   * Lesson delete
   */
  export type LessonDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter which Lesson to delete.
     */
    where: LessonWhereUniqueInput
  }


  /**
   * Lesson deleteMany
   */
  export type LessonDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lessons to delete
     */
    where?: LessonWhereInput
  }


  /**
   * Lesson.videos
   */
  export type Lesson$videosArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonVideo
     */
    select?: LessonVideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LessonVideoInclude<ExtArgs> | null
    where?: LessonVideoWhereInput
    orderBy?: Enumerable<LessonVideoOrderByWithRelationInput>
    cursor?: LessonVideoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<LessonVideoScalarFieldEnum>
  }


  /**
   * Lesson without action
   */
  export type LessonArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LessonInclude<ExtArgs> | null
  }



  /**
   * Model LessonVideo
   */


  export type AggregateLessonVideo = {
    _count: LessonVideoCountAggregateOutputType | null
    _avg: LessonVideoAvgAggregateOutputType | null
    _sum: LessonVideoSumAggregateOutputType | null
    _min: LessonVideoMinAggregateOutputType | null
    _max: LessonVideoMaxAggregateOutputType | null
  }

  export type LessonVideoAvgAggregateOutputType = {
    numericId: number | null
    order: number | null
  }

  export type LessonVideoSumAggregateOutputType = {
    numericId: number | null
    order: number | null
  }

  export type LessonVideoMinAggregateOutputType = {
    id: string | null
    numericId: number | null
    lessonId: string | null
    order: number | null
    title: string | null
    video: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type LessonVideoMaxAggregateOutputType = {
    id: string | null
    numericId: number | null
    lessonId: string | null
    order: number | null
    title: string | null
    video: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type LessonVideoCountAggregateOutputType = {
    id: number
    numericId: number
    lessonId: number
    order: number
    title: number
    video: number
    isActive: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type LessonVideoAvgAggregateInputType = {
    numericId?: true
    order?: true
  }

  export type LessonVideoSumAggregateInputType = {
    numericId?: true
    order?: true
  }

  export type LessonVideoMinAggregateInputType = {
    id?: true
    numericId?: true
    lessonId?: true
    order?: true
    title?: true
    video?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type LessonVideoMaxAggregateInputType = {
    id?: true
    numericId?: true
    lessonId?: true
    order?: true
    title?: true
    video?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type LessonVideoCountAggregateInputType = {
    id?: true
    numericId?: true
    lessonId?: true
    order?: true
    title?: true
    video?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type LessonVideoAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which LessonVideo to aggregate.
     */
    where?: LessonVideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LessonVideos to fetch.
     */
    orderBy?: Enumerable<LessonVideoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LessonVideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LessonVideos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LessonVideos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LessonVideos
    **/
    _count?: true | LessonVideoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LessonVideoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LessonVideoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LessonVideoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LessonVideoMaxAggregateInputType
  }

  export type GetLessonVideoAggregateType<T extends LessonVideoAggregateArgs> = {
        [P in keyof T & keyof AggregateLessonVideo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLessonVideo[P]>
      : GetScalarType<T[P], AggregateLessonVideo[P]>
  }




  export type LessonVideoGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: LessonVideoWhereInput
    orderBy?: Enumerable<LessonVideoOrderByWithAggregationInput>
    by: LessonVideoScalarFieldEnum[]
    having?: LessonVideoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LessonVideoCountAggregateInputType | true
    _avg?: LessonVideoAvgAggregateInputType
    _sum?: LessonVideoSumAggregateInputType
    _min?: LessonVideoMinAggregateInputType
    _max?: LessonVideoMaxAggregateInputType
  }


  export type LessonVideoGroupByOutputType = {
    id: string
    numericId: number
    lessonId: string
    order: number
    title: string
    video: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: LessonVideoCountAggregateOutputType | null
    _avg: LessonVideoAvgAggregateOutputType | null
    _sum: LessonVideoSumAggregateOutputType | null
    _min: LessonVideoMinAggregateOutputType | null
    _max: LessonVideoMaxAggregateOutputType | null
  }

  type GetLessonVideoGroupByPayload<T extends LessonVideoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<LessonVideoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LessonVideoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LessonVideoGroupByOutputType[P]>
            : GetScalarType<T[P], LessonVideoGroupByOutputType[P]>
        }
      >
    >


  export type LessonVideoSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    numericId?: boolean
    lessonId?: boolean
    order?: boolean
    title?: boolean
    video?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    lesson?: boolean | LessonArgs<ExtArgs>
    watched?: boolean | LessonVideo$watchedArgs<ExtArgs>
    _count?: boolean | LessonVideoCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["lessonVideo"]>

  export type LessonVideoSelectScalar = {
    id?: boolean
    numericId?: boolean
    lessonId?: boolean
    order?: boolean
    title?: boolean
    video?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type LessonVideoInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    lesson?: boolean | LessonArgs<ExtArgs>
    watched?: boolean | LessonVideo$watchedArgs<ExtArgs>
    _count?: boolean | LessonVideoCountOutputTypeArgs<ExtArgs>
  }


  type LessonVideoGetPayload<S extends boolean | null | undefined | LessonVideoArgs> = $Types.GetResult<LessonVideoPayload, S>

  type LessonVideoCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<LessonVideoFindManyArgs, 'select' | 'include'> & {
      select?: LessonVideoCountAggregateInputType | true
    }

  export interface LessonVideoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LessonVideo'], meta: { name: 'LessonVideo' } }
    /**
     * Find zero or one LessonVideo that matches the filter.
     * @param {LessonVideoFindUniqueArgs} args - Arguments to find a LessonVideo
     * @example
     * // Get one LessonVideo
     * const lessonVideo = await prisma.lessonVideo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LessonVideoFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LessonVideoFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'LessonVideo'> extends True ? Prisma__LessonVideoClient<$Types.GetResult<LessonVideoPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__LessonVideoClient<$Types.GetResult<LessonVideoPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one LessonVideo that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LessonVideoFindUniqueOrThrowArgs} args - Arguments to find a LessonVideo
     * @example
     * // Get one LessonVideo
     * const lessonVideo = await prisma.lessonVideo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LessonVideoFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LessonVideoFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__LessonVideoClient<$Types.GetResult<LessonVideoPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first LessonVideo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonVideoFindFirstArgs} args - Arguments to find a LessonVideo
     * @example
     * // Get one LessonVideo
     * const lessonVideo = await prisma.lessonVideo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LessonVideoFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LessonVideoFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'LessonVideo'> extends True ? Prisma__LessonVideoClient<$Types.GetResult<LessonVideoPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__LessonVideoClient<$Types.GetResult<LessonVideoPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first LessonVideo that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonVideoFindFirstOrThrowArgs} args - Arguments to find a LessonVideo
     * @example
     * // Get one LessonVideo
     * const lessonVideo = await prisma.lessonVideo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LessonVideoFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LessonVideoFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__LessonVideoClient<$Types.GetResult<LessonVideoPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more LessonVideos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonVideoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LessonVideos
     * const lessonVideos = await prisma.lessonVideo.findMany()
     * 
     * // Get first 10 LessonVideos
     * const lessonVideos = await prisma.lessonVideo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lessonVideoWithIdOnly = await prisma.lessonVideo.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LessonVideoFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LessonVideoFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<LessonVideoPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a LessonVideo.
     * @param {LessonVideoCreateArgs} args - Arguments to create a LessonVideo.
     * @example
     * // Create one LessonVideo
     * const LessonVideo = await prisma.lessonVideo.create({
     *   data: {
     *     // ... data to create a LessonVideo
     *   }
     * })
     * 
    **/
    create<T extends LessonVideoCreateArgs<ExtArgs>>(
      args: SelectSubset<T, LessonVideoCreateArgs<ExtArgs>>
    ): Prisma__LessonVideoClient<$Types.GetResult<LessonVideoPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many LessonVideos.
     *     @param {LessonVideoCreateManyArgs} args - Arguments to create many LessonVideos.
     *     @example
     *     // Create many LessonVideos
     *     const lessonVideo = await prisma.lessonVideo.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LessonVideoCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LessonVideoCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LessonVideo.
     * @param {LessonVideoDeleteArgs} args - Arguments to delete one LessonVideo.
     * @example
     * // Delete one LessonVideo
     * const LessonVideo = await prisma.lessonVideo.delete({
     *   where: {
     *     // ... filter to delete one LessonVideo
     *   }
     * })
     * 
    **/
    delete<T extends LessonVideoDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, LessonVideoDeleteArgs<ExtArgs>>
    ): Prisma__LessonVideoClient<$Types.GetResult<LessonVideoPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one LessonVideo.
     * @param {LessonVideoUpdateArgs} args - Arguments to update one LessonVideo.
     * @example
     * // Update one LessonVideo
     * const lessonVideo = await prisma.lessonVideo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LessonVideoUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, LessonVideoUpdateArgs<ExtArgs>>
    ): Prisma__LessonVideoClient<$Types.GetResult<LessonVideoPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more LessonVideos.
     * @param {LessonVideoDeleteManyArgs} args - Arguments to filter LessonVideos to delete.
     * @example
     * // Delete a few LessonVideos
     * const { count } = await prisma.lessonVideo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LessonVideoDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LessonVideoDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LessonVideos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonVideoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LessonVideos
     * const lessonVideo = await prisma.lessonVideo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LessonVideoUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, LessonVideoUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LessonVideo.
     * @param {LessonVideoUpsertArgs} args - Arguments to update or create a LessonVideo.
     * @example
     * // Update or create a LessonVideo
     * const lessonVideo = await prisma.lessonVideo.upsert({
     *   create: {
     *     // ... data to create a LessonVideo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LessonVideo we want to update
     *   }
     * })
    **/
    upsert<T extends LessonVideoUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, LessonVideoUpsertArgs<ExtArgs>>
    ): Prisma__LessonVideoClient<$Types.GetResult<LessonVideoPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of LessonVideos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonVideoCountArgs} args - Arguments to filter LessonVideos to count.
     * @example
     * // Count the number of LessonVideos
     * const count = await prisma.lessonVideo.count({
     *   where: {
     *     // ... the filter for the LessonVideos we want to count
     *   }
     * })
    **/
    count<T extends LessonVideoCountArgs>(
      args?: Subset<T, LessonVideoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LessonVideoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LessonVideo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonVideoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LessonVideoAggregateArgs>(args: Subset<T, LessonVideoAggregateArgs>): Prisma.PrismaPromise<GetLessonVideoAggregateType<T>>

    /**
     * Group by LessonVideo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonVideoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LessonVideoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LessonVideoGroupByArgs['orderBy'] }
        : { orderBy?: LessonVideoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LessonVideoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLessonVideoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for LessonVideo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LessonVideoClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    lesson<T extends LessonArgs<ExtArgs> = {}>(args?: Subset<T, LessonArgs<ExtArgs>>): Prisma__LessonClient<$Types.GetResult<LessonPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    watched<T extends LessonVideo$watchedArgs<ExtArgs> = {}>(args?: Subset<T, LessonVideo$watchedArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<WatchedVideoPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * LessonVideo base type for findUnique actions
   */
  export type LessonVideoFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonVideo
     */
    select?: LessonVideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LessonVideoInclude<ExtArgs> | null
    /**
     * Filter, which LessonVideo to fetch.
     */
    where: LessonVideoWhereUniqueInput
  }

  /**
   * LessonVideo findUnique
   */
  export interface LessonVideoFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends LessonVideoFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LessonVideo findUniqueOrThrow
   */
  export type LessonVideoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonVideo
     */
    select?: LessonVideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LessonVideoInclude<ExtArgs> | null
    /**
     * Filter, which LessonVideo to fetch.
     */
    where: LessonVideoWhereUniqueInput
  }


  /**
   * LessonVideo base type for findFirst actions
   */
  export type LessonVideoFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonVideo
     */
    select?: LessonVideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LessonVideoInclude<ExtArgs> | null
    /**
     * Filter, which LessonVideo to fetch.
     */
    where?: LessonVideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LessonVideos to fetch.
     */
    orderBy?: Enumerable<LessonVideoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LessonVideos.
     */
    cursor?: LessonVideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LessonVideos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LessonVideos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LessonVideos.
     */
    distinct?: Enumerable<LessonVideoScalarFieldEnum>
  }

  /**
   * LessonVideo findFirst
   */
  export interface LessonVideoFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends LessonVideoFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * LessonVideo findFirstOrThrow
   */
  export type LessonVideoFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonVideo
     */
    select?: LessonVideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LessonVideoInclude<ExtArgs> | null
    /**
     * Filter, which LessonVideo to fetch.
     */
    where?: LessonVideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LessonVideos to fetch.
     */
    orderBy?: Enumerable<LessonVideoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LessonVideos.
     */
    cursor?: LessonVideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LessonVideos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LessonVideos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LessonVideos.
     */
    distinct?: Enumerable<LessonVideoScalarFieldEnum>
  }


  /**
   * LessonVideo findMany
   */
  export type LessonVideoFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonVideo
     */
    select?: LessonVideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LessonVideoInclude<ExtArgs> | null
    /**
     * Filter, which LessonVideos to fetch.
     */
    where?: LessonVideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LessonVideos to fetch.
     */
    orderBy?: Enumerable<LessonVideoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LessonVideos.
     */
    cursor?: LessonVideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LessonVideos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LessonVideos.
     */
    skip?: number
    distinct?: Enumerable<LessonVideoScalarFieldEnum>
  }


  /**
   * LessonVideo create
   */
  export type LessonVideoCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonVideo
     */
    select?: LessonVideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LessonVideoInclude<ExtArgs> | null
    /**
     * The data needed to create a LessonVideo.
     */
    data: XOR<LessonVideoCreateInput, LessonVideoUncheckedCreateInput>
  }


  /**
   * LessonVideo createMany
   */
  export type LessonVideoCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LessonVideos.
     */
    data: Enumerable<LessonVideoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * LessonVideo update
   */
  export type LessonVideoUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonVideo
     */
    select?: LessonVideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LessonVideoInclude<ExtArgs> | null
    /**
     * The data needed to update a LessonVideo.
     */
    data: XOR<LessonVideoUpdateInput, LessonVideoUncheckedUpdateInput>
    /**
     * Choose, which LessonVideo to update.
     */
    where: LessonVideoWhereUniqueInput
  }


  /**
   * LessonVideo updateMany
   */
  export type LessonVideoUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LessonVideos.
     */
    data: XOR<LessonVideoUpdateManyMutationInput, LessonVideoUncheckedUpdateManyInput>
    /**
     * Filter which LessonVideos to update
     */
    where?: LessonVideoWhereInput
  }


  /**
   * LessonVideo upsert
   */
  export type LessonVideoUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonVideo
     */
    select?: LessonVideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LessonVideoInclude<ExtArgs> | null
    /**
     * The filter to search for the LessonVideo to update in case it exists.
     */
    where: LessonVideoWhereUniqueInput
    /**
     * In case the LessonVideo found by the `where` argument doesn't exist, create a new LessonVideo with this data.
     */
    create: XOR<LessonVideoCreateInput, LessonVideoUncheckedCreateInput>
    /**
     * In case the LessonVideo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LessonVideoUpdateInput, LessonVideoUncheckedUpdateInput>
  }


  /**
   * LessonVideo delete
   */
  export type LessonVideoDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonVideo
     */
    select?: LessonVideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LessonVideoInclude<ExtArgs> | null
    /**
     * Filter which LessonVideo to delete.
     */
    where: LessonVideoWhereUniqueInput
  }


  /**
   * LessonVideo deleteMany
   */
  export type LessonVideoDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which LessonVideos to delete
     */
    where?: LessonVideoWhereInput
  }


  /**
   * LessonVideo.watched
   */
  export type LessonVideo$watchedArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchedVideo
     */
    select?: WatchedVideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WatchedVideoInclude<ExtArgs> | null
    where?: WatchedVideoWhereInput
    orderBy?: Enumerable<WatchedVideoOrderByWithRelationInput>
    cursor?: WatchedVideoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<WatchedVideoScalarFieldEnum>
  }


  /**
   * LessonVideo without action
   */
  export type LessonVideoArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonVideo
     */
    select?: LessonVideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LessonVideoInclude<ExtArgs> | null
  }



  /**
   * Model WatchedVideo
   */


  export type AggregateWatchedVideo = {
    _count: WatchedVideoCountAggregateOutputType | null
    _avg: WatchedVideoAvgAggregateOutputType | null
    _sum: WatchedVideoSumAggregateOutputType | null
    _min: WatchedVideoMinAggregateOutputType | null
    _max: WatchedVideoMaxAggregateOutputType | null
  }

  export type WatchedVideoAvgAggregateOutputType = {
    numericId: number | null
  }

  export type WatchedVideoSumAggregateOutputType = {
    numericId: number | null
  }

  export type WatchedVideoMinAggregateOutputType = {
    id: string | null
    numericId: number | null
    userId: string | null
    videoId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type WatchedVideoMaxAggregateOutputType = {
    id: string | null
    numericId: number | null
    userId: string | null
    videoId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type WatchedVideoCountAggregateOutputType = {
    id: number
    numericId: number
    userId: number
    videoId: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type WatchedVideoAvgAggregateInputType = {
    numericId?: true
  }

  export type WatchedVideoSumAggregateInputType = {
    numericId?: true
  }

  export type WatchedVideoMinAggregateInputType = {
    id?: true
    numericId?: true
    userId?: true
    videoId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type WatchedVideoMaxAggregateInputType = {
    id?: true
    numericId?: true
    userId?: true
    videoId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type WatchedVideoCountAggregateInputType = {
    id?: true
    numericId?: true
    userId?: true
    videoId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type WatchedVideoAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which WatchedVideo to aggregate.
     */
    where?: WatchedVideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WatchedVideos to fetch.
     */
    orderBy?: Enumerable<WatchedVideoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WatchedVideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WatchedVideos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WatchedVideos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WatchedVideos
    **/
    _count?: true | WatchedVideoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WatchedVideoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WatchedVideoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WatchedVideoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WatchedVideoMaxAggregateInputType
  }

  export type GetWatchedVideoAggregateType<T extends WatchedVideoAggregateArgs> = {
        [P in keyof T & keyof AggregateWatchedVideo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWatchedVideo[P]>
      : GetScalarType<T[P], AggregateWatchedVideo[P]>
  }




  export type WatchedVideoGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: WatchedVideoWhereInput
    orderBy?: Enumerable<WatchedVideoOrderByWithAggregationInput>
    by: WatchedVideoScalarFieldEnum[]
    having?: WatchedVideoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WatchedVideoCountAggregateInputType | true
    _avg?: WatchedVideoAvgAggregateInputType
    _sum?: WatchedVideoSumAggregateInputType
    _min?: WatchedVideoMinAggregateInputType
    _max?: WatchedVideoMaxAggregateInputType
  }


  export type WatchedVideoGroupByOutputType = {
    id: string
    numericId: number
    userId: string
    videoId: string
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: WatchedVideoCountAggregateOutputType | null
    _avg: WatchedVideoAvgAggregateOutputType | null
    _sum: WatchedVideoSumAggregateOutputType | null
    _min: WatchedVideoMinAggregateOutputType | null
    _max: WatchedVideoMaxAggregateOutputType | null
  }

  type GetWatchedVideoGroupByPayload<T extends WatchedVideoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<WatchedVideoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WatchedVideoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WatchedVideoGroupByOutputType[P]>
            : GetScalarType<T[P], WatchedVideoGroupByOutputType[P]>
        }
      >
    >


  export type WatchedVideoSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    numericId?: boolean
    userId?: boolean
    videoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserArgs<ExtArgs>
    video?: boolean | LessonVideoArgs<ExtArgs>
  }, ExtArgs["result"]["watchedVideo"]>

  export type WatchedVideoSelectScalar = {
    id?: boolean
    numericId?: boolean
    userId?: boolean
    videoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type WatchedVideoInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserArgs<ExtArgs>
    video?: boolean | LessonVideoArgs<ExtArgs>
  }


  type WatchedVideoGetPayload<S extends boolean | null | undefined | WatchedVideoArgs> = $Types.GetResult<WatchedVideoPayload, S>

  type WatchedVideoCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<WatchedVideoFindManyArgs, 'select' | 'include'> & {
      select?: WatchedVideoCountAggregateInputType | true
    }

  export interface WatchedVideoDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WatchedVideo'], meta: { name: 'WatchedVideo' } }
    /**
     * Find zero or one WatchedVideo that matches the filter.
     * @param {WatchedVideoFindUniqueArgs} args - Arguments to find a WatchedVideo
     * @example
     * // Get one WatchedVideo
     * const watchedVideo = await prisma.watchedVideo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WatchedVideoFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, WatchedVideoFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'WatchedVideo'> extends True ? Prisma__WatchedVideoClient<$Types.GetResult<WatchedVideoPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__WatchedVideoClient<$Types.GetResult<WatchedVideoPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one WatchedVideo that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {WatchedVideoFindUniqueOrThrowArgs} args - Arguments to find a WatchedVideo
     * @example
     * // Get one WatchedVideo
     * const watchedVideo = await prisma.watchedVideo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends WatchedVideoFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, WatchedVideoFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__WatchedVideoClient<$Types.GetResult<WatchedVideoPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first WatchedVideo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchedVideoFindFirstArgs} args - Arguments to find a WatchedVideo
     * @example
     * // Get one WatchedVideo
     * const watchedVideo = await prisma.watchedVideo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WatchedVideoFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, WatchedVideoFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'WatchedVideo'> extends True ? Prisma__WatchedVideoClient<$Types.GetResult<WatchedVideoPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__WatchedVideoClient<$Types.GetResult<WatchedVideoPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first WatchedVideo that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchedVideoFindFirstOrThrowArgs} args - Arguments to find a WatchedVideo
     * @example
     * // Get one WatchedVideo
     * const watchedVideo = await prisma.watchedVideo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends WatchedVideoFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, WatchedVideoFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__WatchedVideoClient<$Types.GetResult<WatchedVideoPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more WatchedVideos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchedVideoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WatchedVideos
     * const watchedVideos = await prisma.watchedVideo.findMany()
     * 
     * // Get first 10 WatchedVideos
     * const watchedVideos = await prisma.watchedVideo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const watchedVideoWithIdOnly = await prisma.watchedVideo.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends WatchedVideoFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WatchedVideoFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<WatchedVideoPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a WatchedVideo.
     * @param {WatchedVideoCreateArgs} args - Arguments to create a WatchedVideo.
     * @example
     * // Create one WatchedVideo
     * const WatchedVideo = await prisma.watchedVideo.create({
     *   data: {
     *     // ... data to create a WatchedVideo
     *   }
     * })
     * 
    **/
    create<T extends WatchedVideoCreateArgs<ExtArgs>>(
      args: SelectSubset<T, WatchedVideoCreateArgs<ExtArgs>>
    ): Prisma__WatchedVideoClient<$Types.GetResult<WatchedVideoPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many WatchedVideos.
     *     @param {WatchedVideoCreateManyArgs} args - Arguments to create many WatchedVideos.
     *     @example
     *     // Create many WatchedVideos
     *     const watchedVideo = await prisma.watchedVideo.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends WatchedVideoCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WatchedVideoCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WatchedVideo.
     * @param {WatchedVideoDeleteArgs} args - Arguments to delete one WatchedVideo.
     * @example
     * // Delete one WatchedVideo
     * const WatchedVideo = await prisma.watchedVideo.delete({
     *   where: {
     *     // ... filter to delete one WatchedVideo
     *   }
     * })
     * 
    **/
    delete<T extends WatchedVideoDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, WatchedVideoDeleteArgs<ExtArgs>>
    ): Prisma__WatchedVideoClient<$Types.GetResult<WatchedVideoPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one WatchedVideo.
     * @param {WatchedVideoUpdateArgs} args - Arguments to update one WatchedVideo.
     * @example
     * // Update one WatchedVideo
     * const watchedVideo = await prisma.watchedVideo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WatchedVideoUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, WatchedVideoUpdateArgs<ExtArgs>>
    ): Prisma__WatchedVideoClient<$Types.GetResult<WatchedVideoPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more WatchedVideos.
     * @param {WatchedVideoDeleteManyArgs} args - Arguments to filter WatchedVideos to delete.
     * @example
     * // Delete a few WatchedVideos
     * const { count } = await prisma.watchedVideo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WatchedVideoDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WatchedVideoDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WatchedVideos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchedVideoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WatchedVideos
     * const watchedVideo = await prisma.watchedVideo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WatchedVideoUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, WatchedVideoUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WatchedVideo.
     * @param {WatchedVideoUpsertArgs} args - Arguments to update or create a WatchedVideo.
     * @example
     * // Update or create a WatchedVideo
     * const watchedVideo = await prisma.watchedVideo.upsert({
     *   create: {
     *     // ... data to create a WatchedVideo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WatchedVideo we want to update
     *   }
     * })
    **/
    upsert<T extends WatchedVideoUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, WatchedVideoUpsertArgs<ExtArgs>>
    ): Prisma__WatchedVideoClient<$Types.GetResult<WatchedVideoPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of WatchedVideos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchedVideoCountArgs} args - Arguments to filter WatchedVideos to count.
     * @example
     * // Count the number of WatchedVideos
     * const count = await prisma.watchedVideo.count({
     *   where: {
     *     // ... the filter for the WatchedVideos we want to count
     *   }
     * })
    **/
    count<T extends WatchedVideoCountArgs>(
      args?: Subset<T, WatchedVideoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WatchedVideoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WatchedVideo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchedVideoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WatchedVideoAggregateArgs>(args: Subset<T, WatchedVideoAggregateArgs>): Prisma.PrismaPromise<GetWatchedVideoAggregateType<T>>

    /**
     * Group by WatchedVideo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WatchedVideoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WatchedVideoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WatchedVideoGroupByArgs['orderBy'] }
        : { orderBy?: WatchedVideoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WatchedVideoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWatchedVideoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for WatchedVideo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__WatchedVideoClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    video<T extends LessonVideoArgs<ExtArgs> = {}>(args?: Subset<T, LessonVideoArgs<ExtArgs>>): Prisma__LessonVideoClient<$Types.GetResult<LessonVideoPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * WatchedVideo base type for findUnique actions
   */
  export type WatchedVideoFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchedVideo
     */
    select?: WatchedVideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WatchedVideoInclude<ExtArgs> | null
    /**
     * Filter, which WatchedVideo to fetch.
     */
    where: WatchedVideoWhereUniqueInput
  }

  /**
   * WatchedVideo findUnique
   */
  export interface WatchedVideoFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends WatchedVideoFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * WatchedVideo findUniqueOrThrow
   */
  export type WatchedVideoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchedVideo
     */
    select?: WatchedVideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WatchedVideoInclude<ExtArgs> | null
    /**
     * Filter, which WatchedVideo to fetch.
     */
    where: WatchedVideoWhereUniqueInput
  }


  /**
   * WatchedVideo base type for findFirst actions
   */
  export type WatchedVideoFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchedVideo
     */
    select?: WatchedVideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WatchedVideoInclude<ExtArgs> | null
    /**
     * Filter, which WatchedVideo to fetch.
     */
    where?: WatchedVideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WatchedVideos to fetch.
     */
    orderBy?: Enumerable<WatchedVideoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WatchedVideos.
     */
    cursor?: WatchedVideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WatchedVideos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WatchedVideos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WatchedVideos.
     */
    distinct?: Enumerable<WatchedVideoScalarFieldEnum>
  }

  /**
   * WatchedVideo findFirst
   */
  export interface WatchedVideoFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends WatchedVideoFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * WatchedVideo findFirstOrThrow
   */
  export type WatchedVideoFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchedVideo
     */
    select?: WatchedVideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WatchedVideoInclude<ExtArgs> | null
    /**
     * Filter, which WatchedVideo to fetch.
     */
    where?: WatchedVideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WatchedVideos to fetch.
     */
    orderBy?: Enumerable<WatchedVideoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WatchedVideos.
     */
    cursor?: WatchedVideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WatchedVideos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WatchedVideos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WatchedVideos.
     */
    distinct?: Enumerable<WatchedVideoScalarFieldEnum>
  }


  /**
   * WatchedVideo findMany
   */
  export type WatchedVideoFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchedVideo
     */
    select?: WatchedVideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WatchedVideoInclude<ExtArgs> | null
    /**
     * Filter, which WatchedVideos to fetch.
     */
    where?: WatchedVideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WatchedVideos to fetch.
     */
    orderBy?: Enumerable<WatchedVideoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WatchedVideos.
     */
    cursor?: WatchedVideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WatchedVideos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WatchedVideos.
     */
    skip?: number
    distinct?: Enumerable<WatchedVideoScalarFieldEnum>
  }


  /**
   * WatchedVideo create
   */
  export type WatchedVideoCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchedVideo
     */
    select?: WatchedVideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WatchedVideoInclude<ExtArgs> | null
    /**
     * The data needed to create a WatchedVideo.
     */
    data: XOR<WatchedVideoCreateInput, WatchedVideoUncheckedCreateInput>
  }


  /**
   * WatchedVideo createMany
   */
  export type WatchedVideoCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WatchedVideos.
     */
    data: Enumerable<WatchedVideoCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * WatchedVideo update
   */
  export type WatchedVideoUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchedVideo
     */
    select?: WatchedVideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WatchedVideoInclude<ExtArgs> | null
    /**
     * The data needed to update a WatchedVideo.
     */
    data: XOR<WatchedVideoUpdateInput, WatchedVideoUncheckedUpdateInput>
    /**
     * Choose, which WatchedVideo to update.
     */
    where: WatchedVideoWhereUniqueInput
  }


  /**
   * WatchedVideo updateMany
   */
  export type WatchedVideoUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WatchedVideos.
     */
    data: XOR<WatchedVideoUpdateManyMutationInput, WatchedVideoUncheckedUpdateManyInput>
    /**
     * Filter which WatchedVideos to update
     */
    where?: WatchedVideoWhereInput
  }


  /**
   * WatchedVideo upsert
   */
  export type WatchedVideoUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchedVideo
     */
    select?: WatchedVideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WatchedVideoInclude<ExtArgs> | null
    /**
     * The filter to search for the WatchedVideo to update in case it exists.
     */
    where: WatchedVideoWhereUniqueInput
    /**
     * In case the WatchedVideo found by the `where` argument doesn't exist, create a new WatchedVideo with this data.
     */
    create: XOR<WatchedVideoCreateInput, WatchedVideoUncheckedCreateInput>
    /**
     * In case the WatchedVideo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WatchedVideoUpdateInput, WatchedVideoUncheckedUpdateInput>
  }


  /**
   * WatchedVideo delete
   */
  export type WatchedVideoDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchedVideo
     */
    select?: WatchedVideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WatchedVideoInclude<ExtArgs> | null
    /**
     * Filter which WatchedVideo to delete.
     */
    where: WatchedVideoWhereUniqueInput
  }


  /**
   * WatchedVideo deleteMany
   */
  export type WatchedVideoDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which WatchedVideos to delete
     */
    where?: WatchedVideoWhereInput
  }


  /**
   * WatchedVideo without action
   */
  export type WatchedVideoArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WatchedVideo
     */
    select?: WatchedVideoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WatchedVideoInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const AnamnesisScalarFieldEnum: {
    id: 'id',
    numericId: 'numericId',
    patientId: 'patientId',
    doctorId: 'doctorId',
    specialtyId: 'specialtyId',
    questions: 'questions',
    title: 'title',
    text: 'text',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type AnamnesisScalarFieldEnum = (typeof AnamnesisScalarFieldEnum)[keyof typeof AnamnesisScalarFieldEnum]


  export const AppointmentScalarFieldEnum: {
    id: 'id',
    numericId: 'numericId',
    doctorId: 'doctorId',
    patientId: 'patientId',
    when: 'when',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt',
    status: 'status'
  };

  export type AppointmentScalarFieldEnum = (typeof AppointmentScalarFieldEnum)[keyof typeof AppointmentScalarFieldEnum]


  export const CourseScalarFieldEnum: {
    id: 'id',
    numericId: 'numericId',
    creatorId: 'creatorId',
    specialtyId: 'specialtyId',
    order: 'order',
    title: 'title',
    cover: 'cover',
    description: 'description',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type CourseScalarFieldEnum = (typeof CourseScalarFieldEnum)[keyof typeof CourseScalarFieldEnum]


  export const DoctorPatientScalarFieldEnum: {
    doctorId: 'doctorId',
    patientId: 'patientId',
    assignedById: 'assignedById',
    createdAt: 'createdAt',
    active: 'active'
  };

  export type DoctorPatientScalarFieldEnum = (typeof DoctorPatientScalarFieldEnum)[keyof typeof DoctorPatientScalarFieldEnum]


  export const DoctorScalarFieldEnum: {
    id: 'id',
    numericId: 'numericId',
    userId: 'userId',
    specialtyId: 'specialtyId',
    crfa: 'crfa',
    availability: 'availability',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type DoctorScalarFieldEnum = (typeof DoctorScalarFieldEnum)[keyof typeof DoctorScalarFieldEnum]


  export const EvaluationScalarFieldEnum: {
    id: 'id',
    numericId: 'numericId',
    patientId: 'patientId',
    doctorId: 'doctorId',
    specialtyId: 'specialtyId',
    text: 'text',
    title: 'title',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type EvaluationScalarFieldEnum = (typeof EvaluationScalarFieldEnum)[keyof typeof EvaluationScalarFieldEnum]


  export const EvolutionScalarFieldEnum: {
    id: 'id',
    numericId: 'numericId',
    patientId: 'patientId',
    doctorId: 'doctorId',
    specialtyId: 'specialtyId',
    exercises: 'exercises',
    text: 'text',
    title: 'title',
    appointmentDate: 'appointmentDate',
    comments: 'comments',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type EvolutionScalarFieldEnum = (typeof EvolutionScalarFieldEnum)[keyof typeof EvolutionScalarFieldEnum]


  export const ExerciseScalarFieldEnum: {
    id: 'id',
    numericId: 'numericId',
    title: 'title',
    description: 'description',
    links: 'links',
    creatorId: 'creatorId',
    specialtyId: 'specialtyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExerciseScalarFieldEnum = (typeof ExerciseScalarFieldEnum)[keyof typeof ExerciseScalarFieldEnum]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const LessonScalarFieldEnum: {
    id: 'id',
    numericId: 'numericId',
    creatorId: 'creatorId',
    courseId: 'courseId',
    order: 'order',
    title: 'title',
    description: 'description',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type LessonScalarFieldEnum = (typeof LessonScalarFieldEnum)[keyof typeof LessonScalarFieldEnum]


  export const LessonVideoScalarFieldEnum: {
    id: 'id',
    numericId: 'numericId',
    lessonId: 'lessonId',
    order: 'order',
    title: 'title',
    video: 'video',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type LessonVideoScalarFieldEnum = (typeof LessonVideoScalarFieldEnum)[keyof typeof LessonVideoScalarFieldEnum]


  export const PatientScalarFieldEnum: {
    id: 'id',
    numericId: 'numericId',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type PatientScalarFieldEnum = (typeof PatientScalarFieldEnum)[keyof typeof PatientScalarFieldEnum]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const SpecialtyScalarFieldEnum: {
    id: 'id',
    numericId: 'numericId',
    name: 'name',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SpecialtyScalarFieldEnum = (typeof SpecialtyScalarFieldEnum)[keyof typeof SpecialtyScalarFieldEnum]


  export const TemplateScalarFieldEnum: {
    id: 'id',
    numericId: 'numericId',
    doctorId: 'doctorId',
    type: 'type',
    specialtyId: 'specialtyId',
    title: 'title',
    html: 'html',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type TemplateScalarFieldEnum = (typeof TemplateScalarFieldEnum)[keyof typeof TemplateScalarFieldEnum]


  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserAdressScalarFieldEnum: {
    id: 'id',
    numericId: 'numericId',
    userId: 'userId',
    streetName: 'streetName',
    zipCode: 'zipCode',
    district: 'district',
    state: 'state',
    city: 'city',
    number: 'number',
    complement: 'complement',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type UserAdressScalarFieldEnum = (typeof UserAdressScalarFieldEnum)[keyof typeof UserAdressScalarFieldEnum]


  export const UserContactScalarFieldEnum: {
    id: 'id',
    numericId: 'numericId',
    userId: 'userId',
    email: 'email',
    area: 'area',
    phone: 'phone',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type UserContactScalarFieldEnum = (typeof UserContactScalarFieldEnum)[keyof typeof UserContactScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    numericId: 'numericId',
    socialName: 'socialName',
    email: 'email',
    name: 'name',
    gender: 'gender',
    customGender: 'customGender',
    cpf: 'cpf',
    birthDate: 'birthDate',
    password: 'password',
    type: 'type',
    avatar: 'avatar',
    facebookToken: 'facebookToken',
    passwordResetToken: 'passwordResetToken',
    passwordResetExpires: 'passwordResetExpires',
    isAdmin: 'isAdmin',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const WatchedVideoScalarFieldEnum: {
    id: 'id',
    numericId: 'numericId',
    userId: 'userId',
    videoId: 'videoId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type WatchedVideoScalarFieldEnum = (typeof WatchedVideoScalarFieldEnum)[keyof typeof WatchedVideoScalarFieldEnum]


  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    id?: UuidFilter | string
    numericId?: IntFilter | number
    socialName?: StringNullableFilter | string | null
    email?: StringFilter | string
    name?: StringFilter | string
    gender?: StringNullableFilter | string | null
    customGender?: StringNullableFilter | string | null
    cpf?: StringNullableFilter | string | null
    birthDate?: DateTimeNullableFilter | Date | string | null
    password?: StringFilter | string
    type?: EnumUserTypeFilter | UserType
    avatar?: StringNullableFilter | string | null
    facebookToken?: StringNullableFilter | string | null
    passwordResetToken?: StringNullableFilter | string | null
    passwordResetExpires?: DateTimeNullableFilter | Date | string | null
    isAdmin?: BoolFilter | boolean
    isActive?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
    patientData?: XOR<PatientRelationFilter, PatientWhereInput> | null
    doctorData?: XOR<DoctorRelationFilter, DoctorWhereInput> | null
    addresses?: UserAdressListRelationFilter
    contacts?: UserContactListRelationFilter
    DoctorPatient?: DoctorPatientListRelationFilter
    exercises?: ExerciseListRelationFilter
    courses?: CourseListRelationFilter
    lessons?: LessonListRelationFilter
    watched?: WatchedVideoListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    numericId?: SortOrder
    socialName?: SortOrder
    email?: SortOrder
    name?: SortOrder
    gender?: SortOrder
    customGender?: SortOrder
    cpf?: SortOrder
    birthDate?: SortOrder
    password?: SortOrder
    type?: SortOrder
    avatar?: SortOrder
    facebookToken?: SortOrder
    passwordResetToken?: SortOrder
    passwordResetExpires?: SortOrder
    isAdmin?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    patientData?: PatientOrderByWithRelationInput
    doctorData?: DoctorOrderByWithRelationInput
    addresses?: UserAdressOrderByRelationAggregateInput
    contacts?: UserContactOrderByRelationAggregateInput
    DoctorPatient?: DoctorPatientOrderByRelationAggregateInput
    exercises?: ExerciseOrderByRelationAggregateInput
    courses?: CourseOrderByRelationAggregateInput
    lessons?: LessonOrderByRelationAggregateInput
    watched?: WatchedVideoOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = {
    id?: string
  }

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    numericId?: SortOrder
    socialName?: SortOrder
    email?: SortOrder
    name?: SortOrder
    gender?: SortOrder
    customGender?: SortOrder
    cpf?: SortOrder
    birthDate?: SortOrder
    password?: SortOrder
    type?: SortOrder
    avatar?: SortOrder
    facebookToken?: SortOrder
    passwordResetToken?: SortOrder
    passwordResetExpires?: SortOrder
    isAdmin?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    id?: UuidWithAggregatesFilter | string
    numericId?: IntWithAggregatesFilter | number
    socialName?: StringNullableWithAggregatesFilter | string | null
    email?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    gender?: StringNullableWithAggregatesFilter | string | null
    customGender?: StringNullableWithAggregatesFilter | string | null
    cpf?: StringNullableWithAggregatesFilter | string | null
    birthDate?: DateTimeNullableWithAggregatesFilter | Date | string | null
    password?: StringWithAggregatesFilter | string
    type?: EnumUserTypeWithAggregatesFilter | UserType
    avatar?: StringNullableWithAggregatesFilter | string | null
    facebookToken?: StringNullableWithAggregatesFilter | string | null
    passwordResetToken?: StringNullableWithAggregatesFilter | string | null
    passwordResetExpires?: DateTimeNullableWithAggregatesFilter | Date | string | null
    isAdmin?: BoolWithAggregatesFilter | boolean
    isActive?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type UserAdressWhereInput = {
    AND?: Enumerable<UserAdressWhereInput>
    OR?: Enumerable<UserAdressWhereInput>
    NOT?: Enumerable<UserAdressWhereInput>
    id?: UuidFilter | string
    numericId?: IntFilter | number
    userId?: UuidFilter | string
    streetName?: StringFilter | string
    zipCode?: StringFilter | string
    district?: StringFilter | string
    state?: StringFilter | string
    city?: StringFilter | string
    number?: StringFilter | string
    complement?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserAdressOrderByWithRelationInput = {
    id?: SortOrder
    numericId?: SortOrder
    userId?: SortOrder
    streetName?: SortOrder
    zipCode?: SortOrder
    district?: SortOrder
    state?: SortOrder
    city?: SortOrder
    number?: SortOrder
    complement?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserAdressWhereUniqueInput = {
    id?: string
  }

  export type UserAdressOrderByWithAggregationInput = {
    id?: SortOrder
    numericId?: SortOrder
    userId?: SortOrder
    streetName?: SortOrder
    zipCode?: SortOrder
    district?: SortOrder
    state?: SortOrder
    city?: SortOrder
    number?: SortOrder
    complement?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    _count?: UserAdressCountOrderByAggregateInput
    _avg?: UserAdressAvgOrderByAggregateInput
    _max?: UserAdressMaxOrderByAggregateInput
    _min?: UserAdressMinOrderByAggregateInput
    _sum?: UserAdressSumOrderByAggregateInput
  }

  export type UserAdressScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserAdressScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserAdressScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserAdressScalarWhereWithAggregatesInput>
    id?: UuidWithAggregatesFilter | string
    numericId?: IntWithAggregatesFilter | number
    userId?: UuidWithAggregatesFilter | string
    streetName?: StringWithAggregatesFilter | string
    zipCode?: StringWithAggregatesFilter | string
    district?: StringWithAggregatesFilter | string
    state?: StringWithAggregatesFilter | string
    city?: StringWithAggregatesFilter | string
    number?: StringWithAggregatesFilter | string
    complement?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type UserContactWhereInput = {
    AND?: Enumerable<UserContactWhereInput>
    OR?: Enumerable<UserContactWhereInput>
    NOT?: Enumerable<UserContactWhereInput>
    id?: UuidFilter | string
    numericId?: IntFilter | number
    userId?: UuidFilter | string
    email?: StringNullableFilter | string | null
    area?: StringFilter | string
    phone?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserContactOrderByWithRelationInput = {
    id?: SortOrder
    numericId?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    area?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserContactWhereUniqueInput = {
    id?: string
  }

  export type UserContactOrderByWithAggregationInput = {
    id?: SortOrder
    numericId?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    area?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    _count?: UserContactCountOrderByAggregateInput
    _avg?: UserContactAvgOrderByAggregateInput
    _max?: UserContactMaxOrderByAggregateInput
    _min?: UserContactMinOrderByAggregateInput
    _sum?: UserContactSumOrderByAggregateInput
  }

  export type UserContactScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserContactScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserContactScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserContactScalarWhereWithAggregatesInput>
    id?: UuidWithAggregatesFilter | string
    numericId?: IntWithAggregatesFilter | number
    userId?: UuidWithAggregatesFilter | string
    email?: StringNullableWithAggregatesFilter | string | null
    area?: StringWithAggregatesFilter | string
    phone?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type PatientWhereInput = {
    AND?: Enumerable<PatientWhereInput>
    OR?: Enumerable<PatientWhereInput>
    NOT?: Enumerable<PatientWhereInput>
    id?: UuidFilter | string
    numericId?: IntFilter | number
    userId?: UuidFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    anamnesis?: AnamnesisListRelationFilter
    evaluations?: EvaluationListRelationFilter
    doctorPatient?: DoctorPatientListRelationFilter
    evolutions?: EvolutionListRelationFilter
    appointment?: AppointmentListRelationFilter
  }

  export type PatientOrderByWithRelationInput = {
    id?: SortOrder
    numericId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    anamnesis?: AnamnesisOrderByRelationAggregateInput
    evaluations?: EvaluationOrderByRelationAggregateInput
    doctorPatient?: DoctorPatientOrderByRelationAggregateInput
    evolutions?: EvolutionOrderByRelationAggregateInput
    appointment?: AppointmentOrderByRelationAggregateInput
  }

  export type PatientWhereUniqueInput = {
    id?: string
    userId?: string
  }

  export type PatientOrderByWithAggregationInput = {
    id?: SortOrder
    numericId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    _count?: PatientCountOrderByAggregateInput
    _avg?: PatientAvgOrderByAggregateInput
    _max?: PatientMaxOrderByAggregateInput
    _min?: PatientMinOrderByAggregateInput
    _sum?: PatientSumOrderByAggregateInput
  }

  export type PatientScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PatientScalarWhereWithAggregatesInput>
    OR?: Enumerable<PatientScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PatientScalarWhereWithAggregatesInput>
    id?: UuidWithAggregatesFilter | string
    numericId?: IntWithAggregatesFilter | number
    userId?: UuidWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type AppointmentWhereInput = {
    AND?: Enumerable<AppointmentWhereInput>
    OR?: Enumerable<AppointmentWhereInput>
    NOT?: Enumerable<AppointmentWhereInput>
    id?: UuidFilter | string
    numericId?: IntFilter | number
    doctorId?: UuidFilter | string
    patientId?: UuidFilter | string
    when?: DateTimeFilter | Date | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
    status?: EnumAppointmentStatusFilter | AppointmentStatus
    doctor?: XOR<DoctorRelationFilter, DoctorWhereInput>
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
  }

  export type AppointmentOrderByWithRelationInput = {
    id?: SortOrder
    numericId?: SortOrder
    doctorId?: SortOrder
    patientId?: SortOrder
    when?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    status?: SortOrder
    doctor?: DoctorOrderByWithRelationInput
    patient?: PatientOrderByWithRelationInput
  }

  export type AppointmentWhereUniqueInput = {
    id?: string
  }

  export type AppointmentOrderByWithAggregationInput = {
    id?: SortOrder
    numericId?: SortOrder
    doctorId?: SortOrder
    patientId?: SortOrder
    when?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    status?: SortOrder
    _count?: AppointmentCountOrderByAggregateInput
    _avg?: AppointmentAvgOrderByAggregateInput
    _max?: AppointmentMaxOrderByAggregateInput
    _min?: AppointmentMinOrderByAggregateInput
    _sum?: AppointmentSumOrderByAggregateInput
  }

  export type AppointmentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AppointmentScalarWhereWithAggregatesInput>
    OR?: Enumerable<AppointmentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AppointmentScalarWhereWithAggregatesInput>
    id?: UuidWithAggregatesFilter | string
    numericId?: IntWithAggregatesFilter | number
    doctorId?: UuidWithAggregatesFilter | string
    patientId?: UuidWithAggregatesFilter | string
    when?: DateTimeWithAggregatesFilter | Date | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    status?: EnumAppointmentStatusWithAggregatesFilter | AppointmentStatus
  }

  export type DoctorWhereInput = {
    AND?: Enumerable<DoctorWhereInput>
    OR?: Enumerable<DoctorWhereInput>
    NOT?: Enumerable<DoctorWhereInput>
    id?: UuidFilter | string
    numericId?: IntFilter | number
    userId?: UuidFilter | string
    specialtyId?: UuidFilter | string
    crfa?: StringNullableFilter | string | null
    availability?: JsonFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
    specialty?: XOR<SpecialtyRelationFilter, SpecialtyWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    anamnesis?: AnamnesisListRelationFilter
    evaluations?: EvaluationListRelationFilter
    doctorPatient?: DoctorPatientListRelationFilter
    templates?: TemplateListRelationFilter
    evolutions?: EvolutionListRelationFilter
    appointments?: AppointmentListRelationFilter
  }

  export type DoctorOrderByWithRelationInput = {
    id?: SortOrder
    numericId?: SortOrder
    userId?: SortOrder
    specialtyId?: SortOrder
    crfa?: SortOrder
    availability?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    specialty?: SpecialtyOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    anamnesis?: AnamnesisOrderByRelationAggregateInput
    evaluations?: EvaluationOrderByRelationAggregateInput
    doctorPatient?: DoctorPatientOrderByRelationAggregateInput
    templates?: TemplateOrderByRelationAggregateInput
    evolutions?: EvolutionOrderByRelationAggregateInput
    appointments?: AppointmentOrderByRelationAggregateInput
  }

  export type DoctorWhereUniqueInput = {
    id?: string
    userId?: string
  }

  export type DoctorOrderByWithAggregationInput = {
    id?: SortOrder
    numericId?: SortOrder
    userId?: SortOrder
    specialtyId?: SortOrder
    crfa?: SortOrder
    availability?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    _count?: DoctorCountOrderByAggregateInput
    _avg?: DoctorAvgOrderByAggregateInput
    _max?: DoctorMaxOrderByAggregateInput
    _min?: DoctorMinOrderByAggregateInput
    _sum?: DoctorSumOrderByAggregateInput
  }

  export type DoctorScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DoctorScalarWhereWithAggregatesInput>
    OR?: Enumerable<DoctorScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DoctorScalarWhereWithAggregatesInput>
    id?: UuidWithAggregatesFilter | string
    numericId?: IntWithAggregatesFilter | number
    userId?: UuidWithAggregatesFilter | string
    specialtyId?: UuidWithAggregatesFilter | string
    crfa?: StringNullableWithAggregatesFilter | string | null
    availability?: JsonWithAggregatesFilter
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type DoctorPatientWhereInput = {
    AND?: Enumerable<DoctorPatientWhereInput>
    OR?: Enumerable<DoctorPatientWhereInput>
    NOT?: Enumerable<DoctorPatientWhereInput>
    doctorId?: UuidFilter | string
    patientId?: UuidFilter | string
    assignedById?: UuidFilter | string
    createdAt?: DateTimeFilter | Date | string
    active?: BoolFilter | boolean
    doctor?: XOR<DoctorRelationFilter, DoctorWhereInput>
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
    assignedBy?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type DoctorPatientOrderByWithRelationInput = {
    doctorId?: SortOrder
    patientId?: SortOrder
    assignedById?: SortOrder
    createdAt?: SortOrder
    active?: SortOrder
    doctor?: DoctorOrderByWithRelationInput
    patient?: PatientOrderByWithRelationInput
    assignedBy?: UserOrderByWithRelationInput
  }

  export type DoctorPatientWhereUniqueInput = {
    doctorId_patientId?: DoctorPatientDoctorIdPatientIdCompoundUniqueInput
  }

  export type DoctorPatientOrderByWithAggregationInput = {
    doctorId?: SortOrder
    patientId?: SortOrder
    assignedById?: SortOrder
    createdAt?: SortOrder
    active?: SortOrder
    _count?: DoctorPatientCountOrderByAggregateInput
    _max?: DoctorPatientMaxOrderByAggregateInput
    _min?: DoctorPatientMinOrderByAggregateInput
  }

  export type DoctorPatientScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DoctorPatientScalarWhereWithAggregatesInput>
    OR?: Enumerable<DoctorPatientScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DoctorPatientScalarWhereWithAggregatesInput>
    doctorId?: UuidWithAggregatesFilter | string
    patientId?: UuidWithAggregatesFilter | string
    assignedById?: UuidWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    active?: BoolWithAggregatesFilter | boolean
  }

  export type SpecialtyWhereInput = {
    AND?: Enumerable<SpecialtyWhereInput>
    OR?: Enumerable<SpecialtyWhereInput>
    NOT?: Enumerable<SpecialtyWhereInput>
    id?: UuidFilter | string
    numericId?: IntFilter | number
    name?: StringFilter | string
    isActive?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    doctors?: DoctorListRelationFilter
    templates?: TemplateListRelationFilter
    evaluations?: EvaluationListRelationFilter
    anamnesis?: AnamnesisListRelationFilter
    evolution?: EvolutionListRelationFilter
    exercise?: ExerciseListRelationFilter
    course?: CourseListRelationFilter
  }

  export type SpecialtyOrderByWithRelationInput = {
    id?: SortOrder
    numericId?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    doctors?: DoctorOrderByRelationAggregateInput
    templates?: TemplateOrderByRelationAggregateInput
    evaluations?: EvaluationOrderByRelationAggregateInput
    anamnesis?: AnamnesisOrderByRelationAggregateInput
    evolution?: EvolutionOrderByRelationAggregateInput
    exercise?: ExerciseOrderByRelationAggregateInput
    course?: CourseOrderByRelationAggregateInput
  }

  export type SpecialtyWhereUniqueInput = {
    id?: string
  }

  export type SpecialtyOrderByWithAggregationInput = {
    id?: SortOrder
    numericId?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SpecialtyCountOrderByAggregateInput
    _avg?: SpecialtyAvgOrderByAggregateInput
    _max?: SpecialtyMaxOrderByAggregateInput
    _min?: SpecialtyMinOrderByAggregateInput
    _sum?: SpecialtySumOrderByAggregateInput
  }

  export type SpecialtyScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SpecialtyScalarWhereWithAggregatesInput>
    OR?: Enumerable<SpecialtyScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SpecialtyScalarWhereWithAggregatesInput>
    id?: UuidWithAggregatesFilter | string
    numericId?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    isActive?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type AnamnesisWhereInput = {
    AND?: Enumerable<AnamnesisWhereInput>
    OR?: Enumerable<AnamnesisWhereInput>
    NOT?: Enumerable<AnamnesisWhereInput>
    id?: UuidFilter | string
    numericId?: IntFilter | number
    patientId?: UuidFilter | string
    doctorId?: UuidFilter | string
    specialtyId?: UuidFilter | string
    questions?: JsonFilter
    title?: StringNullableFilter | string | null
    text?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
    doctor?: XOR<DoctorRelationFilter, DoctorWhereInput>
    specialty?: XOR<SpecialtyRelationFilter, SpecialtyWhereInput>
  }

  export type AnamnesisOrderByWithRelationInput = {
    id?: SortOrder
    numericId?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    specialtyId?: SortOrder
    questions?: SortOrder
    title?: SortOrder
    text?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    patient?: PatientOrderByWithRelationInput
    doctor?: DoctorOrderByWithRelationInput
    specialty?: SpecialtyOrderByWithRelationInput
  }

  export type AnamnesisWhereUniqueInput = {
    id?: string
  }

  export type AnamnesisOrderByWithAggregationInput = {
    id?: SortOrder
    numericId?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    specialtyId?: SortOrder
    questions?: SortOrder
    title?: SortOrder
    text?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    _count?: AnamnesisCountOrderByAggregateInput
    _avg?: AnamnesisAvgOrderByAggregateInput
    _max?: AnamnesisMaxOrderByAggregateInput
    _min?: AnamnesisMinOrderByAggregateInput
    _sum?: AnamnesisSumOrderByAggregateInput
  }

  export type AnamnesisScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AnamnesisScalarWhereWithAggregatesInput>
    OR?: Enumerable<AnamnesisScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AnamnesisScalarWhereWithAggregatesInput>
    id?: UuidWithAggregatesFilter | string
    numericId?: IntWithAggregatesFilter | number
    patientId?: UuidWithAggregatesFilter | string
    doctorId?: UuidWithAggregatesFilter | string
    specialtyId?: UuidWithAggregatesFilter | string
    questions?: JsonWithAggregatesFilter
    title?: StringNullableWithAggregatesFilter | string | null
    text?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type EvolutionWhereInput = {
    AND?: Enumerable<EvolutionWhereInput>
    OR?: Enumerable<EvolutionWhereInput>
    NOT?: Enumerable<EvolutionWhereInput>
    id?: UuidFilter | string
    numericId?: IntFilter | number
    patientId?: UuidFilter | string
    doctorId?: UuidFilter | string
    specialtyId?: UuidFilter | string
    exercises?: JsonFilter
    text?: StringNullableFilter | string | null
    title?: StringNullableFilter | string | null
    appointmentDate?: DateTimeFilter | Date | string
    comments?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
    doctor?: XOR<DoctorRelationFilter, DoctorWhereInput>
    specialty?: XOR<SpecialtyRelationFilter, SpecialtyWhereInput>
  }

  export type EvolutionOrderByWithRelationInput = {
    id?: SortOrder
    numericId?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    specialtyId?: SortOrder
    exercises?: SortOrder
    text?: SortOrder
    title?: SortOrder
    appointmentDate?: SortOrder
    comments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    patient?: PatientOrderByWithRelationInput
    doctor?: DoctorOrderByWithRelationInput
    specialty?: SpecialtyOrderByWithRelationInput
  }

  export type EvolutionWhereUniqueInput = {
    id?: string
  }

  export type EvolutionOrderByWithAggregationInput = {
    id?: SortOrder
    numericId?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    specialtyId?: SortOrder
    exercises?: SortOrder
    text?: SortOrder
    title?: SortOrder
    appointmentDate?: SortOrder
    comments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    _count?: EvolutionCountOrderByAggregateInput
    _avg?: EvolutionAvgOrderByAggregateInput
    _max?: EvolutionMaxOrderByAggregateInput
    _min?: EvolutionMinOrderByAggregateInput
    _sum?: EvolutionSumOrderByAggregateInput
  }

  export type EvolutionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<EvolutionScalarWhereWithAggregatesInput>
    OR?: Enumerable<EvolutionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<EvolutionScalarWhereWithAggregatesInput>
    id?: UuidWithAggregatesFilter | string
    numericId?: IntWithAggregatesFilter | number
    patientId?: UuidWithAggregatesFilter | string
    doctorId?: UuidWithAggregatesFilter | string
    specialtyId?: UuidWithAggregatesFilter | string
    exercises?: JsonWithAggregatesFilter
    text?: StringNullableWithAggregatesFilter | string | null
    title?: StringNullableWithAggregatesFilter | string | null
    appointmentDate?: DateTimeWithAggregatesFilter | Date | string
    comments?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type EvaluationWhereInput = {
    AND?: Enumerable<EvaluationWhereInput>
    OR?: Enumerable<EvaluationWhereInput>
    NOT?: Enumerable<EvaluationWhereInput>
    id?: UuidFilter | string
    numericId?: IntFilter | number
    patientId?: UuidFilter | string
    doctorId?: UuidFilter | string
    specialtyId?: UuidFilter | string
    text?: StringNullableFilter | string | null
    title?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
    doctor?: XOR<DoctorRelationFilter, DoctorWhereInput>
    specialty?: XOR<SpecialtyRelationFilter, SpecialtyWhereInput>
  }

  export type EvaluationOrderByWithRelationInput = {
    id?: SortOrder
    numericId?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    specialtyId?: SortOrder
    text?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    patient?: PatientOrderByWithRelationInput
    doctor?: DoctorOrderByWithRelationInput
    specialty?: SpecialtyOrderByWithRelationInput
  }

  export type EvaluationWhereUniqueInput = {
    id?: string
  }

  export type EvaluationOrderByWithAggregationInput = {
    id?: SortOrder
    numericId?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    specialtyId?: SortOrder
    text?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    _count?: EvaluationCountOrderByAggregateInput
    _avg?: EvaluationAvgOrderByAggregateInput
    _max?: EvaluationMaxOrderByAggregateInput
    _min?: EvaluationMinOrderByAggregateInput
    _sum?: EvaluationSumOrderByAggregateInput
  }

  export type EvaluationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<EvaluationScalarWhereWithAggregatesInput>
    OR?: Enumerable<EvaluationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<EvaluationScalarWhereWithAggregatesInput>
    id?: UuidWithAggregatesFilter | string
    numericId?: IntWithAggregatesFilter | number
    patientId?: UuidWithAggregatesFilter | string
    doctorId?: UuidWithAggregatesFilter | string
    specialtyId?: UuidWithAggregatesFilter | string
    text?: StringNullableWithAggregatesFilter | string | null
    title?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type ExerciseWhereInput = {
    AND?: Enumerable<ExerciseWhereInput>
    OR?: Enumerable<ExerciseWhereInput>
    NOT?: Enumerable<ExerciseWhereInput>
    id?: UuidFilter | string
    numericId?: IntFilter | number
    title?: StringFilter | string
    description?: StringFilter | string
    links?: JsonFilter
    creatorId?: UuidFilter | string
    specialtyId?: UuidFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    creator?: XOR<UserRelationFilter, UserWhereInput>
    specialty?: XOR<SpecialtyRelationFilter, SpecialtyWhereInput>
  }

  export type ExerciseOrderByWithRelationInput = {
    id?: SortOrder
    numericId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    links?: SortOrder
    creatorId?: SortOrder
    specialtyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creator?: UserOrderByWithRelationInput
    specialty?: SpecialtyOrderByWithRelationInput
  }

  export type ExerciseWhereUniqueInput = {
    id?: string
  }

  export type ExerciseOrderByWithAggregationInput = {
    id?: SortOrder
    numericId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    links?: SortOrder
    creatorId?: SortOrder
    specialtyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ExerciseCountOrderByAggregateInput
    _avg?: ExerciseAvgOrderByAggregateInput
    _max?: ExerciseMaxOrderByAggregateInput
    _min?: ExerciseMinOrderByAggregateInput
    _sum?: ExerciseSumOrderByAggregateInput
  }

  export type ExerciseScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ExerciseScalarWhereWithAggregatesInput>
    OR?: Enumerable<ExerciseScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ExerciseScalarWhereWithAggregatesInput>
    id?: UuidWithAggregatesFilter | string
    numericId?: IntWithAggregatesFilter | number
    title?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
    links?: JsonWithAggregatesFilter
    creatorId?: UuidWithAggregatesFilter | string
    specialtyId?: UuidWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type TemplateWhereInput = {
    AND?: Enumerable<TemplateWhereInput>
    OR?: Enumerable<TemplateWhereInput>
    NOT?: Enumerable<TemplateWhereInput>
    id?: UuidFilter | string
    numericId?: IntFilter | number
    doctorId?: UuidFilter | string
    type?: EnumTemplateTypeFilter | TemplateType
    specialtyId?: UuidFilter | string
    title?: StringFilter | string
    html?: StringFilter | string
    isActive?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
    doctor?: XOR<DoctorRelationFilter, DoctorWhereInput>
    specialty?: XOR<SpecialtyRelationFilter, SpecialtyWhereInput>
  }

  export type TemplateOrderByWithRelationInput = {
    id?: SortOrder
    numericId?: SortOrder
    doctorId?: SortOrder
    type?: SortOrder
    specialtyId?: SortOrder
    title?: SortOrder
    html?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    doctor?: DoctorOrderByWithRelationInput
    specialty?: SpecialtyOrderByWithRelationInput
  }

  export type TemplateWhereUniqueInput = {
    id?: string
  }

  export type TemplateOrderByWithAggregationInput = {
    id?: SortOrder
    numericId?: SortOrder
    doctorId?: SortOrder
    type?: SortOrder
    specialtyId?: SortOrder
    title?: SortOrder
    html?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    _count?: TemplateCountOrderByAggregateInput
    _avg?: TemplateAvgOrderByAggregateInput
    _max?: TemplateMaxOrderByAggregateInput
    _min?: TemplateMinOrderByAggregateInput
    _sum?: TemplateSumOrderByAggregateInput
  }

  export type TemplateScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TemplateScalarWhereWithAggregatesInput>
    OR?: Enumerable<TemplateScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TemplateScalarWhereWithAggregatesInput>
    id?: UuidWithAggregatesFilter | string
    numericId?: IntWithAggregatesFilter | number
    doctorId?: UuidWithAggregatesFilter | string
    type?: EnumTemplateTypeWithAggregatesFilter | TemplateType
    specialtyId?: UuidWithAggregatesFilter | string
    title?: StringWithAggregatesFilter | string
    html?: StringWithAggregatesFilter | string
    isActive?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type CourseWhereInput = {
    AND?: Enumerable<CourseWhereInput>
    OR?: Enumerable<CourseWhereInput>
    NOT?: Enumerable<CourseWhereInput>
    id?: UuidFilter | string
    numericId?: IntFilter | number
    creatorId?: UuidFilter | string
    specialtyId?: UuidFilter | string
    order?: IntFilter | number
    title?: StringFilter | string
    cover?: StringNullableFilter | string | null
    description?: StringFilter | string
    isActive?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
    creator?: XOR<UserRelationFilter, UserWhereInput>
    specialty?: XOR<SpecialtyRelationFilter, SpecialtyWhereInput>
    lessons?: LessonListRelationFilter
  }

  export type CourseOrderByWithRelationInput = {
    id?: SortOrder
    numericId?: SortOrder
    creatorId?: SortOrder
    specialtyId?: SortOrder
    order?: SortOrder
    title?: SortOrder
    cover?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    creator?: UserOrderByWithRelationInput
    specialty?: SpecialtyOrderByWithRelationInput
    lessons?: LessonOrderByRelationAggregateInput
  }

  export type CourseWhereUniqueInput = {
    id?: string
  }

  export type CourseOrderByWithAggregationInput = {
    id?: SortOrder
    numericId?: SortOrder
    creatorId?: SortOrder
    specialtyId?: SortOrder
    order?: SortOrder
    title?: SortOrder
    cover?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    _count?: CourseCountOrderByAggregateInput
    _avg?: CourseAvgOrderByAggregateInput
    _max?: CourseMaxOrderByAggregateInput
    _min?: CourseMinOrderByAggregateInput
    _sum?: CourseSumOrderByAggregateInput
  }

  export type CourseScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CourseScalarWhereWithAggregatesInput>
    OR?: Enumerable<CourseScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CourseScalarWhereWithAggregatesInput>
    id?: UuidWithAggregatesFilter | string
    numericId?: IntWithAggregatesFilter | number
    creatorId?: UuidWithAggregatesFilter | string
    specialtyId?: UuidWithAggregatesFilter | string
    order?: IntWithAggregatesFilter | number
    title?: StringWithAggregatesFilter | string
    cover?: StringNullableWithAggregatesFilter | string | null
    description?: StringWithAggregatesFilter | string
    isActive?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type LessonWhereInput = {
    AND?: Enumerable<LessonWhereInput>
    OR?: Enumerable<LessonWhereInput>
    NOT?: Enumerable<LessonWhereInput>
    id?: UuidFilter | string
    numericId?: IntFilter | number
    creatorId?: UuidFilter | string
    courseId?: UuidFilter | string
    order?: IntFilter | number
    title?: StringFilter | string
    description?: StringFilter | string
    isActive?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
    creator?: XOR<UserRelationFilter, UserWhereInput>
    course?: XOR<CourseRelationFilter, CourseWhereInput>
    videos?: LessonVideoListRelationFilter
  }

  export type LessonOrderByWithRelationInput = {
    id?: SortOrder
    numericId?: SortOrder
    creatorId?: SortOrder
    courseId?: SortOrder
    order?: SortOrder
    title?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    creator?: UserOrderByWithRelationInput
    course?: CourseOrderByWithRelationInput
    videos?: LessonVideoOrderByRelationAggregateInput
  }

  export type LessonWhereUniqueInput = {
    id?: string
  }

  export type LessonOrderByWithAggregationInput = {
    id?: SortOrder
    numericId?: SortOrder
    creatorId?: SortOrder
    courseId?: SortOrder
    order?: SortOrder
    title?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    _count?: LessonCountOrderByAggregateInput
    _avg?: LessonAvgOrderByAggregateInput
    _max?: LessonMaxOrderByAggregateInput
    _min?: LessonMinOrderByAggregateInput
    _sum?: LessonSumOrderByAggregateInput
  }

  export type LessonScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LessonScalarWhereWithAggregatesInput>
    OR?: Enumerable<LessonScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LessonScalarWhereWithAggregatesInput>
    id?: UuidWithAggregatesFilter | string
    numericId?: IntWithAggregatesFilter | number
    creatorId?: UuidWithAggregatesFilter | string
    courseId?: UuidWithAggregatesFilter | string
    order?: IntWithAggregatesFilter | number
    title?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
    isActive?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type LessonVideoWhereInput = {
    AND?: Enumerable<LessonVideoWhereInput>
    OR?: Enumerable<LessonVideoWhereInput>
    NOT?: Enumerable<LessonVideoWhereInput>
    id?: UuidFilter | string
    numericId?: IntFilter | number
    lessonId?: UuidFilter | string
    order?: IntFilter | number
    title?: StringFilter | string
    video?: StringFilter | string
    isActive?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
    lesson?: XOR<LessonRelationFilter, LessonWhereInput>
    watched?: WatchedVideoListRelationFilter
  }

  export type LessonVideoOrderByWithRelationInput = {
    id?: SortOrder
    numericId?: SortOrder
    lessonId?: SortOrder
    order?: SortOrder
    title?: SortOrder
    video?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    lesson?: LessonOrderByWithRelationInput
    watched?: WatchedVideoOrderByRelationAggregateInput
  }

  export type LessonVideoWhereUniqueInput = {
    id?: string
  }

  export type LessonVideoOrderByWithAggregationInput = {
    id?: SortOrder
    numericId?: SortOrder
    lessonId?: SortOrder
    order?: SortOrder
    title?: SortOrder
    video?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    _count?: LessonVideoCountOrderByAggregateInput
    _avg?: LessonVideoAvgOrderByAggregateInput
    _max?: LessonVideoMaxOrderByAggregateInput
    _min?: LessonVideoMinOrderByAggregateInput
    _sum?: LessonVideoSumOrderByAggregateInput
  }

  export type LessonVideoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LessonVideoScalarWhereWithAggregatesInput>
    OR?: Enumerable<LessonVideoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LessonVideoScalarWhereWithAggregatesInput>
    id?: UuidWithAggregatesFilter | string
    numericId?: IntWithAggregatesFilter | number
    lessonId?: UuidWithAggregatesFilter | string
    order?: IntWithAggregatesFilter | number
    title?: StringWithAggregatesFilter | string
    video?: StringWithAggregatesFilter | string
    isActive?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type WatchedVideoWhereInput = {
    AND?: Enumerable<WatchedVideoWhereInput>
    OR?: Enumerable<WatchedVideoWhereInput>
    NOT?: Enumerable<WatchedVideoWhereInput>
    id?: UuidFilter | string
    numericId?: IntFilter | number
    userId?: UuidFilter | string
    videoId?: UuidFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    video?: XOR<LessonVideoRelationFilter, LessonVideoWhereInput>
  }

  export type WatchedVideoOrderByWithRelationInput = {
    id?: SortOrder
    numericId?: SortOrder
    userId?: SortOrder
    videoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    video?: LessonVideoOrderByWithRelationInput
  }

  export type WatchedVideoWhereUniqueInput = {
    id?: string
  }

  export type WatchedVideoOrderByWithAggregationInput = {
    id?: SortOrder
    numericId?: SortOrder
    userId?: SortOrder
    videoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    _count?: WatchedVideoCountOrderByAggregateInput
    _avg?: WatchedVideoAvgOrderByAggregateInput
    _max?: WatchedVideoMaxOrderByAggregateInput
    _min?: WatchedVideoMinOrderByAggregateInput
    _sum?: WatchedVideoSumOrderByAggregateInput
  }

  export type WatchedVideoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<WatchedVideoScalarWhereWithAggregatesInput>
    OR?: Enumerable<WatchedVideoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<WatchedVideoScalarWhereWithAggregatesInput>
    id?: UuidWithAggregatesFilter | string
    numericId?: IntWithAggregatesFilter | number
    userId?: UuidWithAggregatesFilter | string
    videoId?: UuidWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type UserCreateInput = {
    id?: string
    numericId?: number
    socialName?: string | null
    email: string
    name: string
    gender?: string | null
    customGender?: string | null
    cpf?: string | null
    birthDate?: Date | string | null
    password: string
    type?: UserType
    avatar?: string | null
    facebookToken?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    isAdmin?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    patientData?: PatientCreateNestedOneWithoutUserInput
    doctorData?: DoctorCreateNestedOneWithoutUserInput
    addresses?: UserAdressCreateNestedManyWithoutUserInput
    contacts?: UserContactCreateNestedManyWithoutUserInput
    DoctorPatient?: DoctorPatientCreateNestedManyWithoutAssignedByInput
    exercises?: ExerciseCreateNestedManyWithoutCreatorInput
    courses?: CourseCreateNestedManyWithoutCreatorInput
    lessons?: LessonCreateNestedManyWithoutCreatorInput
    watched?: WatchedVideoCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    numericId?: number
    socialName?: string | null
    email: string
    name: string
    gender?: string | null
    customGender?: string | null
    cpf?: string | null
    birthDate?: Date | string | null
    password: string
    type?: UserType
    avatar?: string | null
    facebookToken?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    isAdmin?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    patientData?: PatientUncheckedCreateNestedOneWithoutUserInput
    doctorData?: DoctorUncheckedCreateNestedOneWithoutUserInput
    addresses?: UserAdressUncheckedCreateNestedManyWithoutUserInput
    contacts?: UserContactUncheckedCreateNestedManyWithoutUserInput
    DoctorPatient?: DoctorPatientUncheckedCreateNestedManyWithoutAssignedByInput
    exercises?: ExerciseUncheckedCreateNestedManyWithoutCreatorInput
    courses?: CourseUncheckedCreateNestedManyWithoutCreatorInput
    lessons?: LessonUncheckedCreateNestedManyWithoutCreatorInput
    watched?: WatchedVideoUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    socialName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    customGender?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    type?: EnumUserTypeFieldUpdateOperationsInput | UserType
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    facebookToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patientData?: PatientUpdateOneWithoutUserNestedInput
    doctorData?: DoctorUpdateOneWithoutUserNestedInput
    addresses?: UserAdressUpdateManyWithoutUserNestedInput
    contacts?: UserContactUpdateManyWithoutUserNestedInput
    DoctorPatient?: DoctorPatientUpdateManyWithoutAssignedByNestedInput
    exercises?: ExerciseUpdateManyWithoutCreatorNestedInput
    courses?: CourseUpdateManyWithoutCreatorNestedInput
    lessons?: LessonUpdateManyWithoutCreatorNestedInput
    watched?: WatchedVideoUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    socialName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    customGender?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    type?: EnumUserTypeFieldUpdateOperationsInput | UserType
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    facebookToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patientData?: PatientUncheckedUpdateOneWithoutUserNestedInput
    doctorData?: DoctorUncheckedUpdateOneWithoutUserNestedInput
    addresses?: UserAdressUncheckedUpdateManyWithoutUserNestedInput
    contacts?: UserContactUncheckedUpdateManyWithoutUserNestedInput
    DoctorPatient?: DoctorPatientUncheckedUpdateManyWithoutAssignedByNestedInput
    exercises?: ExerciseUncheckedUpdateManyWithoutCreatorNestedInput
    courses?: CourseUncheckedUpdateManyWithoutCreatorNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutCreatorNestedInput
    watched?: WatchedVideoUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    numericId?: number
    socialName?: string | null
    email: string
    name: string
    gender?: string | null
    customGender?: string | null
    cpf?: string | null
    birthDate?: Date | string | null
    password: string
    type?: UserType
    avatar?: string | null
    facebookToken?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    isAdmin?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    socialName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    customGender?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    type?: EnumUserTypeFieldUpdateOperationsInput | UserType
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    facebookToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    socialName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    customGender?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    type?: EnumUserTypeFieldUpdateOperationsInput | UserType
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    facebookToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserAdressCreateInput = {
    id?: string
    numericId?: number
    streetName: string
    zipCode: string
    district: string
    state: string
    city: string
    number: string
    complement?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutAddressesInput
  }

  export type UserAdressUncheckedCreateInput = {
    id?: string
    numericId?: number
    userId: string
    streetName: string
    zipCode: string
    district: string
    state: string
    city: string
    number: string
    complement?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type UserAdressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    streetName?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutAddressesNestedInput
  }

  export type UserAdressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    streetName?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserAdressCreateManyInput = {
    id?: string
    numericId?: number
    userId: string
    streetName: string
    zipCode: string
    district: string
    state: string
    city: string
    number: string
    complement?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type UserAdressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    streetName?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserAdressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    streetName?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserContactCreateInput = {
    id?: string
    numericId?: number
    email?: string | null
    area: string
    phone: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutContactsInput
  }

  export type UserContactUncheckedCreateInput = {
    id?: string
    numericId?: number
    userId: string
    email?: string | null
    area: string
    phone: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type UserContactUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    email?: NullableStringFieldUpdateOperationsInput | string | null
    area?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutContactsNestedInput
  }

  export type UserContactUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    area?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserContactCreateManyInput = {
    id?: string
    numericId?: number
    userId: string
    email?: string | null
    area: string
    phone: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type UserContactUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    email?: NullableStringFieldUpdateOperationsInput | string | null
    area?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserContactUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    area?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PatientCreateInput = {
    id?: string
    numericId?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutPatientDataInput
    anamnesis?: AnamnesisCreateNestedManyWithoutPatientInput
    evaluations?: EvaluationCreateNestedManyWithoutPatientInput
    doctorPatient?: DoctorPatientCreateNestedManyWithoutPatientInput
    evolutions?: EvolutionCreateNestedManyWithoutPatientInput
    appointment?: AppointmentCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateInput = {
    id?: string
    numericId?: number
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    anamnesis?: AnamnesisUncheckedCreateNestedManyWithoutPatientInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutPatientInput
    doctorPatient?: DoctorPatientUncheckedCreateNestedManyWithoutPatientInput
    evolutions?: EvolutionUncheckedCreateNestedManyWithoutPatientInput
    appointment?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutPatientDataNestedInput
    anamnesis?: AnamnesisUpdateManyWithoutPatientNestedInput
    evaluations?: EvaluationUpdateManyWithoutPatientNestedInput
    doctorPatient?: DoctorPatientUpdateManyWithoutPatientNestedInput
    evolutions?: EvolutionUpdateManyWithoutPatientNestedInput
    appointment?: AppointmentUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    anamnesis?: AnamnesisUncheckedUpdateManyWithoutPatientNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutPatientNestedInput
    doctorPatient?: DoctorPatientUncheckedUpdateManyWithoutPatientNestedInput
    evolutions?: EvolutionUncheckedUpdateManyWithoutPatientNestedInput
    appointment?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PatientCreateManyInput = {
    id?: string
    numericId?: number
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PatientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PatientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AppointmentCreateInput = {
    id?: string
    numericId?: number
    when: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    status?: AppointmentStatus
    doctor: DoctorCreateNestedOneWithoutAppointmentsInput
    patient: PatientCreateNestedOneWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateInput = {
    id?: string
    numericId?: number
    doctorId: string
    patientId: string
    when: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    status?: AppointmentStatus
  }

  export type AppointmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    when?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | AppointmentStatus
    doctor?: DoctorUpdateOneRequiredWithoutAppointmentsNestedInput
    patient?: PatientUpdateOneRequiredWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    doctorId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    when?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | AppointmentStatus
  }

  export type AppointmentCreateManyInput = {
    id?: string
    numericId?: number
    doctorId: string
    patientId: string
    when: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    status?: AppointmentStatus
  }

  export type AppointmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    when?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | AppointmentStatus
  }

  export type AppointmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    doctorId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    when?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | AppointmentStatus
  }

  export type DoctorCreateInput = {
    id?: string
    numericId?: number
    crfa?: string | null
    availability?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    specialty: SpecialtyCreateNestedOneWithoutDoctorsInput
    user: UserCreateNestedOneWithoutDoctorDataInput
    anamnesis?: AnamnesisCreateNestedManyWithoutDoctorInput
    evaluations?: EvaluationCreateNestedManyWithoutDoctorInput
    doctorPatient?: DoctorPatientCreateNestedManyWithoutDoctorInput
    templates?: TemplateCreateNestedManyWithoutDoctorInput
    evolutions?: EvolutionCreateNestedManyWithoutDoctorInput
    appointments?: AppointmentCreateNestedManyWithoutDoctorInput
  }

  export type DoctorUncheckedCreateInput = {
    id?: string
    numericId?: number
    userId: string
    specialtyId: string
    crfa?: string | null
    availability?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    anamnesis?: AnamnesisUncheckedCreateNestedManyWithoutDoctorInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutDoctorInput
    doctorPatient?: DoctorPatientUncheckedCreateNestedManyWithoutDoctorInput
    templates?: TemplateUncheckedCreateNestedManyWithoutDoctorInput
    evolutions?: EvolutionUncheckedCreateNestedManyWithoutDoctorInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
  }

  export type DoctorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    crfa?: NullableStringFieldUpdateOperationsInput | string | null
    availability?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    specialty?: SpecialtyUpdateOneRequiredWithoutDoctorsNestedInput
    user?: UserUpdateOneRequiredWithoutDoctorDataNestedInput
    anamnesis?: AnamnesisUpdateManyWithoutDoctorNestedInput
    evaluations?: EvaluationUpdateManyWithoutDoctorNestedInput
    doctorPatient?: DoctorPatientUpdateManyWithoutDoctorNestedInput
    templates?: TemplateUpdateManyWithoutDoctorNestedInput
    evolutions?: EvolutionUpdateManyWithoutDoctorNestedInput
    appointments?: AppointmentUpdateManyWithoutDoctorNestedInput
  }

  export type DoctorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    specialtyId?: StringFieldUpdateOperationsInput | string
    crfa?: NullableStringFieldUpdateOperationsInput | string | null
    availability?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    anamnesis?: AnamnesisUncheckedUpdateManyWithoutDoctorNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutDoctorNestedInput
    doctorPatient?: DoctorPatientUncheckedUpdateManyWithoutDoctorNestedInput
    templates?: TemplateUncheckedUpdateManyWithoutDoctorNestedInput
    evolutions?: EvolutionUncheckedUpdateManyWithoutDoctorNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
  }

  export type DoctorCreateManyInput = {
    id?: string
    numericId?: number
    userId: string
    specialtyId: string
    crfa?: string | null
    availability?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type DoctorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    crfa?: NullableStringFieldUpdateOperationsInput | string | null
    availability?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DoctorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    specialtyId?: StringFieldUpdateOperationsInput | string
    crfa?: NullableStringFieldUpdateOperationsInput | string | null
    availability?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DoctorPatientCreateInput = {
    createdAt?: Date | string
    active?: boolean
    doctor: DoctorCreateNestedOneWithoutDoctorPatientInput
    patient: PatientCreateNestedOneWithoutDoctorPatientInput
    assignedBy: UserCreateNestedOneWithoutDoctorPatientInput
  }

  export type DoctorPatientUncheckedCreateInput = {
    doctorId: string
    patientId: string
    assignedById: string
    createdAt?: Date | string
    active?: boolean
  }

  export type DoctorPatientUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    doctor?: DoctorUpdateOneRequiredWithoutDoctorPatientNestedInput
    patient?: PatientUpdateOneRequiredWithoutDoctorPatientNestedInput
    assignedBy?: UserUpdateOneRequiredWithoutDoctorPatientNestedInput
  }

  export type DoctorPatientUncheckedUpdateInput = {
    doctorId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    assignedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DoctorPatientCreateManyInput = {
    doctorId: string
    patientId: string
    assignedById: string
    createdAt?: Date | string
    active?: boolean
  }

  export type DoctorPatientUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DoctorPatientUncheckedUpdateManyInput = {
    doctorId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    assignedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SpecialtyCreateInput = {
    id?: string
    numericId?: number
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    doctors?: DoctorCreateNestedManyWithoutSpecialtyInput
    templates?: TemplateCreateNestedManyWithoutSpecialtyInput
    evaluations?: EvaluationCreateNestedManyWithoutSpecialtyInput
    anamnesis?: AnamnesisCreateNestedManyWithoutSpecialtyInput
    evolution?: EvolutionCreateNestedManyWithoutSpecialtyInput
    exercise?: ExerciseCreateNestedManyWithoutSpecialtyInput
    course?: CourseCreateNestedManyWithoutSpecialtyInput
  }

  export type SpecialtyUncheckedCreateInput = {
    id?: string
    numericId?: number
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    doctors?: DoctorUncheckedCreateNestedManyWithoutSpecialtyInput
    templates?: TemplateUncheckedCreateNestedManyWithoutSpecialtyInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutSpecialtyInput
    anamnesis?: AnamnesisUncheckedCreateNestedManyWithoutSpecialtyInput
    evolution?: EvolutionUncheckedCreateNestedManyWithoutSpecialtyInput
    exercise?: ExerciseUncheckedCreateNestedManyWithoutSpecialtyInput
    course?: CourseUncheckedCreateNestedManyWithoutSpecialtyInput
  }

  export type SpecialtyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctors?: DoctorUpdateManyWithoutSpecialtyNestedInput
    templates?: TemplateUpdateManyWithoutSpecialtyNestedInput
    evaluations?: EvaluationUpdateManyWithoutSpecialtyNestedInput
    anamnesis?: AnamnesisUpdateManyWithoutSpecialtyNestedInput
    evolution?: EvolutionUpdateManyWithoutSpecialtyNestedInput
    exercise?: ExerciseUpdateManyWithoutSpecialtyNestedInput
    course?: CourseUpdateManyWithoutSpecialtyNestedInput
  }

  export type SpecialtyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctors?: DoctorUncheckedUpdateManyWithoutSpecialtyNestedInput
    templates?: TemplateUncheckedUpdateManyWithoutSpecialtyNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutSpecialtyNestedInput
    anamnesis?: AnamnesisUncheckedUpdateManyWithoutSpecialtyNestedInput
    evolution?: EvolutionUncheckedUpdateManyWithoutSpecialtyNestedInput
    exercise?: ExerciseUncheckedUpdateManyWithoutSpecialtyNestedInput
    course?: CourseUncheckedUpdateManyWithoutSpecialtyNestedInput
  }

  export type SpecialtyCreateManyInput = {
    id?: string
    numericId?: number
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SpecialtyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpecialtyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnamnesisCreateInput = {
    id?: string
    numericId?: number
    questions?: JsonNullValueInput | InputJsonValue
    title?: string | null
    text?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    patient: PatientCreateNestedOneWithoutAnamnesisInput
    doctor: DoctorCreateNestedOneWithoutAnamnesisInput
    specialty: SpecialtyCreateNestedOneWithoutAnamnesisInput
  }

  export type AnamnesisUncheckedCreateInput = {
    id?: string
    numericId?: number
    patientId: string
    doctorId: string
    specialtyId: string
    questions?: JsonNullValueInput | InputJsonValue
    title?: string | null
    text?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AnamnesisUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    questions?: JsonNullValueInput | InputJsonValue
    title?: NullableStringFieldUpdateOperationsInput | string | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patient?: PatientUpdateOneRequiredWithoutAnamnesisNestedInput
    doctor?: DoctorUpdateOneRequiredWithoutAnamnesisNestedInput
    specialty?: SpecialtyUpdateOneRequiredWithoutAnamnesisNestedInput
  }

  export type AnamnesisUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    specialtyId?: StringFieldUpdateOperationsInput | string
    questions?: JsonNullValueInput | InputJsonValue
    title?: NullableStringFieldUpdateOperationsInput | string | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AnamnesisCreateManyInput = {
    id?: string
    numericId?: number
    patientId: string
    doctorId: string
    specialtyId: string
    questions?: JsonNullValueInput | InputJsonValue
    title?: string | null
    text?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AnamnesisUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    questions?: JsonNullValueInput | InputJsonValue
    title?: NullableStringFieldUpdateOperationsInput | string | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AnamnesisUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    specialtyId?: StringFieldUpdateOperationsInput | string
    questions?: JsonNullValueInput | InputJsonValue
    title?: NullableStringFieldUpdateOperationsInput | string | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EvolutionCreateInput = {
    id?: string
    numericId?: number
    exercises?: JsonNullValueInput | InputJsonValue
    text?: string | null
    title?: string | null
    appointmentDate?: Date | string
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    patient: PatientCreateNestedOneWithoutEvolutionsInput
    doctor: DoctorCreateNestedOneWithoutEvolutionsInput
    specialty: SpecialtyCreateNestedOneWithoutEvolutionInput
  }

  export type EvolutionUncheckedCreateInput = {
    id?: string
    numericId?: number
    patientId: string
    doctorId: string
    specialtyId: string
    exercises?: JsonNullValueInput | InputJsonValue
    text?: string | null
    title?: string | null
    appointmentDate?: Date | string
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type EvolutionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    exercises?: JsonNullValueInput | InputJsonValue
    text?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patient?: PatientUpdateOneRequiredWithoutEvolutionsNestedInput
    doctor?: DoctorUpdateOneRequiredWithoutEvolutionsNestedInput
    specialty?: SpecialtyUpdateOneRequiredWithoutEvolutionNestedInput
  }

  export type EvolutionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    specialtyId?: StringFieldUpdateOperationsInput | string
    exercises?: JsonNullValueInput | InputJsonValue
    text?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EvolutionCreateManyInput = {
    id?: string
    numericId?: number
    patientId: string
    doctorId: string
    specialtyId: string
    exercises?: JsonNullValueInput | InputJsonValue
    text?: string | null
    title?: string | null
    appointmentDate?: Date | string
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type EvolutionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    exercises?: JsonNullValueInput | InputJsonValue
    text?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EvolutionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    specialtyId?: StringFieldUpdateOperationsInput | string
    exercises?: JsonNullValueInput | InputJsonValue
    text?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EvaluationCreateInput = {
    id?: string
    numericId?: number
    text?: string | null
    title?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    patient: PatientCreateNestedOneWithoutEvaluationsInput
    doctor: DoctorCreateNestedOneWithoutEvaluationsInput
    specialty: SpecialtyCreateNestedOneWithoutEvaluationsInput
  }

  export type EvaluationUncheckedCreateInput = {
    id?: string
    numericId?: number
    patientId: string
    doctorId: string
    specialtyId: string
    text?: string | null
    title?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type EvaluationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    text?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patient?: PatientUpdateOneRequiredWithoutEvaluationsNestedInput
    doctor?: DoctorUpdateOneRequiredWithoutEvaluationsNestedInput
    specialty?: SpecialtyUpdateOneRequiredWithoutEvaluationsNestedInput
  }

  export type EvaluationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    specialtyId?: StringFieldUpdateOperationsInput | string
    text?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EvaluationCreateManyInput = {
    id?: string
    numericId?: number
    patientId: string
    doctorId: string
    specialtyId: string
    text?: string | null
    title?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type EvaluationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    text?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EvaluationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    specialtyId?: StringFieldUpdateOperationsInput | string
    text?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ExerciseCreateInput = {
    id?: string
    numericId?: number
    title: string
    description: string
    links?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutExercisesInput
    specialty: SpecialtyCreateNestedOneWithoutExerciseInput
  }

  export type ExerciseUncheckedCreateInput = {
    id?: string
    numericId?: number
    title: string
    description: string
    links?: JsonNullValueInput | InputJsonValue
    creatorId: string
    specialtyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExerciseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    links?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutExercisesNestedInput
    specialty?: SpecialtyUpdateOneRequiredWithoutExerciseNestedInput
  }

  export type ExerciseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    links?: JsonNullValueInput | InputJsonValue
    creatorId?: StringFieldUpdateOperationsInput | string
    specialtyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExerciseCreateManyInput = {
    id?: string
    numericId?: number
    title: string
    description: string
    links?: JsonNullValueInput | InputJsonValue
    creatorId: string
    specialtyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExerciseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    links?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExerciseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    links?: JsonNullValueInput | InputJsonValue
    creatorId?: StringFieldUpdateOperationsInput | string
    specialtyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateCreateInput = {
    id?: string
    numericId?: number
    type: TemplateType
    title: string
    html: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    doctor: DoctorCreateNestedOneWithoutTemplatesInput
    specialty: SpecialtyCreateNestedOneWithoutTemplatesInput
  }

  export type TemplateUncheckedCreateInput = {
    id?: string
    numericId?: number
    doctorId: string
    type: TemplateType
    specialtyId: string
    title: string
    html: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type TemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    type?: EnumTemplateTypeFieldUpdateOperationsInput | TemplateType
    title?: StringFieldUpdateOperationsInput | string
    html?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctor?: DoctorUpdateOneRequiredWithoutTemplatesNestedInput
    specialty?: SpecialtyUpdateOneRequiredWithoutTemplatesNestedInput
  }

  export type TemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    doctorId?: StringFieldUpdateOperationsInput | string
    type?: EnumTemplateTypeFieldUpdateOperationsInput | TemplateType
    specialtyId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    html?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TemplateCreateManyInput = {
    id?: string
    numericId?: number
    doctorId: string
    type: TemplateType
    specialtyId: string
    title: string
    html: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type TemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    type?: EnumTemplateTypeFieldUpdateOperationsInput | TemplateType
    title?: StringFieldUpdateOperationsInput | string
    html?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    doctorId?: StringFieldUpdateOperationsInput | string
    type?: EnumTemplateTypeFieldUpdateOperationsInput | TemplateType
    specialtyId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    html?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CourseCreateInput = {
    id?: string
    numericId?: number
    order?: number
    title: string
    cover?: string | null
    description: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    creator: UserCreateNestedOneWithoutCoursesInput
    specialty: SpecialtyCreateNestedOneWithoutCourseInput
    lessons?: LessonCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateInput = {
    id?: string
    numericId?: number
    creatorId: string
    specialtyId: string
    order?: number
    title: string
    cover?: string | null
    description: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    lessons?: LessonUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creator?: UserUpdateOneRequiredWithoutCoursesNestedInput
    specialty?: SpecialtyUpdateOneRequiredWithoutCourseNestedInput
    lessons?: LessonUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    creatorId?: StringFieldUpdateOperationsInput | string
    specialtyId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lessons?: LessonUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CourseCreateManyInput = {
    id?: string
    numericId?: number
    creatorId: string
    specialtyId: string
    order?: number
    title: string
    cover?: string | null
    description: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type CourseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CourseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    creatorId?: StringFieldUpdateOperationsInput | string
    specialtyId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LessonCreateInput = {
    id?: string
    numericId?: number
    order?: number
    title: string
    description: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    creator: UserCreateNestedOneWithoutLessonsInput
    course: CourseCreateNestedOneWithoutLessonsInput
    videos?: LessonVideoCreateNestedManyWithoutLessonInput
  }

  export type LessonUncheckedCreateInput = {
    id?: string
    numericId?: number
    creatorId: string
    courseId: string
    order?: number
    title: string
    description: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    videos?: LessonVideoUncheckedCreateNestedManyWithoutLessonInput
  }

  export type LessonUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creator?: UserUpdateOneRequiredWithoutLessonsNestedInput
    course?: CourseUpdateOneRequiredWithoutLessonsNestedInput
    videos?: LessonVideoUpdateManyWithoutLessonNestedInput
  }

  export type LessonUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    creatorId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    videos?: LessonVideoUncheckedUpdateManyWithoutLessonNestedInput
  }

  export type LessonCreateManyInput = {
    id?: string
    numericId?: number
    creatorId: string
    courseId: string
    order?: number
    title: string
    description: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type LessonUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LessonUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    creatorId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LessonVideoCreateInput = {
    id?: string
    numericId?: number
    order?: number
    title: string
    video: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    lesson: LessonCreateNestedOneWithoutVideosInput
    watched?: WatchedVideoCreateNestedManyWithoutVideoInput
  }

  export type LessonVideoUncheckedCreateInput = {
    id?: string
    numericId?: number
    lessonId: string
    order?: number
    title: string
    video: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    watched?: WatchedVideoUncheckedCreateNestedManyWithoutVideoInput
  }

  export type LessonVideoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    video?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lesson?: LessonUpdateOneRequiredWithoutVideosNestedInput
    watched?: WatchedVideoUpdateManyWithoutVideoNestedInput
  }

  export type LessonVideoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    lessonId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    video?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    watched?: WatchedVideoUncheckedUpdateManyWithoutVideoNestedInput
  }

  export type LessonVideoCreateManyInput = {
    id?: string
    numericId?: number
    lessonId: string
    order?: number
    title: string
    video: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type LessonVideoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    video?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LessonVideoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    lessonId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    video?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WatchedVideoCreateInput = {
    id?: string
    numericId?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutWatchedInput
    video: LessonVideoCreateNestedOneWithoutWatchedInput
  }

  export type WatchedVideoUncheckedCreateInput = {
    id?: string
    numericId?: number
    userId: string
    videoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type WatchedVideoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutWatchedNestedInput
    video?: LessonVideoUpdateOneRequiredWithoutWatchedNestedInput
  }

  export type WatchedVideoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    videoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WatchedVideoCreateManyInput = {
    id?: string
    numericId?: number
    userId: string
    videoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type WatchedVideoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WatchedVideoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    videoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UuidFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    mode?: QueryMode
    not?: NestedUuidFilter | string
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type EnumUserTypeFilter = {
    equals?: UserType
    in?: Enumerable<UserType>
    notIn?: Enumerable<UserType>
    not?: NestedEnumUserTypeFilter | UserType
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type PatientRelationFilter = {
    is?: PatientWhereInput
    isNot?: PatientWhereInput
  }

  export type DoctorRelationFilter = {
    is?: DoctorWhereInput
    isNot?: DoctorWhereInput
  }

  export type UserAdressListRelationFilter = {
    every?: UserAdressWhereInput
    some?: UserAdressWhereInput
    none?: UserAdressWhereInput
  }

  export type UserContactListRelationFilter = {
    every?: UserContactWhereInput
    some?: UserContactWhereInput
    none?: UserContactWhereInput
  }

  export type DoctorPatientListRelationFilter = {
    every?: DoctorPatientWhereInput
    some?: DoctorPatientWhereInput
    none?: DoctorPatientWhereInput
  }

  export type ExerciseListRelationFilter = {
    every?: ExerciseWhereInput
    some?: ExerciseWhereInput
    none?: ExerciseWhereInput
  }

  export type CourseListRelationFilter = {
    every?: CourseWhereInput
    some?: CourseWhereInput
    none?: CourseWhereInput
  }

  export type LessonListRelationFilter = {
    every?: LessonWhereInput
    some?: LessonWhereInput
    none?: LessonWhereInput
  }

  export type WatchedVideoListRelationFilter = {
    every?: WatchedVideoWhereInput
    some?: WatchedVideoWhereInput
    none?: WatchedVideoWhereInput
  }

  export type UserAdressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserContactOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DoctorPatientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExerciseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LessonOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WatchedVideoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    numericId?: SortOrder
    socialName?: SortOrder
    email?: SortOrder
    name?: SortOrder
    gender?: SortOrder
    customGender?: SortOrder
    cpf?: SortOrder
    birthDate?: SortOrder
    password?: SortOrder
    type?: SortOrder
    avatar?: SortOrder
    facebookToken?: SortOrder
    passwordResetToken?: SortOrder
    passwordResetExpires?: SortOrder
    isAdmin?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    numericId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    numericId?: SortOrder
    socialName?: SortOrder
    email?: SortOrder
    name?: SortOrder
    gender?: SortOrder
    customGender?: SortOrder
    cpf?: SortOrder
    birthDate?: SortOrder
    password?: SortOrder
    type?: SortOrder
    avatar?: SortOrder
    facebookToken?: SortOrder
    passwordResetToken?: SortOrder
    passwordResetExpires?: SortOrder
    isAdmin?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    numericId?: SortOrder
    socialName?: SortOrder
    email?: SortOrder
    name?: SortOrder
    gender?: SortOrder
    customGender?: SortOrder
    cpf?: SortOrder
    birthDate?: SortOrder
    password?: SortOrder
    type?: SortOrder
    avatar?: SortOrder
    facebookToken?: SortOrder
    passwordResetToken?: SortOrder
    passwordResetExpires?: SortOrder
    isAdmin?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    numericId?: SortOrder
  }

  export type UuidWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type EnumUserTypeWithAggregatesFilter = {
    equals?: UserType
    in?: Enumerable<UserType>
    notIn?: Enumerable<UserType>
    not?: NestedEnumUserTypeWithAggregatesFilter | UserType
    _count?: NestedIntFilter
    _min?: NestedEnumUserTypeFilter
    _max?: NestedEnumUserTypeFilter
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type UserAdressCountOrderByAggregateInput = {
    id?: SortOrder
    numericId?: SortOrder
    userId?: SortOrder
    streetName?: SortOrder
    zipCode?: SortOrder
    district?: SortOrder
    state?: SortOrder
    city?: SortOrder
    number?: SortOrder
    complement?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UserAdressAvgOrderByAggregateInput = {
    numericId?: SortOrder
  }

  export type UserAdressMaxOrderByAggregateInput = {
    id?: SortOrder
    numericId?: SortOrder
    userId?: SortOrder
    streetName?: SortOrder
    zipCode?: SortOrder
    district?: SortOrder
    state?: SortOrder
    city?: SortOrder
    number?: SortOrder
    complement?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UserAdressMinOrderByAggregateInput = {
    id?: SortOrder
    numericId?: SortOrder
    userId?: SortOrder
    streetName?: SortOrder
    zipCode?: SortOrder
    district?: SortOrder
    state?: SortOrder
    city?: SortOrder
    number?: SortOrder
    complement?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UserAdressSumOrderByAggregateInput = {
    numericId?: SortOrder
  }

  export type UserContactCountOrderByAggregateInput = {
    id?: SortOrder
    numericId?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    area?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UserContactAvgOrderByAggregateInput = {
    numericId?: SortOrder
  }

  export type UserContactMaxOrderByAggregateInput = {
    id?: SortOrder
    numericId?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    area?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UserContactMinOrderByAggregateInput = {
    id?: SortOrder
    numericId?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    area?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UserContactSumOrderByAggregateInput = {
    numericId?: SortOrder
  }

  export type AnamnesisListRelationFilter = {
    every?: AnamnesisWhereInput
    some?: AnamnesisWhereInput
    none?: AnamnesisWhereInput
  }

  export type EvaluationListRelationFilter = {
    every?: EvaluationWhereInput
    some?: EvaluationWhereInput
    none?: EvaluationWhereInput
  }

  export type EvolutionListRelationFilter = {
    every?: EvolutionWhereInput
    some?: EvolutionWhereInput
    none?: EvolutionWhereInput
  }

  export type AppointmentListRelationFilter = {
    every?: AppointmentWhereInput
    some?: AppointmentWhereInput
    none?: AppointmentWhereInput
  }

  export type AnamnesisOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EvaluationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EvolutionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AppointmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PatientCountOrderByAggregateInput = {
    id?: SortOrder
    numericId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type PatientAvgOrderByAggregateInput = {
    numericId?: SortOrder
  }

  export type PatientMaxOrderByAggregateInput = {
    id?: SortOrder
    numericId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type PatientMinOrderByAggregateInput = {
    id?: SortOrder
    numericId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type PatientSumOrderByAggregateInput = {
    numericId?: SortOrder
  }

  export type EnumAppointmentStatusFilter = {
    equals?: AppointmentStatus
    in?: Enumerable<AppointmentStatus>
    notIn?: Enumerable<AppointmentStatus>
    not?: NestedEnumAppointmentStatusFilter | AppointmentStatus
  }

  export type AppointmentCountOrderByAggregateInput = {
    id?: SortOrder
    numericId?: SortOrder
    doctorId?: SortOrder
    patientId?: SortOrder
    when?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    status?: SortOrder
  }

  export type AppointmentAvgOrderByAggregateInput = {
    numericId?: SortOrder
  }

  export type AppointmentMaxOrderByAggregateInput = {
    id?: SortOrder
    numericId?: SortOrder
    doctorId?: SortOrder
    patientId?: SortOrder
    when?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    status?: SortOrder
  }

  export type AppointmentMinOrderByAggregateInput = {
    id?: SortOrder
    numericId?: SortOrder
    doctorId?: SortOrder
    patientId?: SortOrder
    when?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    status?: SortOrder
  }

  export type AppointmentSumOrderByAggregateInput = {
    numericId?: SortOrder
  }

  export type EnumAppointmentStatusWithAggregatesFilter = {
    equals?: AppointmentStatus
    in?: Enumerable<AppointmentStatus>
    notIn?: Enumerable<AppointmentStatus>
    not?: NestedEnumAppointmentStatusWithAggregatesFilter | AppointmentStatus
    _count?: NestedIntFilter
    _min?: NestedEnumAppointmentStatusFilter
    _max?: NestedEnumAppointmentStatusFilter
  }
  export type JsonFilter = 
    | PatchUndefined<
        Either<Required<JsonFilterBase>, Exclude<keyof Required<JsonFilterBase>, 'path'>>,
        Required<JsonFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase>, 'path'>>

  export type JsonFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: string[]
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
  }

  export type SpecialtyRelationFilter = {
    is?: SpecialtyWhereInput
    isNot?: SpecialtyWhereInput
  }

  export type TemplateListRelationFilter = {
    every?: TemplateWhereInput
    some?: TemplateWhereInput
    none?: TemplateWhereInput
  }

  export type TemplateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DoctorCountOrderByAggregateInput = {
    id?: SortOrder
    numericId?: SortOrder
    userId?: SortOrder
    specialtyId?: SortOrder
    crfa?: SortOrder
    availability?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type DoctorAvgOrderByAggregateInput = {
    numericId?: SortOrder
  }

  export type DoctorMaxOrderByAggregateInput = {
    id?: SortOrder
    numericId?: SortOrder
    userId?: SortOrder
    specialtyId?: SortOrder
    crfa?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type DoctorMinOrderByAggregateInput = {
    id?: SortOrder
    numericId?: SortOrder
    userId?: SortOrder
    specialtyId?: SortOrder
    crfa?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type DoctorSumOrderByAggregateInput = {
    numericId?: SortOrder
  }
  export type JsonWithAggregatesFilter = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase>, Exclude<keyof Required<JsonWithAggregatesFilterBase>, 'path'>>,
        Required<JsonWithAggregatesFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase>, 'path'>>

  export type JsonWithAggregatesFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: string[]
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
    _count?: NestedIntFilter
    _min?: NestedJsonFilter
    _max?: NestedJsonFilter
  }

  export type DoctorPatientDoctorIdPatientIdCompoundUniqueInput = {
    doctorId: string
    patientId: string
  }

  export type DoctorPatientCountOrderByAggregateInput = {
    doctorId?: SortOrder
    patientId?: SortOrder
    assignedById?: SortOrder
    createdAt?: SortOrder
    active?: SortOrder
  }

  export type DoctorPatientMaxOrderByAggregateInput = {
    doctorId?: SortOrder
    patientId?: SortOrder
    assignedById?: SortOrder
    createdAt?: SortOrder
    active?: SortOrder
  }

  export type DoctorPatientMinOrderByAggregateInput = {
    doctorId?: SortOrder
    patientId?: SortOrder
    assignedById?: SortOrder
    createdAt?: SortOrder
    active?: SortOrder
  }

  export type DoctorListRelationFilter = {
    every?: DoctorWhereInput
    some?: DoctorWhereInput
    none?: DoctorWhereInput
  }

  export type DoctorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SpecialtyCountOrderByAggregateInput = {
    id?: SortOrder
    numericId?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SpecialtyAvgOrderByAggregateInput = {
    numericId?: SortOrder
  }

  export type SpecialtyMaxOrderByAggregateInput = {
    id?: SortOrder
    numericId?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SpecialtyMinOrderByAggregateInput = {
    id?: SortOrder
    numericId?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SpecialtySumOrderByAggregateInput = {
    numericId?: SortOrder
  }

  export type AnamnesisCountOrderByAggregateInput = {
    id?: SortOrder
    numericId?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    specialtyId?: SortOrder
    questions?: SortOrder
    title?: SortOrder
    text?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type AnamnesisAvgOrderByAggregateInput = {
    numericId?: SortOrder
  }

  export type AnamnesisMaxOrderByAggregateInput = {
    id?: SortOrder
    numericId?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    specialtyId?: SortOrder
    title?: SortOrder
    text?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type AnamnesisMinOrderByAggregateInput = {
    id?: SortOrder
    numericId?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    specialtyId?: SortOrder
    title?: SortOrder
    text?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type AnamnesisSumOrderByAggregateInput = {
    numericId?: SortOrder
  }

  export type EvolutionCountOrderByAggregateInput = {
    id?: SortOrder
    numericId?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    specialtyId?: SortOrder
    exercises?: SortOrder
    text?: SortOrder
    title?: SortOrder
    appointmentDate?: SortOrder
    comments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type EvolutionAvgOrderByAggregateInput = {
    numericId?: SortOrder
  }

  export type EvolutionMaxOrderByAggregateInput = {
    id?: SortOrder
    numericId?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    specialtyId?: SortOrder
    text?: SortOrder
    title?: SortOrder
    appointmentDate?: SortOrder
    comments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type EvolutionMinOrderByAggregateInput = {
    id?: SortOrder
    numericId?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    specialtyId?: SortOrder
    text?: SortOrder
    title?: SortOrder
    appointmentDate?: SortOrder
    comments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type EvolutionSumOrderByAggregateInput = {
    numericId?: SortOrder
  }

  export type EvaluationCountOrderByAggregateInput = {
    id?: SortOrder
    numericId?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    specialtyId?: SortOrder
    text?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type EvaluationAvgOrderByAggregateInput = {
    numericId?: SortOrder
  }

  export type EvaluationMaxOrderByAggregateInput = {
    id?: SortOrder
    numericId?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    specialtyId?: SortOrder
    text?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type EvaluationMinOrderByAggregateInput = {
    id?: SortOrder
    numericId?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    specialtyId?: SortOrder
    text?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type EvaluationSumOrderByAggregateInput = {
    numericId?: SortOrder
  }

  export type ExerciseCountOrderByAggregateInput = {
    id?: SortOrder
    numericId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    links?: SortOrder
    creatorId?: SortOrder
    specialtyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExerciseAvgOrderByAggregateInput = {
    numericId?: SortOrder
  }

  export type ExerciseMaxOrderByAggregateInput = {
    id?: SortOrder
    numericId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    creatorId?: SortOrder
    specialtyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExerciseMinOrderByAggregateInput = {
    id?: SortOrder
    numericId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    creatorId?: SortOrder
    specialtyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExerciseSumOrderByAggregateInput = {
    numericId?: SortOrder
  }

  export type EnumTemplateTypeFilter = {
    equals?: TemplateType
    in?: Enumerable<TemplateType>
    notIn?: Enumerable<TemplateType>
    not?: NestedEnumTemplateTypeFilter | TemplateType
  }

  export type TemplateCountOrderByAggregateInput = {
    id?: SortOrder
    numericId?: SortOrder
    doctorId?: SortOrder
    type?: SortOrder
    specialtyId?: SortOrder
    title?: SortOrder
    html?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type TemplateAvgOrderByAggregateInput = {
    numericId?: SortOrder
  }

  export type TemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    numericId?: SortOrder
    doctorId?: SortOrder
    type?: SortOrder
    specialtyId?: SortOrder
    title?: SortOrder
    html?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type TemplateMinOrderByAggregateInput = {
    id?: SortOrder
    numericId?: SortOrder
    doctorId?: SortOrder
    type?: SortOrder
    specialtyId?: SortOrder
    title?: SortOrder
    html?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type TemplateSumOrderByAggregateInput = {
    numericId?: SortOrder
  }

  export type EnumTemplateTypeWithAggregatesFilter = {
    equals?: TemplateType
    in?: Enumerable<TemplateType>
    notIn?: Enumerable<TemplateType>
    not?: NestedEnumTemplateTypeWithAggregatesFilter | TemplateType
    _count?: NestedIntFilter
    _min?: NestedEnumTemplateTypeFilter
    _max?: NestedEnumTemplateTypeFilter
  }

  export type CourseCountOrderByAggregateInput = {
    id?: SortOrder
    numericId?: SortOrder
    creatorId?: SortOrder
    specialtyId?: SortOrder
    order?: SortOrder
    title?: SortOrder
    cover?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type CourseAvgOrderByAggregateInput = {
    numericId?: SortOrder
    order?: SortOrder
  }

  export type CourseMaxOrderByAggregateInput = {
    id?: SortOrder
    numericId?: SortOrder
    creatorId?: SortOrder
    specialtyId?: SortOrder
    order?: SortOrder
    title?: SortOrder
    cover?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type CourseMinOrderByAggregateInput = {
    id?: SortOrder
    numericId?: SortOrder
    creatorId?: SortOrder
    specialtyId?: SortOrder
    order?: SortOrder
    title?: SortOrder
    cover?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type CourseSumOrderByAggregateInput = {
    numericId?: SortOrder
    order?: SortOrder
  }

  export type CourseRelationFilter = {
    is?: CourseWhereInput
    isNot?: CourseWhereInput
  }

  export type LessonVideoListRelationFilter = {
    every?: LessonVideoWhereInput
    some?: LessonVideoWhereInput
    none?: LessonVideoWhereInput
  }

  export type LessonVideoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LessonCountOrderByAggregateInput = {
    id?: SortOrder
    numericId?: SortOrder
    creatorId?: SortOrder
    courseId?: SortOrder
    order?: SortOrder
    title?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type LessonAvgOrderByAggregateInput = {
    numericId?: SortOrder
    order?: SortOrder
  }

  export type LessonMaxOrderByAggregateInput = {
    id?: SortOrder
    numericId?: SortOrder
    creatorId?: SortOrder
    courseId?: SortOrder
    order?: SortOrder
    title?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type LessonMinOrderByAggregateInput = {
    id?: SortOrder
    numericId?: SortOrder
    creatorId?: SortOrder
    courseId?: SortOrder
    order?: SortOrder
    title?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type LessonSumOrderByAggregateInput = {
    numericId?: SortOrder
    order?: SortOrder
  }

  export type LessonRelationFilter = {
    is?: LessonWhereInput
    isNot?: LessonWhereInput
  }

  export type LessonVideoCountOrderByAggregateInput = {
    id?: SortOrder
    numericId?: SortOrder
    lessonId?: SortOrder
    order?: SortOrder
    title?: SortOrder
    video?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type LessonVideoAvgOrderByAggregateInput = {
    numericId?: SortOrder
    order?: SortOrder
  }

  export type LessonVideoMaxOrderByAggregateInput = {
    id?: SortOrder
    numericId?: SortOrder
    lessonId?: SortOrder
    order?: SortOrder
    title?: SortOrder
    video?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type LessonVideoMinOrderByAggregateInput = {
    id?: SortOrder
    numericId?: SortOrder
    lessonId?: SortOrder
    order?: SortOrder
    title?: SortOrder
    video?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type LessonVideoSumOrderByAggregateInput = {
    numericId?: SortOrder
    order?: SortOrder
  }

  export type LessonVideoRelationFilter = {
    is?: LessonVideoWhereInput
    isNot?: LessonVideoWhereInput
  }

  export type WatchedVideoCountOrderByAggregateInput = {
    id?: SortOrder
    numericId?: SortOrder
    userId?: SortOrder
    videoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type WatchedVideoAvgOrderByAggregateInput = {
    numericId?: SortOrder
  }

  export type WatchedVideoMaxOrderByAggregateInput = {
    id?: SortOrder
    numericId?: SortOrder
    userId?: SortOrder
    videoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type WatchedVideoMinOrderByAggregateInput = {
    id?: SortOrder
    numericId?: SortOrder
    userId?: SortOrder
    videoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type WatchedVideoSumOrderByAggregateInput = {
    numericId?: SortOrder
  }

  export type PatientCreateNestedOneWithoutUserInput = {
    create?: XOR<PatientCreateWithoutUserInput, PatientUncheckedCreateWithoutUserInput>
    connectOrCreate?: PatientCreateOrConnectWithoutUserInput
    connect?: PatientWhereUniqueInput
  }

  export type DoctorCreateNestedOneWithoutUserInput = {
    create?: XOR<DoctorCreateWithoutUserInput, DoctorUncheckedCreateWithoutUserInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutUserInput
    connect?: DoctorWhereUniqueInput
  }

  export type UserAdressCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserAdressCreateWithoutUserInput>, Enumerable<UserAdressUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserAdressCreateOrConnectWithoutUserInput>
    createMany?: UserAdressCreateManyUserInputEnvelope
    connect?: Enumerable<UserAdressWhereUniqueInput>
  }

  export type UserContactCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserContactCreateWithoutUserInput>, Enumerable<UserContactUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserContactCreateOrConnectWithoutUserInput>
    createMany?: UserContactCreateManyUserInputEnvelope
    connect?: Enumerable<UserContactWhereUniqueInput>
  }

  export type DoctorPatientCreateNestedManyWithoutAssignedByInput = {
    create?: XOR<Enumerable<DoctorPatientCreateWithoutAssignedByInput>, Enumerable<DoctorPatientUncheckedCreateWithoutAssignedByInput>>
    connectOrCreate?: Enumerable<DoctorPatientCreateOrConnectWithoutAssignedByInput>
    createMany?: DoctorPatientCreateManyAssignedByInputEnvelope
    connect?: Enumerable<DoctorPatientWhereUniqueInput>
  }

  export type ExerciseCreateNestedManyWithoutCreatorInput = {
    create?: XOR<Enumerable<ExerciseCreateWithoutCreatorInput>, Enumerable<ExerciseUncheckedCreateWithoutCreatorInput>>
    connectOrCreate?: Enumerable<ExerciseCreateOrConnectWithoutCreatorInput>
    createMany?: ExerciseCreateManyCreatorInputEnvelope
    connect?: Enumerable<ExerciseWhereUniqueInput>
  }

  export type CourseCreateNestedManyWithoutCreatorInput = {
    create?: XOR<Enumerable<CourseCreateWithoutCreatorInput>, Enumerable<CourseUncheckedCreateWithoutCreatorInput>>
    connectOrCreate?: Enumerable<CourseCreateOrConnectWithoutCreatorInput>
    createMany?: CourseCreateManyCreatorInputEnvelope
    connect?: Enumerable<CourseWhereUniqueInput>
  }

  export type LessonCreateNestedManyWithoutCreatorInput = {
    create?: XOR<Enumerable<LessonCreateWithoutCreatorInput>, Enumerable<LessonUncheckedCreateWithoutCreatorInput>>
    connectOrCreate?: Enumerable<LessonCreateOrConnectWithoutCreatorInput>
    createMany?: LessonCreateManyCreatorInputEnvelope
    connect?: Enumerable<LessonWhereUniqueInput>
  }

  export type WatchedVideoCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<WatchedVideoCreateWithoutUserInput>, Enumerable<WatchedVideoUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<WatchedVideoCreateOrConnectWithoutUserInput>
    createMany?: WatchedVideoCreateManyUserInputEnvelope
    connect?: Enumerable<WatchedVideoWhereUniqueInput>
  }

  export type PatientUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<PatientCreateWithoutUserInput, PatientUncheckedCreateWithoutUserInput>
    connectOrCreate?: PatientCreateOrConnectWithoutUserInput
    connect?: PatientWhereUniqueInput
  }

  export type DoctorUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<DoctorCreateWithoutUserInput, DoctorUncheckedCreateWithoutUserInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutUserInput
    connect?: DoctorWhereUniqueInput
  }

  export type UserAdressUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserAdressCreateWithoutUserInput>, Enumerable<UserAdressUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserAdressCreateOrConnectWithoutUserInput>
    createMany?: UserAdressCreateManyUserInputEnvelope
    connect?: Enumerable<UserAdressWhereUniqueInput>
  }

  export type UserContactUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserContactCreateWithoutUserInput>, Enumerable<UserContactUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserContactCreateOrConnectWithoutUserInput>
    createMany?: UserContactCreateManyUserInputEnvelope
    connect?: Enumerable<UserContactWhereUniqueInput>
  }

  export type DoctorPatientUncheckedCreateNestedManyWithoutAssignedByInput = {
    create?: XOR<Enumerable<DoctorPatientCreateWithoutAssignedByInput>, Enumerable<DoctorPatientUncheckedCreateWithoutAssignedByInput>>
    connectOrCreate?: Enumerable<DoctorPatientCreateOrConnectWithoutAssignedByInput>
    createMany?: DoctorPatientCreateManyAssignedByInputEnvelope
    connect?: Enumerable<DoctorPatientWhereUniqueInput>
  }

  export type ExerciseUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<Enumerable<ExerciseCreateWithoutCreatorInput>, Enumerable<ExerciseUncheckedCreateWithoutCreatorInput>>
    connectOrCreate?: Enumerable<ExerciseCreateOrConnectWithoutCreatorInput>
    createMany?: ExerciseCreateManyCreatorInputEnvelope
    connect?: Enumerable<ExerciseWhereUniqueInput>
  }

  export type CourseUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<Enumerable<CourseCreateWithoutCreatorInput>, Enumerable<CourseUncheckedCreateWithoutCreatorInput>>
    connectOrCreate?: Enumerable<CourseCreateOrConnectWithoutCreatorInput>
    createMany?: CourseCreateManyCreatorInputEnvelope
    connect?: Enumerable<CourseWhereUniqueInput>
  }

  export type LessonUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<Enumerable<LessonCreateWithoutCreatorInput>, Enumerable<LessonUncheckedCreateWithoutCreatorInput>>
    connectOrCreate?: Enumerable<LessonCreateOrConnectWithoutCreatorInput>
    createMany?: LessonCreateManyCreatorInputEnvelope
    connect?: Enumerable<LessonWhereUniqueInput>
  }

  export type WatchedVideoUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<WatchedVideoCreateWithoutUserInput>, Enumerable<WatchedVideoUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<WatchedVideoCreateOrConnectWithoutUserInput>
    createMany?: WatchedVideoCreateManyUserInputEnvelope
    connect?: Enumerable<WatchedVideoWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumUserTypeFieldUpdateOperationsInput = {
    set?: UserType
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type PatientUpdateOneWithoutUserNestedInput = {
    create?: XOR<PatientCreateWithoutUserInput, PatientUncheckedCreateWithoutUserInput>
    connectOrCreate?: PatientCreateOrConnectWithoutUserInput
    upsert?: PatientUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: PatientWhereUniqueInput
    update?: XOR<PatientUpdateWithoutUserInput, PatientUncheckedUpdateWithoutUserInput>
  }

  export type DoctorUpdateOneWithoutUserNestedInput = {
    create?: XOR<DoctorCreateWithoutUserInput, DoctorUncheckedCreateWithoutUserInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutUserInput
    upsert?: DoctorUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: DoctorWhereUniqueInput
    update?: XOR<DoctorUpdateWithoutUserInput, DoctorUncheckedUpdateWithoutUserInput>
  }

  export type UserAdressUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<UserAdressCreateWithoutUserInput>, Enumerable<UserAdressUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserAdressCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserAdressUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserAdressCreateManyUserInputEnvelope
    set?: Enumerable<UserAdressWhereUniqueInput>
    disconnect?: Enumerable<UserAdressWhereUniqueInput>
    delete?: Enumerable<UserAdressWhereUniqueInput>
    connect?: Enumerable<UserAdressWhereUniqueInput>
    update?: Enumerable<UserAdressUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserAdressUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserAdressScalarWhereInput>
  }

  export type UserContactUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<UserContactCreateWithoutUserInput>, Enumerable<UserContactUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserContactCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserContactUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserContactCreateManyUserInputEnvelope
    set?: Enumerable<UserContactWhereUniqueInput>
    disconnect?: Enumerable<UserContactWhereUniqueInput>
    delete?: Enumerable<UserContactWhereUniqueInput>
    connect?: Enumerable<UserContactWhereUniqueInput>
    update?: Enumerable<UserContactUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserContactUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserContactScalarWhereInput>
  }

  export type DoctorPatientUpdateManyWithoutAssignedByNestedInput = {
    create?: XOR<Enumerable<DoctorPatientCreateWithoutAssignedByInput>, Enumerable<DoctorPatientUncheckedCreateWithoutAssignedByInput>>
    connectOrCreate?: Enumerable<DoctorPatientCreateOrConnectWithoutAssignedByInput>
    upsert?: Enumerable<DoctorPatientUpsertWithWhereUniqueWithoutAssignedByInput>
    createMany?: DoctorPatientCreateManyAssignedByInputEnvelope
    set?: Enumerable<DoctorPatientWhereUniqueInput>
    disconnect?: Enumerable<DoctorPatientWhereUniqueInput>
    delete?: Enumerable<DoctorPatientWhereUniqueInput>
    connect?: Enumerable<DoctorPatientWhereUniqueInput>
    update?: Enumerable<DoctorPatientUpdateWithWhereUniqueWithoutAssignedByInput>
    updateMany?: Enumerable<DoctorPatientUpdateManyWithWhereWithoutAssignedByInput>
    deleteMany?: Enumerable<DoctorPatientScalarWhereInput>
  }

  export type ExerciseUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<Enumerable<ExerciseCreateWithoutCreatorInput>, Enumerable<ExerciseUncheckedCreateWithoutCreatorInput>>
    connectOrCreate?: Enumerable<ExerciseCreateOrConnectWithoutCreatorInput>
    upsert?: Enumerable<ExerciseUpsertWithWhereUniqueWithoutCreatorInput>
    createMany?: ExerciseCreateManyCreatorInputEnvelope
    set?: Enumerable<ExerciseWhereUniqueInput>
    disconnect?: Enumerable<ExerciseWhereUniqueInput>
    delete?: Enumerable<ExerciseWhereUniqueInput>
    connect?: Enumerable<ExerciseWhereUniqueInput>
    update?: Enumerable<ExerciseUpdateWithWhereUniqueWithoutCreatorInput>
    updateMany?: Enumerable<ExerciseUpdateManyWithWhereWithoutCreatorInput>
    deleteMany?: Enumerable<ExerciseScalarWhereInput>
  }

  export type CourseUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<Enumerable<CourseCreateWithoutCreatorInput>, Enumerable<CourseUncheckedCreateWithoutCreatorInput>>
    connectOrCreate?: Enumerable<CourseCreateOrConnectWithoutCreatorInput>
    upsert?: Enumerable<CourseUpsertWithWhereUniqueWithoutCreatorInput>
    createMany?: CourseCreateManyCreatorInputEnvelope
    set?: Enumerable<CourseWhereUniqueInput>
    disconnect?: Enumerable<CourseWhereUniqueInput>
    delete?: Enumerable<CourseWhereUniqueInput>
    connect?: Enumerable<CourseWhereUniqueInput>
    update?: Enumerable<CourseUpdateWithWhereUniqueWithoutCreatorInput>
    updateMany?: Enumerable<CourseUpdateManyWithWhereWithoutCreatorInput>
    deleteMany?: Enumerable<CourseScalarWhereInput>
  }

  export type LessonUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<Enumerable<LessonCreateWithoutCreatorInput>, Enumerable<LessonUncheckedCreateWithoutCreatorInput>>
    connectOrCreate?: Enumerable<LessonCreateOrConnectWithoutCreatorInput>
    upsert?: Enumerable<LessonUpsertWithWhereUniqueWithoutCreatorInput>
    createMany?: LessonCreateManyCreatorInputEnvelope
    set?: Enumerable<LessonWhereUniqueInput>
    disconnect?: Enumerable<LessonWhereUniqueInput>
    delete?: Enumerable<LessonWhereUniqueInput>
    connect?: Enumerable<LessonWhereUniqueInput>
    update?: Enumerable<LessonUpdateWithWhereUniqueWithoutCreatorInput>
    updateMany?: Enumerable<LessonUpdateManyWithWhereWithoutCreatorInput>
    deleteMany?: Enumerable<LessonScalarWhereInput>
  }

  export type WatchedVideoUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<WatchedVideoCreateWithoutUserInput>, Enumerable<WatchedVideoUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<WatchedVideoCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<WatchedVideoUpsertWithWhereUniqueWithoutUserInput>
    createMany?: WatchedVideoCreateManyUserInputEnvelope
    set?: Enumerable<WatchedVideoWhereUniqueInput>
    disconnect?: Enumerable<WatchedVideoWhereUniqueInput>
    delete?: Enumerable<WatchedVideoWhereUniqueInput>
    connect?: Enumerable<WatchedVideoWhereUniqueInput>
    update?: Enumerable<WatchedVideoUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<WatchedVideoUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<WatchedVideoScalarWhereInput>
  }

  export type PatientUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<PatientCreateWithoutUserInput, PatientUncheckedCreateWithoutUserInput>
    connectOrCreate?: PatientCreateOrConnectWithoutUserInput
    upsert?: PatientUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: PatientWhereUniqueInput
    update?: XOR<PatientUpdateWithoutUserInput, PatientUncheckedUpdateWithoutUserInput>
  }

  export type DoctorUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<DoctorCreateWithoutUserInput, DoctorUncheckedCreateWithoutUserInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutUserInput
    upsert?: DoctorUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: DoctorWhereUniqueInput
    update?: XOR<DoctorUpdateWithoutUserInput, DoctorUncheckedUpdateWithoutUserInput>
  }

  export type UserAdressUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<UserAdressCreateWithoutUserInput>, Enumerable<UserAdressUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserAdressCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserAdressUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserAdressCreateManyUserInputEnvelope
    set?: Enumerable<UserAdressWhereUniqueInput>
    disconnect?: Enumerable<UserAdressWhereUniqueInput>
    delete?: Enumerable<UserAdressWhereUniqueInput>
    connect?: Enumerable<UserAdressWhereUniqueInput>
    update?: Enumerable<UserAdressUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserAdressUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserAdressScalarWhereInput>
  }

  export type UserContactUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<UserContactCreateWithoutUserInput>, Enumerable<UserContactUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserContactCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserContactUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserContactCreateManyUserInputEnvelope
    set?: Enumerable<UserContactWhereUniqueInput>
    disconnect?: Enumerable<UserContactWhereUniqueInput>
    delete?: Enumerable<UserContactWhereUniqueInput>
    connect?: Enumerable<UserContactWhereUniqueInput>
    update?: Enumerable<UserContactUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserContactUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserContactScalarWhereInput>
  }

  export type DoctorPatientUncheckedUpdateManyWithoutAssignedByNestedInput = {
    create?: XOR<Enumerable<DoctorPatientCreateWithoutAssignedByInput>, Enumerable<DoctorPatientUncheckedCreateWithoutAssignedByInput>>
    connectOrCreate?: Enumerable<DoctorPatientCreateOrConnectWithoutAssignedByInput>
    upsert?: Enumerable<DoctorPatientUpsertWithWhereUniqueWithoutAssignedByInput>
    createMany?: DoctorPatientCreateManyAssignedByInputEnvelope
    set?: Enumerable<DoctorPatientWhereUniqueInput>
    disconnect?: Enumerable<DoctorPatientWhereUniqueInput>
    delete?: Enumerable<DoctorPatientWhereUniqueInput>
    connect?: Enumerable<DoctorPatientWhereUniqueInput>
    update?: Enumerable<DoctorPatientUpdateWithWhereUniqueWithoutAssignedByInput>
    updateMany?: Enumerable<DoctorPatientUpdateManyWithWhereWithoutAssignedByInput>
    deleteMany?: Enumerable<DoctorPatientScalarWhereInput>
  }

  export type ExerciseUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<Enumerable<ExerciseCreateWithoutCreatorInput>, Enumerable<ExerciseUncheckedCreateWithoutCreatorInput>>
    connectOrCreate?: Enumerable<ExerciseCreateOrConnectWithoutCreatorInput>
    upsert?: Enumerable<ExerciseUpsertWithWhereUniqueWithoutCreatorInput>
    createMany?: ExerciseCreateManyCreatorInputEnvelope
    set?: Enumerable<ExerciseWhereUniqueInput>
    disconnect?: Enumerable<ExerciseWhereUniqueInput>
    delete?: Enumerable<ExerciseWhereUniqueInput>
    connect?: Enumerable<ExerciseWhereUniqueInput>
    update?: Enumerable<ExerciseUpdateWithWhereUniqueWithoutCreatorInput>
    updateMany?: Enumerable<ExerciseUpdateManyWithWhereWithoutCreatorInput>
    deleteMany?: Enumerable<ExerciseScalarWhereInput>
  }

  export type CourseUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<Enumerable<CourseCreateWithoutCreatorInput>, Enumerable<CourseUncheckedCreateWithoutCreatorInput>>
    connectOrCreate?: Enumerable<CourseCreateOrConnectWithoutCreatorInput>
    upsert?: Enumerable<CourseUpsertWithWhereUniqueWithoutCreatorInput>
    createMany?: CourseCreateManyCreatorInputEnvelope
    set?: Enumerable<CourseWhereUniqueInput>
    disconnect?: Enumerable<CourseWhereUniqueInput>
    delete?: Enumerable<CourseWhereUniqueInput>
    connect?: Enumerable<CourseWhereUniqueInput>
    update?: Enumerable<CourseUpdateWithWhereUniqueWithoutCreatorInput>
    updateMany?: Enumerable<CourseUpdateManyWithWhereWithoutCreatorInput>
    deleteMany?: Enumerable<CourseScalarWhereInput>
  }

  export type LessonUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<Enumerable<LessonCreateWithoutCreatorInput>, Enumerable<LessonUncheckedCreateWithoutCreatorInput>>
    connectOrCreate?: Enumerable<LessonCreateOrConnectWithoutCreatorInput>
    upsert?: Enumerable<LessonUpsertWithWhereUniqueWithoutCreatorInput>
    createMany?: LessonCreateManyCreatorInputEnvelope
    set?: Enumerable<LessonWhereUniqueInput>
    disconnect?: Enumerable<LessonWhereUniqueInput>
    delete?: Enumerable<LessonWhereUniqueInput>
    connect?: Enumerable<LessonWhereUniqueInput>
    update?: Enumerable<LessonUpdateWithWhereUniqueWithoutCreatorInput>
    updateMany?: Enumerable<LessonUpdateManyWithWhereWithoutCreatorInput>
    deleteMany?: Enumerable<LessonScalarWhereInput>
  }

  export type WatchedVideoUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<WatchedVideoCreateWithoutUserInput>, Enumerable<WatchedVideoUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<WatchedVideoCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<WatchedVideoUpsertWithWhereUniqueWithoutUserInput>
    createMany?: WatchedVideoCreateManyUserInputEnvelope
    set?: Enumerable<WatchedVideoWhereUniqueInput>
    disconnect?: Enumerable<WatchedVideoWhereUniqueInput>
    delete?: Enumerable<WatchedVideoWhereUniqueInput>
    connect?: Enumerable<WatchedVideoWhereUniqueInput>
    update?: Enumerable<WatchedVideoUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<WatchedVideoUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<WatchedVideoScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutAddressesInput = {
    create?: XOR<UserCreateWithoutAddressesInput, UserUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAddressesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAddressesNestedInput = {
    create?: XOR<UserCreateWithoutAddressesInput, UserUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAddressesInput
    upsert?: UserUpsertWithoutAddressesInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutAddressesInput, UserUncheckedUpdateWithoutAddressesInput>
  }

  export type UserCreateNestedOneWithoutContactsInput = {
    create?: XOR<UserCreateWithoutContactsInput, UserUncheckedCreateWithoutContactsInput>
    connectOrCreate?: UserCreateOrConnectWithoutContactsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutContactsNestedInput = {
    create?: XOR<UserCreateWithoutContactsInput, UserUncheckedCreateWithoutContactsInput>
    connectOrCreate?: UserCreateOrConnectWithoutContactsInput
    upsert?: UserUpsertWithoutContactsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutContactsInput, UserUncheckedUpdateWithoutContactsInput>
  }

  export type UserCreateNestedOneWithoutPatientDataInput = {
    create?: XOR<UserCreateWithoutPatientDataInput, UserUncheckedCreateWithoutPatientDataInput>
    connectOrCreate?: UserCreateOrConnectWithoutPatientDataInput
    connect?: UserWhereUniqueInput
  }

  export type AnamnesisCreateNestedManyWithoutPatientInput = {
    create?: XOR<Enumerable<AnamnesisCreateWithoutPatientInput>, Enumerable<AnamnesisUncheckedCreateWithoutPatientInput>>
    connectOrCreate?: Enumerable<AnamnesisCreateOrConnectWithoutPatientInput>
    createMany?: AnamnesisCreateManyPatientInputEnvelope
    connect?: Enumerable<AnamnesisWhereUniqueInput>
  }

  export type EvaluationCreateNestedManyWithoutPatientInput = {
    create?: XOR<Enumerable<EvaluationCreateWithoutPatientInput>, Enumerable<EvaluationUncheckedCreateWithoutPatientInput>>
    connectOrCreate?: Enumerable<EvaluationCreateOrConnectWithoutPatientInput>
    createMany?: EvaluationCreateManyPatientInputEnvelope
    connect?: Enumerable<EvaluationWhereUniqueInput>
  }

  export type DoctorPatientCreateNestedManyWithoutPatientInput = {
    create?: XOR<Enumerable<DoctorPatientCreateWithoutPatientInput>, Enumerable<DoctorPatientUncheckedCreateWithoutPatientInput>>
    connectOrCreate?: Enumerable<DoctorPatientCreateOrConnectWithoutPatientInput>
    createMany?: DoctorPatientCreateManyPatientInputEnvelope
    connect?: Enumerable<DoctorPatientWhereUniqueInput>
  }

  export type EvolutionCreateNestedManyWithoutPatientInput = {
    create?: XOR<Enumerable<EvolutionCreateWithoutPatientInput>, Enumerable<EvolutionUncheckedCreateWithoutPatientInput>>
    connectOrCreate?: Enumerable<EvolutionCreateOrConnectWithoutPatientInput>
    createMany?: EvolutionCreateManyPatientInputEnvelope
    connect?: Enumerable<EvolutionWhereUniqueInput>
  }

  export type AppointmentCreateNestedManyWithoutPatientInput = {
    create?: XOR<Enumerable<AppointmentCreateWithoutPatientInput>, Enumerable<AppointmentUncheckedCreateWithoutPatientInput>>
    connectOrCreate?: Enumerable<AppointmentCreateOrConnectWithoutPatientInput>
    createMany?: AppointmentCreateManyPatientInputEnvelope
    connect?: Enumerable<AppointmentWhereUniqueInput>
  }

  export type AnamnesisUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<Enumerable<AnamnesisCreateWithoutPatientInput>, Enumerable<AnamnesisUncheckedCreateWithoutPatientInput>>
    connectOrCreate?: Enumerable<AnamnesisCreateOrConnectWithoutPatientInput>
    createMany?: AnamnesisCreateManyPatientInputEnvelope
    connect?: Enumerable<AnamnesisWhereUniqueInput>
  }

  export type EvaluationUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<Enumerable<EvaluationCreateWithoutPatientInput>, Enumerable<EvaluationUncheckedCreateWithoutPatientInput>>
    connectOrCreate?: Enumerable<EvaluationCreateOrConnectWithoutPatientInput>
    createMany?: EvaluationCreateManyPatientInputEnvelope
    connect?: Enumerable<EvaluationWhereUniqueInput>
  }

  export type DoctorPatientUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<Enumerable<DoctorPatientCreateWithoutPatientInput>, Enumerable<DoctorPatientUncheckedCreateWithoutPatientInput>>
    connectOrCreate?: Enumerable<DoctorPatientCreateOrConnectWithoutPatientInput>
    createMany?: DoctorPatientCreateManyPatientInputEnvelope
    connect?: Enumerable<DoctorPatientWhereUniqueInput>
  }

  export type EvolutionUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<Enumerable<EvolutionCreateWithoutPatientInput>, Enumerable<EvolutionUncheckedCreateWithoutPatientInput>>
    connectOrCreate?: Enumerable<EvolutionCreateOrConnectWithoutPatientInput>
    createMany?: EvolutionCreateManyPatientInputEnvelope
    connect?: Enumerable<EvolutionWhereUniqueInput>
  }

  export type AppointmentUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<Enumerable<AppointmentCreateWithoutPatientInput>, Enumerable<AppointmentUncheckedCreateWithoutPatientInput>>
    connectOrCreate?: Enumerable<AppointmentCreateOrConnectWithoutPatientInput>
    createMany?: AppointmentCreateManyPatientInputEnvelope
    connect?: Enumerable<AppointmentWhereUniqueInput>
  }

  export type UserUpdateOneRequiredWithoutPatientDataNestedInput = {
    create?: XOR<UserCreateWithoutPatientDataInput, UserUncheckedCreateWithoutPatientDataInput>
    connectOrCreate?: UserCreateOrConnectWithoutPatientDataInput
    upsert?: UserUpsertWithoutPatientDataInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutPatientDataInput, UserUncheckedUpdateWithoutPatientDataInput>
  }

  export type AnamnesisUpdateManyWithoutPatientNestedInput = {
    create?: XOR<Enumerable<AnamnesisCreateWithoutPatientInput>, Enumerable<AnamnesisUncheckedCreateWithoutPatientInput>>
    connectOrCreate?: Enumerable<AnamnesisCreateOrConnectWithoutPatientInput>
    upsert?: Enumerable<AnamnesisUpsertWithWhereUniqueWithoutPatientInput>
    createMany?: AnamnesisCreateManyPatientInputEnvelope
    set?: Enumerable<AnamnesisWhereUniqueInput>
    disconnect?: Enumerable<AnamnesisWhereUniqueInput>
    delete?: Enumerable<AnamnesisWhereUniqueInput>
    connect?: Enumerable<AnamnesisWhereUniqueInput>
    update?: Enumerable<AnamnesisUpdateWithWhereUniqueWithoutPatientInput>
    updateMany?: Enumerable<AnamnesisUpdateManyWithWhereWithoutPatientInput>
    deleteMany?: Enumerable<AnamnesisScalarWhereInput>
  }

  export type EvaluationUpdateManyWithoutPatientNestedInput = {
    create?: XOR<Enumerable<EvaluationCreateWithoutPatientInput>, Enumerable<EvaluationUncheckedCreateWithoutPatientInput>>
    connectOrCreate?: Enumerable<EvaluationCreateOrConnectWithoutPatientInput>
    upsert?: Enumerable<EvaluationUpsertWithWhereUniqueWithoutPatientInput>
    createMany?: EvaluationCreateManyPatientInputEnvelope
    set?: Enumerable<EvaluationWhereUniqueInput>
    disconnect?: Enumerable<EvaluationWhereUniqueInput>
    delete?: Enumerable<EvaluationWhereUniqueInput>
    connect?: Enumerable<EvaluationWhereUniqueInput>
    update?: Enumerable<EvaluationUpdateWithWhereUniqueWithoutPatientInput>
    updateMany?: Enumerable<EvaluationUpdateManyWithWhereWithoutPatientInput>
    deleteMany?: Enumerable<EvaluationScalarWhereInput>
  }

  export type DoctorPatientUpdateManyWithoutPatientNestedInput = {
    create?: XOR<Enumerable<DoctorPatientCreateWithoutPatientInput>, Enumerable<DoctorPatientUncheckedCreateWithoutPatientInput>>
    connectOrCreate?: Enumerable<DoctorPatientCreateOrConnectWithoutPatientInput>
    upsert?: Enumerable<DoctorPatientUpsertWithWhereUniqueWithoutPatientInput>
    createMany?: DoctorPatientCreateManyPatientInputEnvelope
    set?: Enumerable<DoctorPatientWhereUniqueInput>
    disconnect?: Enumerable<DoctorPatientWhereUniqueInput>
    delete?: Enumerable<DoctorPatientWhereUniqueInput>
    connect?: Enumerable<DoctorPatientWhereUniqueInput>
    update?: Enumerable<DoctorPatientUpdateWithWhereUniqueWithoutPatientInput>
    updateMany?: Enumerable<DoctorPatientUpdateManyWithWhereWithoutPatientInput>
    deleteMany?: Enumerable<DoctorPatientScalarWhereInput>
  }

  export type EvolutionUpdateManyWithoutPatientNestedInput = {
    create?: XOR<Enumerable<EvolutionCreateWithoutPatientInput>, Enumerable<EvolutionUncheckedCreateWithoutPatientInput>>
    connectOrCreate?: Enumerable<EvolutionCreateOrConnectWithoutPatientInput>
    upsert?: Enumerable<EvolutionUpsertWithWhereUniqueWithoutPatientInput>
    createMany?: EvolutionCreateManyPatientInputEnvelope
    set?: Enumerable<EvolutionWhereUniqueInput>
    disconnect?: Enumerable<EvolutionWhereUniqueInput>
    delete?: Enumerable<EvolutionWhereUniqueInput>
    connect?: Enumerable<EvolutionWhereUniqueInput>
    update?: Enumerable<EvolutionUpdateWithWhereUniqueWithoutPatientInput>
    updateMany?: Enumerable<EvolutionUpdateManyWithWhereWithoutPatientInput>
    deleteMany?: Enumerable<EvolutionScalarWhereInput>
  }

  export type AppointmentUpdateManyWithoutPatientNestedInput = {
    create?: XOR<Enumerable<AppointmentCreateWithoutPatientInput>, Enumerable<AppointmentUncheckedCreateWithoutPatientInput>>
    connectOrCreate?: Enumerable<AppointmentCreateOrConnectWithoutPatientInput>
    upsert?: Enumerable<AppointmentUpsertWithWhereUniqueWithoutPatientInput>
    createMany?: AppointmentCreateManyPatientInputEnvelope
    set?: Enumerable<AppointmentWhereUniqueInput>
    disconnect?: Enumerable<AppointmentWhereUniqueInput>
    delete?: Enumerable<AppointmentWhereUniqueInput>
    connect?: Enumerable<AppointmentWhereUniqueInput>
    update?: Enumerable<AppointmentUpdateWithWhereUniqueWithoutPatientInput>
    updateMany?: Enumerable<AppointmentUpdateManyWithWhereWithoutPatientInput>
    deleteMany?: Enumerable<AppointmentScalarWhereInput>
  }

  export type AnamnesisUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<Enumerable<AnamnesisCreateWithoutPatientInput>, Enumerable<AnamnesisUncheckedCreateWithoutPatientInput>>
    connectOrCreate?: Enumerable<AnamnesisCreateOrConnectWithoutPatientInput>
    upsert?: Enumerable<AnamnesisUpsertWithWhereUniqueWithoutPatientInput>
    createMany?: AnamnesisCreateManyPatientInputEnvelope
    set?: Enumerable<AnamnesisWhereUniqueInput>
    disconnect?: Enumerable<AnamnesisWhereUniqueInput>
    delete?: Enumerable<AnamnesisWhereUniqueInput>
    connect?: Enumerable<AnamnesisWhereUniqueInput>
    update?: Enumerable<AnamnesisUpdateWithWhereUniqueWithoutPatientInput>
    updateMany?: Enumerable<AnamnesisUpdateManyWithWhereWithoutPatientInput>
    deleteMany?: Enumerable<AnamnesisScalarWhereInput>
  }

  export type EvaluationUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<Enumerable<EvaluationCreateWithoutPatientInput>, Enumerable<EvaluationUncheckedCreateWithoutPatientInput>>
    connectOrCreate?: Enumerable<EvaluationCreateOrConnectWithoutPatientInput>
    upsert?: Enumerable<EvaluationUpsertWithWhereUniqueWithoutPatientInput>
    createMany?: EvaluationCreateManyPatientInputEnvelope
    set?: Enumerable<EvaluationWhereUniqueInput>
    disconnect?: Enumerable<EvaluationWhereUniqueInput>
    delete?: Enumerable<EvaluationWhereUniqueInput>
    connect?: Enumerable<EvaluationWhereUniqueInput>
    update?: Enumerable<EvaluationUpdateWithWhereUniqueWithoutPatientInput>
    updateMany?: Enumerable<EvaluationUpdateManyWithWhereWithoutPatientInput>
    deleteMany?: Enumerable<EvaluationScalarWhereInput>
  }

  export type DoctorPatientUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<Enumerable<DoctorPatientCreateWithoutPatientInput>, Enumerable<DoctorPatientUncheckedCreateWithoutPatientInput>>
    connectOrCreate?: Enumerable<DoctorPatientCreateOrConnectWithoutPatientInput>
    upsert?: Enumerable<DoctorPatientUpsertWithWhereUniqueWithoutPatientInput>
    createMany?: DoctorPatientCreateManyPatientInputEnvelope
    set?: Enumerable<DoctorPatientWhereUniqueInput>
    disconnect?: Enumerable<DoctorPatientWhereUniqueInput>
    delete?: Enumerable<DoctorPatientWhereUniqueInput>
    connect?: Enumerable<DoctorPatientWhereUniqueInput>
    update?: Enumerable<DoctorPatientUpdateWithWhereUniqueWithoutPatientInput>
    updateMany?: Enumerable<DoctorPatientUpdateManyWithWhereWithoutPatientInput>
    deleteMany?: Enumerable<DoctorPatientScalarWhereInput>
  }

  export type EvolutionUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<Enumerable<EvolutionCreateWithoutPatientInput>, Enumerable<EvolutionUncheckedCreateWithoutPatientInput>>
    connectOrCreate?: Enumerable<EvolutionCreateOrConnectWithoutPatientInput>
    upsert?: Enumerable<EvolutionUpsertWithWhereUniqueWithoutPatientInput>
    createMany?: EvolutionCreateManyPatientInputEnvelope
    set?: Enumerable<EvolutionWhereUniqueInput>
    disconnect?: Enumerable<EvolutionWhereUniqueInput>
    delete?: Enumerable<EvolutionWhereUniqueInput>
    connect?: Enumerable<EvolutionWhereUniqueInput>
    update?: Enumerable<EvolutionUpdateWithWhereUniqueWithoutPatientInput>
    updateMany?: Enumerable<EvolutionUpdateManyWithWhereWithoutPatientInput>
    deleteMany?: Enumerable<EvolutionScalarWhereInput>
  }

  export type AppointmentUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<Enumerable<AppointmentCreateWithoutPatientInput>, Enumerable<AppointmentUncheckedCreateWithoutPatientInput>>
    connectOrCreate?: Enumerable<AppointmentCreateOrConnectWithoutPatientInput>
    upsert?: Enumerable<AppointmentUpsertWithWhereUniqueWithoutPatientInput>
    createMany?: AppointmentCreateManyPatientInputEnvelope
    set?: Enumerable<AppointmentWhereUniqueInput>
    disconnect?: Enumerable<AppointmentWhereUniqueInput>
    delete?: Enumerable<AppointmentWhereUniqueInput>
    connect?: Enumerable<AppointmentWhereUniqueInput>
    update?: Enumerable<AppointmentUpdateWithWhereUniqueWithoutPatientInput>
    updateMany?: Enumerable<AppointmentUpdateManyWithWhereWithoutPatientInput>
    deleteMany?: Enumerable<AppointmentScalarWhereInput>
  }

  export type DoctorCreateNestedOneWithoutAppointmentsInput = {
    create?: XOR<DoctorCreateWithoutAppointmentsInput, DoctorUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutAppointmentsInput
    connect?: DoctorWhereUniqueInput
  }

  export type PatientCreateNestedOneWithoutAppointmentInput = {
    create?: XOR<PatientCreateWithoutAppointmentInput, PatientUncheckedCreateWithoutAppointmentInput>
    connectOrCreate?: PatientCreateOrConnectWithoutAppointmentInput
    connect?: PatientWhereUniqueInput
  }

  export type EnumAppointmentStatusFieldUpdateOperationsInput = {
    set?: AppointmentStatus
  }

  export type DoctorUpdateOneRequiredWithoutAppointmentsNestedInput = {
    create?: XOR<DoctorCreateWithoutAppointmentsInput, DoctorUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutAppointmentsInput
    upsert?: DoctorUpsertWithoutAppointmentsInput
    connect?: DoctorWhereUniqueInput
    update?: XOR<DoctorUpdateWithoutAppointmentsInput, DoctorUncheckedUpdateWithoutAppointmentsInput>
  }

  export type PatientUpdateOneRequiredWithoutAppointmentNestedInput = {
    create?: XOR<PatientCreateWithoutAppointmentInput, PatientUncheckedCreateWithoutAppointmentInput>
    connectOrCreate?: PatientCreateOrConnectWithoutAppointmentInput
    upsert?: PatientUpsertWithoutAppointmentInput
    connect?: PatientWhereUniqueInput
    update?: XOR<PatientUpdateWithoutAppointmentInput, PatientUncheckedUpdateWithoutAppointmentInput>
  }

  export type SpecialtyCreateNestedOneWithoutDoctorsInput = {
    create?: XOR<SpecialtyCreateWithoutDoctorsInput, SpecialtyUncheckedCreateWithoutDoctorsInput>
    connectOrCreate?: SpecialtyCreateOrConnectWithoutDoctorsInput
    connect?: SpecialtyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDoctorDataInput = {
    create?: XOR<UserCreateWithoutDoctorDataInput, UserUncheckedCreateWithoutDoctorDataInput>
    connectOrCreate?: UserCreateOrConnectWithoutDoctorDataInput
    connect?: UserWhereUniqueInput
  }

  export type AnamnesisCreateNestedManyWithoutDoctorInput = {
    create?: XOR<Enumerable<AnamnesisCreateWithoutDoctorInput>, Enumerable<AnamnesisUncheckedCreateWithoutDoctorInput>>
    connectOrCreate?: Enumerable<AnamnesisCreateOrConnectWithoutDoctorInput>
    createMany?: AnamnesisCreateManyDoctorInputEnvelope
    connect?: Enumerable<AnamnesisWhereUniqueInput>
  }

  export type EvaluationCreateNestedManyWithoutDoctorInput = {
    create?: XOR<Enumerable<EvaluationCreateWithoutDoctorInput>, Enumerable<EvaluationUncheckedCreateWithoutDoctorInput>>
    connectOrCreate?: Enumerable<EvaluationCreateOrConnectWithoutDoctorInput>
    createMany?: EvaluationCreateManyDoctorInputEnvelope
    connect?: Enumerable<EvaluationWhereUniqueInput>
  }

  export type DoctorPatientCreateNestedManyWithoutDoctorInput = {
    create?: XOR<Enumerable<DoctorPatientCreateWithoutDoctorInput>, Enumerable<DoctorPatientUncheckedCreateWithoutDoctorInput>>
    connectOrCreate?: Enumerable<DoctorPatientCreateOrConnectWithoutDoctorInput>
    createMany?: DoctorPatientCreateManyDoctorInputEnvelope
    connect?: Enumerable<DoctorPatientWhereUniqueInput>
  }

  export type TemplateCreateNestedManyWithoutDoctorInput = {
    create?: XOR<Enumerable<TemplateCreateWithoutDoctorInput>, Enumerable<TemplateUncheckedCreateWithoutDoctorInput>>
    connectOrCreate?: Enumerable<TemplateCreateOrConnectWithoutDoctorInput>
    createMany?: TemplateCreateManyDoctorInputEnvelope
    connect?: Enumerable<TemplateWhereUniqueInput>
  }

  export type EvolutionCreateNestedManyWithoutDoctorInput = {
    create?: XOR<Enumerable<EvolutionCreateWithoutDoctorInput>, Enumerable<EvolutionUncheckedCreateWithoutDoctorInput>>
    connectOrCreate?: Enumerable<EvolutionCreateOrConnectWithoutDoctorInput>
    createMany?: EvolutionCreateManyDoctorInputEnvelope
    connect?: Enumerable<EvolutionWhereUniqueInput>
  }

  export type AppointmentCreateNestedManyWithoutDoctorInput = {
    create?: XOR<Enumerable<AppointmentCreateWithoutDoctorInput>, Enumerable<AppointmentUncheckedCreateWithoutDoctorInput>>
    connectOrCreate?: Enumerable<AppointmentCreateOrConnectWithoutDoctorInput>
    createMany?: AppointmentCreateManyDoctorInputEnvelope
    connect?: Enumerable<AppointmentWhereUniqueInput>
  }

  export type AnamnesisUncheckedCreateNestedManyWithoutDoctorInput = {
    create?: XOR<Enumerable<AnamnesisCreateWithoutDoctorInput>, Enumerable<AnamnesisUncheckedCreateWithoutDoctorInput>>
    connectOrCreate?: Enumerable<AnamnesisCreateOrConnectWithoutDoctorInput>
    createMany?: AnamnesisCreateManyDoctorInputEnvelope
    connect?: Enumerable<AnamnesisWhereUniqueInput>
  }

  export type EvaluationUncheckedCreateNestedManyWithoutDoctorInput = {
    create?: XOR<Enumerable<EvaluationCreateWithoutDoctorInput>, Enumerable<EvaluationUncheckedCreateWithoutDoctorInput>>
    connectOrCreate?: Enumerable<EvaluationCreateOrConnectWithoutDoctorInput>
    createMany?: EvaluationCreateManyDoctorInputEnvelope
    connect?: Enumerable<EvaluationWhereUniqueInput>
  }

  export type DoctorPatientUncheckedCreateNestedManyWithoutDoctorInput = {
    create?: XOR<Enumerable<DoctorPatientCreateWithoutDoctorInput>, Enumerable<DoctorPatientUncheckedCreateWithoutDoctorInput>>
    connectOrCreate?: Enumerable<DoctorPatientCreateOrConnectWithoutDoctorInput>
    createMany?: DoctorPatientCreateManyDoctorInputEnvelope
    connect?: Enumerable<DoctorPatientWhereUniqueInput>
  }

  export type TemplateUncheckedCreateNestedManyWithoutDoctorInput = {
    create?: XOR<Enumerable<TemplateCreateWithoutDoctorInput>, Enumerable<TemplateUncheckedCreateWithoutDoctorInput>>
    connectOrCreate?: Enumerable<TemplateCreateOrConnectWithoutDoctorInput>
    createMany?: TemplateCreateManyDoctorInputEnvelope
    connect?: Enumerable<TemplateWhereUniqueInput>
  }

  export type EvolutionUncheckedCreateNestedManyWithoutDoctorInput = {
    create?: XOR<Enumerable<EvolutionCreateWithoutDoctorInput>, Enumerable<EvolutionUncheckedCreateWithoutDoctorInput>>
    connectOrCreate?: Enumerable<EvolutionCreateOrConnectWithoutDoctorInput>
    createMany?: EvolutionCreateManyDoctorInputEnvelope
    connect?: Enumerable<EvolutionWhereUniqueInput>
  }

  export type AppointmentUncheckedCreateNestedManyWithoutDoctorInput = {
    create?: XOR<Enumerable<AppointmentCreateWithoutDoctorInput>, Enumerable<AppointmentUncheckedCreateWithoutDoctorInput>>
    connectOrCreate?: Enumerable<AppointmentCreateOrConnectWithoutDoctorInput>
    createMany?: AppointmentCreateManyDoctorInputEnvelope
    connect?: Enumerable<AppointmentWhereUniqueInput>
  }

  export type SpecialtyUpdateOneRequiredWithoutDoctorsNestedInput = {
    create?: XOR<SpecialtyCreateWithoutDoctorsInput, SpecialtyUncheckedCreateWithoutDoctorsInput>
    connectOrCreate?: SpecialtyCreateOrConnectWithoutDoctorsInput
    upsert?: SpecialtyUpsertWithoutDoctorsInput
    connect?: SpecialtyWhereUniqueInput
    update?: XOR<SpecialtyUpdateWithoutDoctorsInput, SpecialtyUncheckedUpdateWithoutDoctorsInput>
  }

  export type UserUpdateOneRequiredWithoutDoctorDataNestedInput = {
    create?: XOR<UserCreateWithoutDoctorDataInput, UserUncheckedCreateWithoutDoctorDataInput>
    connectOrCreate?: UserCreateOrConnectWithoutDoctorDataInput
    upsert?: UserUpsertWithoutDoctorDataInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutDoctorDataInput, UserUncheckedUpdateWithoutDoctorDataInput>
  }

  export type AnamnesisUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<Enumerable<AnamnesisCreateWithoutDoctorInput>, Enumerable<AnamnesisUncheckedCreateWithoutDoctorInput>>
    connectOrCreate?: Enumerable<AnamnesisCreateOrConnectWithoutDoctorInput>
    upsert?: Enumerable<AnamnesisUpsertWithWhereUniqueWithoutDoctorInput>
    createMany?: AnamnesisCreateManyDoctorInputEnvelope
    set?: Enumerable<AnamnesisWhereUniqueInput>
    disconnect?: Enumerable<AnamnesisWhereUniqueInput>
    delete?: Enumerable<AnamnesisWhereUniqueInput>
    connect?: Enumerable<AnamnesisWhereUniqueInput>
    update?: Enumerable<AnamnesisUpdateWithWhereUniqueWithoutDoctorInput>
    updateMany?: Enumerable<AnamnesisUpdateManyWithWhereWithoutDoctorInput>
    deleteMany?: Enumerable<AnamnesisScalarWhereInput>
  }

  export type EvaluationUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<Enumerable<EvaluationCreateWithoutDoctorInput>, Enumerable<EvaluationUncheckedCreateWithoutDoctorInput>>
    connectOrCreate?: Enumerable<EvaluationCreateOrConnectWithoutDoctorInput>
    upsert?: Enumerable<EvaluationUpsertWithWhereUniqueWithoutDoctorInput>
    createMany?: EvaluationCreateManyDoctorInputEnvelope
    set?: Enumerable<EvaluationWhereUniqueInput>
    disconnect?: Enumerable<EvaluationWhereUniqueInput>
    delete?: Enumerable<EvaluationWhereUniqueInput>
    connect?: Enumerable<EvaluationWhereUniqueInput>
    update?: Enumerable<EvaluationUpdateWithWhereUniqueWithoutDoctorInput>
    updateMany?: Enumerable<EvaluationUpdateManyWithWhereWithoutDoctorInput>
    deleteMany?: Enumerable<EvaluationScalarWhereInput>
  }

  export type DoctorPatientUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<Enumerable<DoctorPatientCreateWithoutDoctorInput>, Enumerable<DoctorPatientUncheckedCreateWithoutDoctorInput>>
    connectOrCreate?: Enumerable<DoctorPatientCreateOrConnectWithoutDoctorInput>
    upsert?: Enumerable<DoctorPatientUpsertWithWhereUniqueWithoutDoctorInput>
    createMany?: DoctorPatientCreateManyDoctorInputEnvelope
    set?: Enumerable<DoctorPatientWhereUniqueInput>
    disconnect?: Enumerable<DoctorPatientWhereUniqueInput>
    delete?: Enumerable<DoctorPatientWhereUniqueInput>
    connect?: Enumerable<DoctorPatientWhereUniqueInput>
    update?: Enumerable<DoctorPatientUpdateWithWhereUniqueWithoutDoctorInput>
    updateMany?: Enumerable<DoctorPatientUpdateManyWithWhereWithoutDoctorInput>
    deleteMany?: Enumerable<DoctorPatientScalarWhereInput>
  }

  export type TemplateUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<Enumerable<TemplateCreateWithoutDoctorInput>, Enumerable<TemplateUncheckedCreateWithoutDoctorInput>>
    connectOrCreate?: Enumerable<TemplateCreateOrConnectWithoutDoctorInput>
    upsert?: Enumerable<TemplateUpsertWithWhereUniqueWithoutDoctorInput>
    createMany?: TemplateCreateManyDoctorInputEnvelope
    set?: Enumerable<TemplateWhereUniqueInput>
    disconnect?: Enumerable<TemplateWhereUniqueInput>
    delete?: Enumerable<TemplateWhereUniqueInput>
    connect?: Enumerable<TemplateWhereUniqueInput>
    update?: Enumerable<TemplateUpdateWithWhereUniqueWithoutDoctorInput>
    updateMany?: Enumerable<TemplateUpdateManyWithWhereWithoutDoctorInput>
    deleteMany?: Enumerable<TemplateScalarWhereInput>
  }

  export type EvolutionUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<Enumerable<EvolutionCreateWithoutDoctorInput>, Enumerable<EvolutionUncheckedCreateWithoutDoctorInput>>
    connectOrCreate?: Enumerable<EvolutionCreateOrConnectWithoutDoctorInput>
    upsert?: Enumerable<EvolutionUpsertWithWhereUniqueWithoutDoctorInput>
    createMany?: EvolutionCreateManyDoctorInputEnvelope
    set?: Enumerable<EvolutionWhereUniqueInput>
    disconnect?: Enumerable<EvolutionWhereUniqueInput>
    delete?: Enumerable<EvolutionWhereUniqueInput>
    connect?: Enumerable<EvolutionWhereUniqueInput>
    update?: Enumerable<EvolutionUpdateWithWhereUniqueWithoutDoctorInput>
    updateMany?: Enumerable<EvolutionUpdateManyWithWhereWithoutDoctorInput>
    deleteMany?: Enumerable<EvolutionScalarWhereInput>
  }

  export type AppointmentUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<Enumerable<AppointmentCreateWithoutDoctorInput>, Enumerable<AppointmentUncheckedCreateWithoutDoctorInput>>
    connectOrCreate?: Enumerable<AppointmentCreateOrConnectWithoutDoctorInput>
    upsert?: Enumerable<AppointmentUpsertWithWhereUniqueWithoutDoctorInput>
    createMany?: AppointmentCreateManyDoctorInputEnvelope
    set?: Enumerable<AppointmentWhereUniqueInput>
    disconnect?: Enumerable<AppointmentWhereUniqueInput>
    delete?: Enumerable<AppointmentWhereUniqueInput>
    connect?: Enumerable<AppointmentWhereUniqueInput>
    update?: Enumerable<AppointmentUpdateWithWhereUniqueWithoutDoctorInput>
    updateMany?: Enumerable<AppointmentUpdateManyWithWhereWithoutDoctorInput>
    deleteMany?: Enumerable<AppointmentScalarWhereInput>
  }

  export type AnamnesisUncheckedUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<Enumerable<AnamnesisCreateWithoutDoctorInput>, Enumerable<AnamnesisUncheckedCreateWithoutDoctorInput>>
    connectOrCreate?: Enumerable<AnamnesisCreateOrConnectWithoutDoctorInput>
    upsert?: Enumerable<AnamnesisUpsertWithWhereUniqueWithoutDoctorInput>
    createMany?: AnamnesisCreateManyDoctorInputEnvelope
    set?: Enumerable<AnamnesisWhereUniqueInput>
    disconnect?: Enumerable<AnamnesisWhereUniqueInput>
    delete?: Enumerable<AnamnesisWhereUniqueInput>
    connect?: Enumerable<AnamnesisWhereUniqueInput>
    update?: Enumerable<AnamnesisUpdateWithWhereUniqueWithoutDoctorInput>
    updateMany?: Enumerable<AnamnesisUpdateManyWithWhereWithoutDoctorInput>
    deleteMany?: Enumerable<AnamnesisScalarWhereInput>
  }

  export type EvaluationUncheckedUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<Enumerable<EvaluationCreateWithoutDoctorInput>, Enumerable<EvaluationUncheckedCreateWithoutDoctorInput>>
    connectOrCreate?: Enumerable<EvaluationCreateOrConnectWithoutDoctorInput>
    upsert?: Enumerable<EvaluationUpsertWithWhereUniqueWithoutDoctorInput>
    createMany?: EvaluationCreateManyDoctorInputEnvelope
    set?: Enumerable<EvaluationWhereUniqueInput>
    disconnect?: Enumerable<EvaluationWhereUniqueInput>
    delete?: Enumerable<EvaluationWhereUniqueInput>
    connect?: Enumerable<EvaluationWhereUniqueInput>
    update?: Enumerable<EvaluationUpdateWithWhereUniqueWithoutDoctorInput>
    updateMany?: Enumerable<EvaluationUpdateManyWithWhereWithoutDoctorInput>
    deleteMany?: Enumerable<EvaluationScalarWhereInput>
  }

  export type DoctorPatientUncheckedUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<Enumerable<DoctorPatientCreateWithoutDoctorInput>, Enumerable<DoctorPatientUncheckedCreateWithoutDoctorInput>>
    connectOrCreate?: Enumerable<DoctorPatientCreateOrConnectWithoutDoctorInput>
    upsert?: Enumerable<DoctorPatientUpsertWithWhereUniqueWithoutDoctorInput>
    createMany?: DoctorPatientCreateManyDoctorInputEnvelope
    set?: Enumerable<DoctorPatientWhereUniqueInput>
    disconnect?: Enumerable<DoctorPatientWhereUniqueInput>
    delete?: Enumerable<DoctorPatientWhereUniqueInput>
    connect?: Enumerable<DoctorPatientWhereUniqueInput>
    update?: Enumerable<DoctorPatientUpdateWithWhereUniqueWithoutDoctorInput>
    updateMany?: Enumerable<DoctorPatientUpdateManyWithWhereWithoutDoctorInput>
    deleteMany?: Enumerable<DoctorPatientScalarWhereInput>
  }

  export type TemplateUncheckedUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<Enumerable<TemplateCreateWithoutDoctorInput>, Enumerable<TemplateUncheckedCreateWithoutDoctorInput>>
    connectOrCreate?: Enumerable<TemplateCreateOrConnectWithoutDoctorInput>
    upsert?: Enumerable<TemplateUpsertWithWhereUniqueWithoutDoctorInput>
    createMany?: TemplateCreateManyDoctorInputEnvelope
    set?: Enumerable<TemplateWhereUniqueInput>
    disconnect?: Enumerable<TemplateWhereUniqueInput>
    delete?: Enumerable<TemplateWhereUniqueInput>
    connect?: Enumerable<TemplateWhereUniqueInput>
    update?: Enumerable<TemplateUpdateWithWhereUniqueWithoutDoctorInput>
    updateMany?: Enumerable<TemplateUpdateManyWithWhereWithoutDoctorInput>
    deleteMany?: Enumerable<TemplateScalarWhereInput>
  }

  export type EvolutionUncheckedUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<Enumerable<EvolutionCreateWithoutDoctorInput>, Enumerable<EvolutionUncheckedCreateWithoutDoctorInput>>
    connectOrCreate?: Enumerable<EvolutionCreateOrConnectWithoutDoctorInput>
    upsert?: Enumerable<EvolutionUpsertWithWhereUniqueWithoutDoctorInput>
    createMany?: EvolutionCreateManyDoctorInputEnvelope
    set?: Enumerable<EvolutionWhereUniqueInput>
    disconnect?: Enumerable<EvolutionWhereUniqueInput>
    delete?: Enumerable<EvolutionWhereUniqueInput>
    connect?: Enumerable<EvolutionWhereUniqueInput>
    update?: Enumerable<EvolutionUpdateWithWhereUniqueWithoutDoctorInput>
    updateMany?: Enumerable<EvolutionUpdateManyWithWhereWithoutDoctorInput>
    deleteMany?: Enumerable<EvolutionScalarWhereInput>
  }

  export type AppointmentUncheckedUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<Enumerable<AppointmentCreateWithoutDoctorInput>, Enumerable<AppointmentUncheckedCreateWithoutDoctorInput>>
    connectOrCreate?: Enumerable<AppointmentCreateOrConnectWithoutDoctorInput>
    upsert?: Enumerable<AppointmentUpsertWithWhereUniqueWithoutDoctorInput>
    createMany?: AppointmentCreateManyDoctorInputEnvelope
    set?: Enumerable<AppointmentWhereUniqueInput>
    disconnect?: Enumerable<AppointmentWhereUniqueInput>
    delete?: Enumerable<AppointmentWhereUniqueInput>
    connect?: Enumerable<AppointmentWhereUniqueInput>
    update?: Enumerable<AppointmentUpdateWithWhereUniqueWithoutDoctorInput>
    updateMany?: Enumerable<AppointmentUpdateManyWithWhereWithoutDoctorInput>
    deleteMany?: Enumerable<AppointmentScalarWhereInput>
  }

  export type DoctorCreateNestedOneWithoutDoctorPatientInput = {
    create?: XOR<DoctorCreateWithoutDoctorPatientInput, DoctorUncheckedCreateWithoutDoctorPatientInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutDoctorPatientInput
    connect?: DoctorWhereUniqueInput
  }

  export type PatientCreateNestedOneWithoutDoctorPatientInput = {
    create?: XOR<PatientCreateWithoutDoctorPatientInput, PatientUncheckedCreateWithoutDoctorPatientInput>
    connectOrCreate?: PatientCreateOrConnectWithoutDoctorPatientInput
    connect?: PatientWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDoctorPatientInput = {
    create?: XOR<UserCreateWithoutDoctorPatientInput, UserUncheckedCreateWithoutDoctorPatientInput>
    connectOrCreate?: UserCreateOrConnectWithoutDoctorPatientInput
    connect?: UserWhereUniqueInput
  }

  export type DoctorUpdateOneRequiredWithoutDoctorPatientNestedInput = {
    create?: XOR<DoctorCreateWithoutDoctorPatientInput, DoctorUncheckedCreateWithoutDoctorPatientInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutDoctorPatientInput
    upsert?: DoctorUpsertWithoutDoctorPatientInput
    connect?: DoctorWhereUniqueInput
    update?: XOR<DoctorUpdateWithoutDoctorPatientInput, DoctorUncheckedUpdateWithoutDoctorPatientInput>
  }

  export type PatientUpdateOneRequiredWithoutDoctorPatientNestedInput = {
    create?: XOR<PatientCreateWithoutDoctorPatientInput, PatientUncheckedCreateWithoutDoctorPatientInput>
    connectOrCreate?: PatientCreateOrConnectWithoutDoctorPatientInput
    upsert?: PatientUpsertWithoutDoctorPatientInput
    connect?: PatientWhereUniqueInput
    update?: XOR<PatientUpdateWithoutDoctorPatientInput, PatientUncheckedUpdateWithoutDoctorPatientInput>
  }

  export type UserUpdateOneRequiredWithoutDoctorPatientNestedInput = {
    create?: XOR<UserCreateWithoutDoctorPatientInput, UserUncheckedCreateWithoutDoctorPatientInput>
    connectOrCreate?: UserCreateOrConnectWithoutDoctorPatientInput
    upsert?: UserUpsertWithoutDoctorPatientInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutDoctorPatientInput, UserUncheckedUpdateWithoutDoctorPatientInput>
  }

  export type DoctorCreateNestedManyWithoutSpecialtyInput = {
    create?: XOR<Enumerable<DoctorCreateWithoutSpecialtyInput>, Enumerable<DoctorUncheckedCreateWithoutSpecialtyInput>>
    connectOrCreate?: Enumerable<DoctorCreateOrConnectWithoutSpecialtyInput>
    createMany?: DoctorCreateManySpecialtyInputEnvelope
    connect?: Enumerable<DoctorWhereUniqueInput>
  }

  export type TemplateCreateNestedManyWithoutSpecialtyInput = {
    create?: XOR<Enumerable<TemplateCreateWithoutSpecialtyInput>, Enumerable<TemplateUncheckedCreateWithoutSpecialtyInput>>
    connectOrCreate?: Enumerable<TemplateCreateOrConnectWithoutSpecialtyInput>
    createMany?: TemplateCreateManySpecialtyInputEnvelope
    connect?: Enumerable<TemplateWhereUniqueInput>
  }

  export type EvaluationCreateNestedManyWithoutSpecialtyInput = {
    create?: XOR<Enumerable<EvaluationCreateWithoutSpecialtyInput>, Enumerable<EvaluationUncheckedCreateWithoutSpecialtyInput>>
    connectOrCreate?: Enumerable<EvaluationCreateOrConnectWithoutSpecialtyInput>
    createMany?: EvaluationCreateManySpecialtyInputEnvelope
    connect?: Enumerable<EvaluationWhereUniqueInput>
  }

  export type AnamnesisCreateNestedManyWithoutSpecialtyInput = {
    create?: XOR<Enumerable<AnamnesisCreateWithoutSpecialtyInput>, Enumerable<AnamnesisUncheckedCreateWithoutSpecialtyInput>>
    connectOrCreate?: Enumerable<AnamnesisCreateOrConnectWithoutSpecialtyInput>
    createMany?: AnamnesisCreateManySpecialtyInputEnvelope
    connect?: Enumerable<AnamnesisWhereUniqueInput>
  }

  export type EvolutionCreateNestedManyWithoutSpecialtyInput = {
    create?: XOR<Enumerable<EvolutionCreateWithoutSpecialtyInput>, Enumerable<EvolutionUncheckedCreateWithoutSpecialtyInput>>
    connectOrCreate?: Enumerable<EvolutionCreateOrConnectWithoutSpecialtyInput>
    createMany?: EvolutionCreateManySpecialtyInputEnvelope
    connect?: Enumerable<EvolutionWhereUniqueInput>
  }

  export type ExerciseCreateNestedManyWithoutSpecialtyInput = {
    create?: XOR<Enumerable<ExerciseCreateWithoutSpecialtyInput>, Enumerable<ExerciseUncheckedCreateWithoutSpecialtyInput>>
    connectOrCreate?: Enumerable<ExerciseCreateOrConnectWithoutSpecialtyInput>
    createMany?: ExerciseCreateManySpecialtyInputEnvelope
    connect?: Enumerable<ExerciseWhereUniqueInput>
  }

  export type CourseCreateNestedManyWithoutSpecialtyInput = {
    create?: XOR<Enumerable<CourseCreateWithoutSpecialtyInput>, Enumerable<CourseUncheckedCreateWithoutSpecialtyInput>>
    connectOrCreate?: Enumerable<CourseCreateOrConnectWithoutSpecialtyInput>
    createMany?: CourseCreateManySpecialtyInputEnvelope
    connect?: Enumerable<CourseWhereUniqueInput>
  }

  export type DoctorUncheckedCreateNestedManyWithoutSpecialtyInput = {
    create?: XOR<Enumerable<DoctorCreateWithoutSpecialtyInput>, Enumerable<DoctorUncheckedCreateWithoutSpecialtyInput>>
    connectOrCreate?: Enumerable<DoctorCreateOrConnectWithoutSpecialtyInput>
    createMany?: DoctorCreateManySpecialtyInputEnvelope
    connect?: Enumerable<DoctorWhereUniqueInput>
  }

  export type TemplateUncheckedCreateNestedManyWithoutSpecialtyInput = {
    create?: XOR<Enumerable<TemplateCreateWithoutSpecialtyInput>, Enumerable<TemplateUncheckedCreateWithoutSpecialtyInput>>
    connectOrCreate?: Enumerable<TemplateCreateOrConnectWithoutSpecialtyInput>
    createMany?: TemplateCreateManySpecialtyInputEnvelope
    connect?: Enumerable<TemplateWhereUniqueInput>
  }

  export type EvaluationUncheckedCreateNestedManyWithoutSpecialtyInput = {
    create?: XOR<Enumerable<EvaluationCreateWithoutSpecialtyInput>, Enumerable<EvaluationUncheckedCreateWithoutSpecialtyInput>>
    connectOrCreate?: Enumerable<EvaluationCreateOrConnectWithoutSpecialtyInput>
    createMany?: EvaluationCreateManySpecialtyInputEnvelope
    connect?: Enumerable<EvaluationWhereUniqueInput>
  }

  export type AnamnesisUncheckedCreateNestedManyWithoutSpecialtyInput = {
    create?: XOR<Enumerable<AnamnesisCreateWithoutSpecialtyInput>, Enumerable<AnamnesisUncheckedCreateWithoutSpecialtyInput>>
    connectOrCreate?: Enumerable<AnamnesisCreateOrConnectWithoutSpecialtyInput>
    createMany?: AnamnesisCreateManySpecialtyInputEnvelope
    connect?: Enumerable<AnamnesisWhereUniqueInput>
  }

  export type EvolutionUncheckedCreateNestedManyWithoutSpecialtyInput = {
    create?: XOR<Enumerable<EvolutionCreateWithoutSpecialtyInput>, Enumerable<EvolutionUncheckedCreateWithoutSpecialtyInput>>
    connectOrCreate?: Enumerable<EvolutionCreateOrConnectWithoutSpecialtyInput>
    createMany?: EvolutionCreateManySpecialtyInputEnvelope
    connect?: Enumerable<EvolutionWhereUniqueInput>
  }

  export type ExerciseUncheckedCreateNestedManyWithoutSpecialtyInput = {
    create?: XOR<Enumerable<ExerciseCreateWithoutSpecialtyInput>, Enumerable<ExerciseUncheckedCreateWithoutSpecialtyInput>>
    connectOrCreate?: Enumerable<ExerciseCreateOrConnectWithoutSpecialtyInput>
    createMany?: ExerciseCreateManySpecialtyInputEnvelope
    connect?: Enumerable<ExerciseWhereUniqueInput>
  }

  export type CourseUncheckedCreateNestedManyWithoutSpecialtyInput = {
    create?: XOR<Enumerable<CourseCreateWithoutSpecialtyInput>, Enumerable<CourseUncheckedCreateWithoutSpecialtyInput>>
    connectOrCreate?: Enumerable<CourseCreateOrConnectWithoutSpecialtyInput>
    createMany?: CourseCreateManySpecialtyInputEnvelope
    connect?: Enumerable<CourseWhereUniqueInput>
  }

  export type DoctorUpdateManyWithoutSpecialtyNestedInput = {
    create?: XOR<Enumerable<DoctorCreateWithoutSpecialtyInput>, Enumerable<DoctorUncheckedCreateWithoutSpecialtyInput>>
    connectOrCreate?: Enumerable<DoctorCreateOrConnectWithoutSpecialtyInput>
    upsert?: Enumerable<DoctorUpsertWithWhereUniqueWithoutSpecialtyInput>
    createMany?: DoctorCreateManySpecialtyInputEnvelope
    set?: Enumerable<DoctorWhereUniqueInput>
    disconnect?: Enumerable<DoctorWhereUniqueInput>
    delete?: Enumerable<DoctorWhereUniqueInput>
    connect?: Enumerable<DoctorWhereUniqueInput>
    update?: Enumerable<DoctorUpdateWithWhereUniqueWithoutSpecialtyInput>
    updateMany?: Enumerable<DoctorUpdateManyWithWhereWithoutSpecialtyInput>
    deleteMany?: Enumerable<DoctorScalarWhereInput>
  }

  export type TemplateUpdateManyWithoutSpecialtyNestedInput = {
    create?: XOR<Enumerable<TemplateCreateWithoutSpecialtyInput>, Enumerable<TemplateUncheckedCreateWithoutSpecialtyInput>>
    connectOrCreate?: Enumerable<TemplateCreateOrConnectWithoutSpecialtyInput>
    upsert?: Enumerable<TemplateUpsertWithWhereUniqueWithoutSpecialtyInput>
    createMany?: TemplateCreateManySpecialtyInputEnvelope
    set?: Enumerable<TemplateWhereUniqueInput>
    disconnect?: Enumerable<TemplateWhereUniqueInput>
    delete?: Enumerable<TemplateWhereUniqueInput>
    connect?: Enumerable<TemplateWhereUniqueInput>
    update?: Enumerable<TemplateUpdateWithWhereUniqueWithoutSpecialtyInput>
    updateMany?: Enumerable<TemplateUpdateManyWithWhereWithoutSpecialtyInput>
    deleteMany?: Enumerable<TemplateScalarWhereInput>
  }

  export type EvaluationUpdateManyWithoutSpecialtyNestedInput = {
    create?: XOR<Enumerable<EvaluationCreateWithoutSpecialtyInput>, Enumerable<EvaluationUncheckedCreateWithoutSpecialtyInput>>
    connectOrCreate?: Enumerable<EvaluationCreateOrConnectWithoutSpecialtyInput>
    upsert?: Enumerable<EvaluationUpsertWithWhereUniqueWithoutSpecialtyInput>
    createMany?: EvaluationCreateManySpecialtyInputEnvelope
    set?: Enumerable<EvaluationWhereUniqueInput>
    disconnect?: Enumerable<EvaluationWhereUniqueInput>
    delete?: Enumerable<EvaluationWhereUniqueInput>
    connect?: Enumerable<EvaluationWhereUniqueInput>
    update?: Enumerable<EvaluationUpdateWithWhereUniqueWithoutSpecialtyInput>
    updateMany?: Enumerable<EvaluationUpdateManyWithWhereWithoutSpecialtyInput>
    deleteMany?: Enumerable<EvaluationScalarWhereInput>
  }

  export type AnamnesisUpdateManyWithoutSpecialtyNestedInput = {
    create?: XOR<Enumerable<AnamnesisCreateWithoutSpecialtyInput>, Enumerable<AnamnesisUncheckedCreateWithoutSpecialtyInput>>
    connectOrCreate?: Enumerable<AnamnesisCreateOrConnectWithoutSpecialtyInput>
    upsert?: Enumerable<AnamnesisUpsertWithWhereUniqueWithoutSpecialtyInput>
    createMany?: AnamnesisCreateManySpecialtyInputEnvelope
    set?: Enumerable<AnamnesisWhereUniqueInput>
    disconnect?: Enumerable<AnamnesisWhereUniqueInput>
    delete?: Enumerable<AnamnesisWhereUniqueInput>
    connect?: Enumerable<AnamnesisWhereUniqueInput>
    update?: Enumerable<AnamnesisUpdateWithWhereUniqueWithoutSpecialtyInput>
    updateMany?: Enumerable<AnamnesisUpdateManyWithWhereWithoutSpecialtyInput>
    deleteMany?: Enumerable<AnamnesisScalarWhereInput>
  }

  export type EvolutionUpdateManyWithoutSpecialtyNestedInput = {
    create?: XOR<Enumerable<EvolutionCreateWithoutSpecialtyInput>, Enumerable<EvolutionUncheckedCreateWithoutSpecialtyInput>>
    connectOrCreate?: Enumerable<EvolutionCreateOrConnectWithoutSpecialtyInput>
    upsert?: Enumerable<EvolutionUpsertWithWhereUniqueWithoutSpecialtyInput>
    createMany?: EvolutionCreateManySpecialtyInputEnvelope
    set?: Enumerable<EvolutionWhereUniqueInput>
    disconnect?: Enumerable<EvolutionWhereUniqueInput>
    delete?: Enumerable<EvolutionWhereUniqueInput>
    connect?: Enumerable<EvolutionWhereUniqueInput>
    update?: Enumerable<EvolutionUpdateWithWhereUniqueWithoutSpecialtyInput>
    updateMany?: Enumerable<EvolutionUpdateManyWithWhereWithoutSpecialtyInput>
    deleteMany?: Enumerable<EvolutionScalarWhereInput>
  }

  export type ExerciseUpdateManyWithoutSpecialtyNestedInput = {
    create?: XOR<Enumerable<ExerciseCreateWithoutSpecialtyInput>, Enumerable<ExerciseUncheckedCreateWithoutSpecialtyInput>>
    connectOrCreate?: Enumerable<ExerciseCreateOrConnectWithoutSpecialtyInput>
    upsert?: Enumerable<ExerciseUpsertWithWhereUniqueWithoutSpecialtyInput>
    createMany?: ExerciseCreateManySpecialtyInputEnvelope
    set?: Enumerable<ExerciseWhereUniqueInput>
    disconnect?: Enumerable<ExerciseWhereUniqueInput>
    delete?: Enumerable<ExerciseWhereUniqueInput>
    connect?: Enumerable<ExerciseWhereUniqueInput>
    update?: Enumerable<ExerciseUpdateWithWhereUniqueWithoutSpecialtyInput>
    updateMany?: Enumerable<ExerciseUpdateManyWithWhereWithoutSpecialtyInput>
    deleteMany?: Enumerable<ExerciseScalarWhereInput>
  }

  export type CourseUpdateManyWithoutSpecialtyNestedInput = {
    create?: XOR<Enumerable<CourseCreateWithoutSpecialtyInput>, Enumerable<CourseUncheckedCreateWithoutSpecialtyInput>>
    connectOrCreate?: Enumerable<CourseCreateOrConnectWithoutSpecialtyInput>
    upsert?: Enumerable<CourseUpsertWithWhereUniqueWithoutSpecialtyInput>
    createMany?: CourseCreateManySpecialtyInputEnvelope
    set?: Enumerable<CourseWhereUniqueInput>
    disconnect?: Enumerable<CourseWhereUniqueInput>
    delete?: Enumerable<CourseWhereUniqueInput>
    connect?: Enumerable<CourseWhereUniqueInput>
    update?: Enumerable<CourseUpdateWithWhereUniqueWithoutSpecialtyInput>
    updateMany?: Enumerable<CourseUpdateManyWithWhereWithoutSpecialtyInput>
    deleteMany?: Enumerable<CourseScalarWhereInput>
  }

  export type DoctorUncheckedUpdateManyWithoutSpecialtyNestedInput = {
    create?: XOR<Enumerable<DoctorCreateWithoutSpecialtyInput>, Enumerable<DoctorUncheckedCreateWithoutSpecialtyInput>>
    connectOrCreate?: Enumerable<DoctorCreateOrConnectWithoutSpecialtyInput>
    upsert?: Enumerable<DoctorUpsertWithWhereUniqueWithoutSpecialtyInput>
    createMany?: DoctorCreateManySpecialtyInputEnvelope
    set?: Enumerable<DoctorWhereUniqueInput>
    disconnect?: Enumerable<DoctorWhereUniqueInput>
    delete?: Enumerable<DoctorWhereUniqueInput>
    connect?: Enumerable<DoctorWhereUniqueInput>
    update?: Enumerable<DoctorUpdateWithWhereUniqueWithoutSpecialtyInput>
    updateMany?: Enumerable<DoctorUpdateManyWithWhereWithoutSpecialtyInput>
    deleteMany?: Enumerable<DoctorScalarWhereInput>
  }

  export type TemplateUncheckedUpdateManyWithoutSpecialtyNestedInput = {
    create?: XOR<Enumerable<TemplateCreateWithoutSpecialtyInput>, Enumerable<TemplateUncheckedCreateWithoutSpecialtyInput>>
    connectOrCreate?: Enumerable<TemplateCreateOrConnectWithoutSpecialtyInput>
    upsert?: Enumerable<TemplateUpsertWithWhereUniqueWithoutSpecialtyInput>
    createMany?: TemplateCreateManySpecialtyInputEnvelope
    set?: Enumerable<TemplateWhereUniqueInput>
    disconnect?: Enumerable<TemplateWhereUniqueInput>
    delete?: Enumerable<TemplateWhereUniqueInput>
    connect?: Enumerable<TemplateWhereUniqueInput>
    update?: Enumerable<TemplateUpdateWithWhereUniqueWithoutSpecialtyInput>
    updateMany?: Enumerable<TemplateUpdateManyWithWhereWithoutSpecialtyInput>
    deleteMany?: Enumerable<TemplateScalarWhereInput>
  }

  export type EvaluationUncheckedUpdateManyWithoutSpecialtyNestedInput = {
    create?: XOR<Enumerable<EvaluationCreateWithoutSpecialtyInput>, Enumerable<EvaluationUncheckedCreateWithoutSpecialtyInput>>
    connectOrCreate?: Enumerable<EvaluationCreateOrConnectWithoutSpecialtyInput>
    upsert?: Enumerable<EvaluationUpsertWithWhereUniqueWithoutSpecialtyInput>
    createMany?: EvaluationCreateManySpecialtyInputEnvelope
    set?: Enumerable<EvaluationWhereUniqueInput>
    disconnect?: Enumerable<EvaluationWhereUniqueInput>
    delete?: Enumerable<EvaluationWhereUniqueInput>
    connect?: Enumerable<EvaluationWhereUniqueInput>
    update?: Enumerable<EvaluationUpdateWithWhereUniqueWithoutSpecialtyInput>
    updateMany?: Enumerable<EvaluationUpdateManyWithWhereWithoutSpecialtyInput>
    deleteMany?: Enumerable<EvaluationScalarWhereInput>
  }

  export type AnamnesisUncheckedUpdateManyWithoutSpecialtyNestedInput = {
    create?: XOR<Enumerable<AnamnesisCreateWithoutSpecialtyInput>, Enumerable<AnamnesisUncheckedCreateWithoutSpecialtyInput>>
    connectOrCreate?: Enumerable<AnamnesisCreateOrConnectWithoutSpecialtyInput>
    upsert?: Enumerable<AnamnesisUpsertWithWhereUniqueWithoutSpecialtyInput>
    createMany?: AnamnesisCreateManySpecialtyInputEnvelope
    set?: Enumerable<AnamnesisWhereUniqueInput>
    disconnect?: Enumerable<AnamnesisWhereUniqueInput>
    delete?: Enumerable<AnamnesisWhereUniqueInput>
    connect?: Enumerable<AnamnesisWhereUniqueInput>
    update?: Enumerable<AnamnesisUpdateWithWhereUniqueWithoutSpecialtyInput>
    updateMany?: Enumerable<AnamnesisUpdateManyWithWhereWithoutSpecialtyInput>
    deleteMany?: Enumerable<AnamnesisScalarWhereInput>
  }

  export type EvolutionUncheckedUpdateManyWithoutSpecialtyNestedInput = {
    create?: XOR<Enumerable<EvolutionCreateWithoutSpecialtyInput>, Enumerable<EvolutionUncheckedCreateWithoutSpecialtyInput>>
    connectOrCreate?: Enumerable<EvolutionCreateOrConnectWithoutSpecialtyInput>
    upsert?: Enumerable<EvolutionUpsertWithWhereUniqueWithoutSpecialtyInput>
    createMany?: EvolutionCreateManySpecialtyInputEnvelope
    set?: Enumerable<EvolutionWhereUniqueInput>
    disconnect?: Enumerable<EvolutionWhereUniqueInput>
    delete?: Enumerable<EvolutionWhereUniqueInput>
    connect?: Enumerable<EvolutionWhereUniqueInput>
    update?: Enumerable<EvolutionUpdateWithWhereUniqueWithoutSpecialtyInput>
    updateMany?: Enumerable<EvolutionUpdateManyWithWhereWithoutSpecialtyInput>
    deleteMany?: Enumerable<EvolutionScalarWhereInput>
  }

  export type ExerciseUncheckedUpdateManyWithoutSpecialtyNestedInput = {
    create?: XOR<Enumerable<ExerciseCreateWithoutSpecialtyInput>, Enumerable<ExerciseUncheckedCreateWithoutSpecialtyInput>>
    connectOrCreate?: Enumerable<ExerciseCreateOrConnectWithoutSpecialtyInput>
    upsert?: Enumerable<ExerciseUpsertWithWhereUniqueWithoutSpecialtyInput>
    createMany?: ExerciseCreateManySpecialtyInputEnvelope
    set?: Enumerable<ExerciseWhereUniqueInput>
    disconnect?: Enumerable<ExerciseWhereUniqueInput>
    delete?: Enumerable<ExerciseWhereUniqueInput>
    connect?: Enumerable<ExerciseWhereUniqueInput>
    update?: Enumerable<ExerciseUpdateWithWhereUniqueWithoutSpecialtyInput>
    updateMany?: Enumerable<ExerciseUpdateManyWithWhereWithoutSpecialtyInput>
    deleteMany?: Enumerable<ExerciseScalarWhereInput>
  }

  export type CourseUncheckedUpdateManyWithoutSpecialtyNestedInput = {
    create?: XOR<Enumerable<CourseCreateWithoutSpecialtyInput>, Enumerable<CourseUncheckedCreateWithoutSpecialtyInput>>
    connectOrCreate?: Enumerable<CourseCreateOrConnectWithoutSpecialtyInput>
    upsert?: Enumerable<CourseUpsertWithWhereUniqueWithoutSpecialtyInput>
    createMany?: CourseCreateManySpecialtyInputEnvelope
    set?: Enumerable<CourseWhereUniqueInput>
    disconnect?: Enumerable<CourseWhereUniqueInput>
    delete?: Enumerable<CourseWhereUniqueInput>
    connect?: Enumerable<CourseWhereUniqueInput>
    update?: Enumerable<CourseUpdateWithWhereUniqueWithoutSpecialtyInput>
    updateMany?: Enumerable<CourseUpdateManyWithWhereWithoutSpecialtyInput>
    deleteMany?: Enumerable<CourseScalarWhereInput>
  }

  export type PatientCreateNestedOneWithoutAnamnesisInput = {
    create?: XOR<PatientCreateWithoutAnamnesisInput, PatientUncheckedCreateWithoutAnamnesisInput>
    connectOrCreate?: PatientCreateOrConnectWithoutAnamnesisInput
    connect?: PatientWhereUniqueInput
  }

  export type DoctorCreateNestedOneWithoutAnamnesisInput = {
    create?: XOR<DoctorCreateWithoutAnamnesisInput, DoctorUncheckedCreateWithoutAnamnesisInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutAnamnesisInput
    connect?: DoctorWhereUniqueInput
  }

  export type SpecialtyCreateNestedOneWithoutAnamnesisInput = {
    create?: XOR<SpecialtyCreateWithoutAnamnesisInput, SpecialtyUncheckedCreateWithoutAnamnesisInput>
    connectOrCreate?: SpecialtyCreateOrConnectWithoutAnamnesisInput
    connect?: SpecialtyWhereUniqueInput
  }

  export type PatientUpdateOneRequiredWithoutAnamnesisNestedInput = {
    create?: XOR<PatientCreateWithoutAnamnesisInput, PatientUncheckedCreateWithoutAnamnesisInput>
    connectOrCreate?: PatientCreateOrConnectWithoutAnamnesisInput
    upsert?: PatientUpsertWithoutAnamnesisInput
    connect?: PatientWhereUniqueInput
    update?: XOR<PatientUpdateWithoutAnamnesisInput, PatientUncheckedUpdateWithoutAnamnesisInput>
  }

  export type DoctorUpdateOneRequiredWithoutAnamnesisNestedInput = {
    create?: XOR<DoctorCreateWithoutAnamnesisInput, DoctorUncheckedCreateWithoutAnamnesisInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutAnamnesisInput
    upsert?: DoctorUpsertWithoutAnamnesisInput
    connect?: DoctorWhereUniqueInput
    update?: XOR<DoctorUpdateWithoutAnamnesisInput, DoctorUncheckedUpdateWithoutAnamnesisInput>
  }

  export type SpecialtyUpdateOneRequiredWithoutAnamnesisNestedInput = {
    create?: XOR<SpecialtyCreateWithoutAnamnesisInput, SpecialtyUncheckedCreateWithoutAnamnesisInput>
    connectOrCreate?: SpecialtyCreateOrConnectWithoutAnamnesisInput
    upsert?: SpecialtyUpsertWithoutAnamnesisInput
    connect?: SpecialtyWhereUniqueInput
    update?: XOR<SpecialtyUpdateWithoutAnamnesisInput, SpecialtyUncheckedUpdateWithoutAnamnesisInput>
  }

  export type PatientCreateNestedOneWithoutEvolutionsInput = {
    create?: XOR<PatientCreateWithoutEvolutionsInput, PatientUncheckedCreateWithoutEvolutionsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutEvolutionsInput
    connect?: PatientWhereUniqueInput
  }

  export type DoctorCreateNestedOneWithoutEvolutionsInput = {
    create?: XOR<DoctorCreateWithoutEvolutionsInput, DoctorUncheckedCreateWithoutEvolutionsInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutEvolutionsInput
    connect?: DoctorWhereUniqueInput
  }

  export type SpecialtyCreateNestedOneWithoutEvolutionInput = {
    create?: XOR<SpecialtyCreateWithoutEvolutionInput, SpecialtyUncheckedCreateWithoutEvolutionInput>
    connectOrCreate?: SpecialtyCreateOrConnectWithoutEvolutionInput
    connect?: SpecialtyWhereUniqueInput
  }

  export type PatientUpdateOneRequiredWithoutEvolutionsNestedInput = {
    create?: XOR<PatientCreateWithoutEvolutionsInput, PatientUncheckedCreateWithoutEvolutionsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutEvolutionsInput
    upsert?: PatientUpsertWithoutEvolutionsInput
    connect?: PatientWhereUniqueInput
    update?: XOR<PatientUpdateWithoutEvolutionsInput, PatientUncheckedUpdateWithoutEvolutionsInput>
  }

  export type DoctorUpdateOneRequiredWithoutEvolutionsNestedInput = {
    create?: XOR<DoctorCreateWithoutEvolutionsInput, DoctorUncheckedCreateWithoutEvolutionsInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutEvolutionsInput
    upsert?: DoctorUpsertWithoutEvolutionsInput
    connect?: DoctorWhereUniqueInput
    update?: XOR<DoctorUpdateWithoutEvolutionsInput, DoctorUncheckedUpdateWithoutEvolutionsInput>
  }

  export type SpecialtyUpdateOneRequiredWithoutEvolutionNestedInput = {
    create?: XOR<SpecialtyCreateWithoutEvolutionInput, SpecialtyUncheckedCreateWithoutEvolutionInput>
    connectOrCreate?: SpecialtyCreateOrConnectWithoutEvolutionInput
    upsert?: SpecialtyUpsertWithoutEvolutionInput
    connect?: SpecialtyWhereUniqueInput
    update?: XOR<SpecialtyUpdateWithoutEvolutionInput, SpecialtyUncheckedUpdateWithoutEvolutionInput>
  }

  export type PatientCreateNestedOneWithoutEvaluationsInput = {
    create?: XOR<PatientCreateWithoutEvaluationsInput, PatientUncheckedCreateWithoutEvaluationsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutEvaluationsInput
    connect?: PatientWhereUniqueInput
  }

  export type DoctorCreateNestedOneWithoutEvaluationsInput = {
    create?: XOR<DoctorCreateWithoutEvaluationsInput, DoctorUncheckedCreateWithoutEvaluationsInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutEvaluationsInput
    connect?: DoctorWhereUniqueInput
  }

  export type SpecialtyCreateNestedOneWithoutEvaluationsInput = {
    create?: XOR<SpecialtyCreateWithoutEvaluationsInput, SpecialtyUncheckedCreateWithoutEvaluationsInput>
    connectOrCreate?: SpecialtyCreateOrConnectWithoutEvaluationsInput
    connect?: SpecialtyWhereUniqueInput
  }

  export type PatientUpdateOneRequiredWithoutEvaluationsNestedInput = {
    create?: XOR<PatientCreateWithoutEvaluationsInput, PatientUncheckedCreateWithoutEvaluationsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutEvaluationsInput
    upsert?: PatientUpsertWithoutEvaluationsInput
    connect?: PatientWhereUniqueInput
    update?: XOR<PatientUpdateWithoutEvaluationsInput, PatientUncheckedUpdateWithoutEvaluationsInput>
  }

  export type DoctorUpdateOneRequiredWithoutEvaluationsNestedInput = {
    create?: XOR<DoctorCreateWithoutEvaluationsInput, DoctorUncheckedCreateWithoutEvaluationsInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutEvaluationsInput
    upsert?: DoctorUpsertWithoutEvaluationsInput
    connect?: DoctorWhereUniqueInput
    update?: XOR<DoctorUpdateWithoutEvaluationsInput, DoctorUncheckedUpdateWithoutEvaluationsInput>
  }

  export type SpecialtyUpdateOneRequiredWithoutEvaluationsNestedInput = {
    create?: XOR<SpecialtyCreateWithoutEvaluationsInput, SpecialtyUncheckedCreateWithoutEvaluationsInput>
    connectOrCreate?: SpecialtyCreateOrConnectWithoutEvaluationsInput
    upsert?: SpecialtyUpsertWithoutEvaluationsInput
    connect?: SpecialtyWhereUniqueInput
    update?: XOR<SpecialtyUpdateWithoutEvaluationsInput, SpecialtyUncheckedUpdateWithoutEvaluationsInput>
  }

  export type UserCreateNestedOneWithoutExercisesInput = {
    create?: XOR<UserCreateWithoutExercisesInput, UserUncheckedCreateWithoutExercisesInput>
    connectOrCreate?: UserCreateOrConnectWithoutExercisesInput
    connect?: UserWhereUniqueInput
  }

  export type SpecialtyCreateNestedOneWithoutExerciseInput = {
    create?: XOR<SpecialtyCreateWithoutExerciseInput, SpecialtyUncheckedCreateWithoutExerciseInput>
    connectOrCreate?: SpecialtyCreateOrConnectWithoutExerciseInput
    connect?: SpecialtyWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutExercisesNestedInput = {
    create?: XOR<UserCreateWithoutExercisesInput, UserUncheckedCreateWithoutExercisesInput>
    connectOrCreate?: UserCreateOrConnectWithoutExercisesInput
    upsert?: UserUpsertWithoutExercisesInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutExercisesInput, UserUncheckedUpdateWithoutExercisesInput>
  }

  export type SpecialtyUpdateOneRequiredWithoutExerciseNestedInput = {
    create?: XOR<SpecialtyCreateWithoutExerciseInput, SpecialtyUncheckedCreateWithoutExerciseInput>
    connectOrCreate?: SpecialtyCreateOrConnectWithoutExerciseInput
    upsert?: SpecialtyUpsertWithoutExerciseInput
    connect?: SpecialtyWhereUniqueInput
    update?: XOR<SpecialtyUpdateWithoutExerciseInput, SpecialtyUncheckedUpdateWithoutExerciseInput>
  }

  export type DoctorCreateNestedOneWithoutTemplatesInput = {
    create?: XOR<DoctorCreateWithoutTemplatesInput, DoctorUncheckedCreateWithoutTemplatesInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutTemplatesInput
    connect?: DoctorWhereUniqueInput
  }

  export type SpecialtyCreateNestedOneWithoutTemplatesInput = {
    create?: XOR<SpecialtyCreateWithoutTemplatesInput, SpecialtyUncheckedCreateWithoutTemplatesInput>
    connectOrCreate?: SpecialtyCreateOrConnectWithoutTemplatesInput
    connect?: SpecialtyWhereUniqueInput
  }

  export type EnumTemplateTypeFieldUpdateOperationsInput = {
    set?: TemplateType
  }

  export type DoctorUpdateOneRequiredWithoutTemplatesNestedInput = {
    create?: XOR<DoctorCreateWithoutTemplatesInput, DoctorUncheckedCreateWithoutTemplatesInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutTemplatesInput
    upsert?: DoctorUpsertWithoutTemplatesInput
    connect?: DoctorWhereUniqueInput
    update?: XOR<DoctorUpdateWithoutTemplatesInput, DoctorUncheckedUpdateWithoutTemplatesInput>
  }

  export type SpecialtyUpdateOneRequiredWithoutTemplatesNestedInput = {
    create?: XOR<SpecialtyCreateWithoutTemplatesInput, SpecialtyUncheckedCreateWithoutTemplatesInput>
    connectOrCreate?: SpecialtyCreateOrConnectWithoutTemplatesInput
    upsert?: SpecialtyUpsertWithoutTemplatesInput
    connect?: SpecialtyWhereUniqueInput
    update?: XOR<SpecialtyUpdateWithoutTemplatesInput, SpecialtyUncheckedUpdateWithoutTemplatesInput>
  }

  export type UserCreateNestedOneWithoutCoursesInput = {
    create?: XOR<UserCreateWithoutCoursesInput, UserUncheckedCreateWithoutCoursesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCoursesInput
    connect?: UserWhereUniqueInput
  }

  export type SpecialtyCreateNestedOneWithoutCourseInput = {
    create?: XOR<SpecialtyCreateWithoutCourseInput, SpecialtyUncheckedCreateWithoutCourseInput>
    connectOrCreate?: SpecialtyCreateOrConnectWithoutCourseInput
    connect?: SpecialtyWhereUniqueInput
  }

  export type LessonCreateNestedManyWithoutCourseInput = {
    create?: XOR<Enumerable<LessonCreateWithoutCourseInput>, Enumerable<LessonUncheckedCreateWithoutCourseInput>>
    connectOrCreate?: Enumerable<LessonCreateOrConnectWithoutCourseInput>
    createMany?: LessonCreateManyCourseInputEnvelope
    connect?: Enumerable<LessonWhereUniqueInput>
  }

  export type LessonUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<Enumerable<LessonCreateWithoutCourseInput>, Enumerable<LessonUncheckedCreateWithoutCourseInput>>
    connectOrCreate?: Enumerable<LessonCreateOrConnectWithoutCourseInput>
    createMany?: LessonCreateManyCourseInputEnvelope
    connect?: Enumerable<LessonWhereUniqueInput>
  }

  export type UserUpdateOneRequiredWithoutCoursesNestedInput = {
    create?: XOR<UserCreateWithoutCoursesInput, UserUncheckedCreateWithoutCoursesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCoursesInput
    upsert?: UserUpsertWithoutCoursesInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutCoursesInput, UserUncheckedUpdateWithoutCoursesInput>
  }

  export type SpecialtyUpdateOneRequiredWithoutCourseNestedInput = {
    create?: XOR<SpecialtyCreateWithoutCourseInput, SpecialtyUncheckedCreateWithoutCourseInput>
    connectOrCreate?: SpecialtyCreateOrConnectWithoutCourseInput
    upsert?: SpecialtyUpsertWithoutCourseInput
    connect?: SpecialtyWhereUniqueInput
    update?: XOR<SpecialtyUpdateWithoutCourseInput, SpecialtyUncheckedUpdateWithoutCourseInput>
  }

  export type LessonUpdateManyWithoutCourseNestedInput = {
    create?: XOR<Enumerable<LessonCreateWithoutCourseInput>, Enumerable<LessonUncheckedCreateWithoutCourseInput>>
    connectOrCreate?: Enumerable<LessonCreateOrConnectWithoutCourseInput>
    upsert?: Enumerable<LessonUpsertWithWhereUniqueWithoutCourseInput>
    createMany?: LessonCreateManyCourseInputEnvelope
    set?: Enumerable<LessonWhereUniqueInput>
    disconnect?: Enumerable<LessonWhereUniqueInput>
    delete?: Enumerable<LessonWhereUniqueInput>
    connect?: Enumerable<LessonWhereUniqueInput>
    update?: Enumerable<LessonUpdateWithWhereUniqueWithoutCourseInput>
    updateMany?: Enumerable<LessonUpdateManyWithWhereWithoutCourseInput>
    deleteMany?: Enumerable<LessonScalarWhereInput>
  }

  export type LessonUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<Enumerable<LessonCreateWithoutCourseInput>, Enumerable<LessonUncheckedCreateWithoutCourseInput>>
    connectOrCreate?: Enumerable<LessonCreateOrConnectWithoutCourseInput>
    upsert?: Enumerable<LessonUpsertWithWhereUniqueWithoutCourseInput>
    createMany?: LessonCreateManyCourseInputEnvelope
    set?: Enumerable<LessonWhereUniqueInput>
    disconnect?: Enumerable<LessonWhereUniqueInput>
    delete?: Enumerable<LessonWhereUniqueInput>
    connect?: Enumerable<LessonWhereUniqueInput>
    update?: Enumerable<LessonUpdateWithWhereUniqueWithoutCourseInput>
    updateMany?: Enumerable<LessonUpdateManyWithWhereWithoutCourseInput>
    deleteMany?: Enumerable<LessonScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutLessonsInput = {
    create?: XOR<UserCreateWithoutLessonsInput, UserUncheckedCreateWithoutLessonsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLessonsInput
    connect?: UserWhereUniqueInput
  }

  export type CourseCreateNestedOneWithoutLessonsInput = {
    create?: XOR<CourseCreateWithoutLessonsInput, CourseUncheckedCreateWithoutLessonsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutLessonsInput
    connect?: CourseWhereUniqueInput
  }

  export type LessonVideoCreateNestedManyWithoutLessonInput = {
    create?: XOR<Enumerable<LessonVideoCreateWithoutLessonInput>, Enumerable<LessonVideoUncheckedCreateWithoutLessonInput>>
    connectOrCreate?: Enumerable<LessonVideoCreateOrConnectWithoutLessonInput>
    createMany?: LessonVideoCreateManyLessonInputEnvelope
    connect?: Enumerable<LessonVideoWhereUniqueInput>
  }

  export type LessonVideoUncheckedCreateNestedManyWithoutLessonInput = {
    create?: XOR<Enumerable<LessonVideoCreateWithoutLessonInput>, Enumerable<LessonVideoUncheckedCreateWithoutLessonInput>>
    connectOrCreate?: Enumerable<LessonVideoCreateOrConnectWithoutLessonInput>
    createMany?: LessonVideoCreateManyLessonInputEnvelope
    connect?: Enumerable<LessonVideoWhereUniqueInput>
  }

  export type UserUpdateOneRequiredWithoutLessonsNestedInput = {
    create?: XOR<UserCreateWithoutLessonsInput, UserUncheckedCreateWithoutLessonsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLessonsInput
    upsert?: UserUpsertWithoutLessonsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutLessonsInput, UserUncheckedUpdateWithoutLessonsInput>
  }

  export type CourseUpdateOneRequiredWithoutLessonsNestedInput = {
    create?: XOR<CourseCreateWithoutLessonsInput, CourseUncheckedCreateWithoutLessonsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutLessonsInput
    upsert?: CourseUpsertWithoutLessonsInput
    connect?: CourseWhereUniqueInput
    update?: XOR<CourseUpdateWithoutLessonsInput, CourseUncheckedUpdateWithoutLessonsInput>
  }

  export type LessonVideoUpdateManyWithoutLessonNestedInput = {
    create?: XOR<Enumerable<LessonVideoCreateWithoutLessonInput>, Enumerable<LessonVideoUncheckedCreateWithoutLessonInput>>
    connectOrCreate?: Enumerable<LessonVideoCreateOrConnectWithoutLessonInput>
    upsert?: Enumerable<LessonVideoUpsertWithWhereUniqueWithoutLessonInput>
    createMany?: LessonVideoCreateManyLessonInputEnvelope
    set?: Enumerable<LessonVideoWhereUniqueInput>
    disconnect?: Enumerable<LessonVideoWhereUniqueInput>
    delete?: Enumerable<LessonVideoWhereUniqueInput>
    connect?: Enumerable<LessonVideoWhereUniqueInput>
    update?: Enumerable<LessonVideoUpdateWithWhereUniqueWithoutLessonInput>
    updateMany?: Enumerable<LessonVideoUpdateManyWithWhereWithoutLessonInput>
    deleteMany?: Enumerable<LessonVideoScalarWhereInput>
  }

  export type LessonVideoUncheckedUpdateManyWithoutLessonNestedInput = {
    create?: XOR<Enumerable<LessonVideoCreateWithoutLessonInput>, Enumerable<LessonVideoUncheckedCreateWithoutLessonInput>>
    connectOrCreate?: Enumerable<LessonVideoCreateOrConnectWithoutLessonInput>
    upsert?: Enumerable<LessonVideoUpsertWithWhereUniqueWithoutLessonInput>
    createMany?: LessonVideoCreateManyLessonInputEnvelope
    set?: Enumerable<LessonVideoWhereUniqueInput>
    disconnect?: Enumerable<LessonVideoWhereUniqueInput>
    delete?: Enumerable<LessonVideoWhereUniqueInput>
    connect?: Enumerable<LessonVideoWhereUniqueInput>
    update?: Enumerable<LessonVideoUpdateWithWhereUniqueWithoutLessonInput>
    updateMany?: Enumerable<LessonVideoUpdateManyWithWhereWithoutLessonInput>
    deleteMany?: Enumerable<LessonVideoScalarWhereInput>
  }

  export type LessonCreateNestedOneWithoutVideosInput = {
    create?: XOR<LessonCreateWithoutVideosInput, LessonUncheckedCreateWithoutVideosInput>
    connectOrCreate?: LessonCreateOrConnectWithoutVideosInput
    connect?: LessonWhereUniqueInput
  }

  export type WatchedVideoCreateNestedManyWithoutVideoInput = {
    create?: XOR<Enumerable<WatchedVideoCreateWithoutVideoInput>, Enumerable<WatchedVideoUncheckedCreateWithoutVideoInput>>
    connectOrCreate?: Enumerable<WatchedVideoCreateOrConnectWithoutVideoInput>
    createMany?: WatchedVideoCreateManyVideoInputEnvelope
    connect?: Enumerable<WatchedVideoWhereUniqueInput>
  }

  export type WatchedVideoUncheckedCreateNestedManyWithoutVideoInput = {
    create?: XOR<Enumerable<WatchedVideoCreateWithoutVideoInput>, Enumerable<WatchedVideoUncheckedCreateWithoutVideoInput>>
    connectOrCreate?: Enumerable<WatchedVideoCreateOrConnectWithoutVideoInput>
    createMany?: WatchedVideoCreateManyVideoInputEnvelope
    connect?: Enumerable<WatchedVideoWhereUniqueInput>
  }

  export type LessonUpdateOneRequiredWithoutVideosNestedInput = {
    create?: XOR<LessonCreateWithoutVideosInput, LessonUncheckedCreateWithoutVideosInput>
    connectOrCreate?: LessonCreateOrConnectWithoutVideosInput
    upsert?: LessonUpsertWithoutVideosInput
    connect?: LessonWhereUniqueInput
    update?: XOR<LessonUpdateWithoutVideosInput, LessonUncheckedUpdateWithoutVideosInput>
  }

  export type WatchedVideoUpdateManyWithoutVideoNestedInput = {
    create?: XOR<Enumerable<WatchedVideoCreateWithoutVideoInput>, Enumerable<WatchedVideoUncheckedCreateWithoutVideoInput>>
    connectOrCreate?: Enumerable<WatchedVideoCreateOrConnectWithoutVideoInput>
    upsert?: Enumerable<WatchedVideoUpsertWithWhereUniqueWithoutVideoInput>
    createMany?: WatchedVideoCreateManyVideoInputEnvelope
    set?: Enumerable<WatchedVideoWhereUniqueInput>
    disconnect?: Enumerable<WatchedVideoWhereUniqueInput>
    delete?: Enumerable<WatchedVideoWhereUniqueInput>
    connect?: Enumerable<WatchedVideoWhereUniqueInput>
    update?: Enumerable<WatchedVideoUpdateWithWhereUniqueWithoutVideoInput>
    updateMany?: Enumerable<WatchedVideoUpdateManyWithWhereWithoutVideoInput>
    deleteMany?: Enumerable<WatchedVideoScalarWhereInput>
  }

  export type WatchedVideoUncheckedUpdateManyWithoutVideoNestedInput = {
    create?: XOR<Enumerable<WatchedVideoCreateWithoutVideoInput>, Enumerable<WatchedVideoUncheckedCreateWithoutVideoInput>>
    connectOrCreate?: Enumerable<WatchedVideoCreateOrConnectWithoutVideoInput>
    upsert?: Enumerable<WatchedVideoUpsertWithWhereUniqueWithoutVideoInput>
    createMany?: WatchedVideoCreateManyVideoInputEnvelope
    set?: Enumerable<WatchedVideoWhereUniqueInput>
    disconnect?: Enumerable<WatchedVideoWhereUniqueInput>
    delete?: Enumerable<WatchedVideoWhereUniqueInput>
    connect?: Enumerable<WatchedVideoWhereUniqueInput>
    update?: Enumerable<WatchedVideoUpdateWithWhereUniqueWithoutVideoInput>
    updateMany?: Enumerable<WatchedVideoUpdateManyWithWhereWithoutVideoInput>
    deleteMany?: Enumerable<WatchedVideoScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutWatchedInput = {
    create?: XOR<UserCreateWithoutWatchedInput, UserUncheckedCreateWithoutWatchedInput>
    connectOrCreate?: UserCreateOrConnectWithoutWatchedInput
    connect?: UserWhereUniqueInput
  }

  export type LessonVideoCreateNestedOneWithoutWatchedInput = {
    create?: XOR<LessonVideoCreateWithoutWatchedInput, LessonVideoUncheckedCreateWithoutWatchedInput>
    connectOrCreate?: LessonVideoCreateOrConnectWithoutWatchedInput
    connect?: LessonVideoWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutWatchedNestedInput = {
    create?: XOR<UserCreateWithoutWatchedInput, UserUncheckedCreateWithoutWatchedInput>
    connectOrCreate?: UserCreateOrConnectWithoutWatchedInput
    upsert?: UserUpsertWithoutWatchedInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutWatchedInput, UserUncheckedUpdateWithoutWatchedInput>
  }

  export type LessonVideoUpdateOneRequiredWithoutWatchedNestedInput = {
    create?: XOR<LessonVideoCreateWithoutWatchedInput, LessonVideoUncheckedCreateWithoutWatchedInput>
    connectOrCreate?: LessonVideoCreateOrConnectWithoutWatchedInput
    upsert?: LessonVideoUpsertWithoutWatchedInput
    connect?: LessonVideoWhereUniqueInput
    update?: XOR<LessonVideoUpdateWithoutWatchedInput, LessonVideoUncheckedUpdateWithoutWatchedInput>
  }

  export type NestedUuidFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    not?: NestedUuidFilter | string
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedEnumUserTypeFilter = {
    equals?: UserType
    in?: Enumerable<UserType>
    notIn?: Enumerable<UserType>
    not?: NestedEnumUserTypeFilter | UserType
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedUuidWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    not?: NestedUuidWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type NestedEnumUserTypeWithAggregatesFilter = {
    equals?: UserType
    in?: Enumerable<UserType>
    notIn?: Enumerable<UserType>
    not?: NestedEnumUserTypeWithAggregatesFilter | UserType
    _count?: NestedIntFilter
    _min?: NestedEnumUserTypeFilter
    _max?: NestedEnumUserTypeFilter
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedEnumAppointmentStatusFilter = {
    equals?: AppointmentStatus
    in?: Enumerable<AppointmentStatus>
    notIn?: Enumerable<AppointmentStatus>
    not?: NestedEnumAppointmentStatusFilter | AppointmentStatus
  }

  export type NestedEnumAppointmentStatusWithAggregatesFilter = {
    equals?: AppointmentStatus
    in?: Enumerable<AppointmentStatus>
    notIn?: Enumerable<AppointmentStatus>
    not?: NestedEnumAppointmentStatusWithAggregatesFilter | AppointmentStatus
    _count?: NestedIntFilter
    _min?: NestedEnumAppointmentStatusFilter
    _max?: NestedEnumAppointmentStatusFilter
  }
  export type NestedJsonFilter = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase>, Exclude<keyof Required<NestedJsonFilterBase>, 'path'>>,
        Required<NestedJsonFilterBase>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase>, 'path'>>

  export type NestedJsonFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: string[]
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
  }

  export type NestedEnumTemplateTypeFilter = {
    equals?: TemplateType
    in?: Enumerable<TemplateType>
    notIn?: Enumerable<TemplateType>
    not?: NestedEnumTemplateTypeFilter | TemplateType
  }

  export type NestedEnumTemplateTypeWithAggregatesFilter = {
    equals?: TemplateType
    in?: Enumerable<TemplateType>
    notIn?: Enumerable<TemplateType>
    not?: NestedEnumTemplateTypeWithAggregatesFilter | TemplateType
    _count?: NestedIntFilter
    _min?: NestedEnumTemplateTypeFilter
    _max?: NestedEnumTemplateTypeFilter
  }

  export type PatientCreateWithoutUserInput = {
    id?: string
    numericId?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    anamnesis?: AnamnesisCreateNestedManyWithoutPatientInput
    evaluations?: EvaluationCreateNestedManyWithoutPatientInput
    doctorPatient?: DoctorPatientCreateNestedManyWithoutPatientInput
    evolutions?: EvolutionCreateNestedManyWithoutPatientInput
    appointment?: AppointmentCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutUserInput = {
    id?: string
    numericId?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    anamnesis?: AnamnesisUncheckedCreateNestedManyWithoutPatientInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutPatientInput
    doctorPatient?: DoctorPatientUncheckedCreateNestedManyWithoutPatientInput
    evolutions?: EvolutionUncheckedCreateNestedManyWithoutPatientInput
    appointment?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutUserInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutUserInput, PatientUncheckedCreateWithoutUserInput>
  }

  export type DoctorCreateWithoutUserInput = {
    id?: string
    numericId?: number
    crfa?: string | null
    availability?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    specialty: SpecialtyCreateNestedOneWithoutDoctorsInput
    anamnesis?: AnamnesisCreateNestedManyWithoutDoctorInput
    evaluations?: EvaluationCreateNestedManyWithoutDoctorInput
    doctorPatient?: DoctorPatientCreateNestedManyWithoutDoctorInput
    templates?: TemplateCreateNestedManyWithoutDoctorInput
    evolutions?: EvolutionCreateNestedManyWithoutDoctorInput
    appointments?: AppointmentCreateNestedManyWithoutDoctorInput
  }

  export type DoctorUncheckedCreateWithoutUserInput = {
    id?: string
    numericId?: number
    specialtyId: string
    crfa?: string | null
    availability?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    anamnesis?: AnamnesisUncheckedCreateNestedManyWithoutDoctorInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutDoctorInput
    doctorPatient?: DoctorPatientUncheckedCreateNestedManyWithoutDoctorInput
    templates?: TemplateUncheckedCreateNestedManyWithoutDoctorInput
    evolutions?: EvolutionUncheckedCreateNestedManyWithoutDoctorInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
  }

  export type DoctorCreateOrConnectWithoutUserInput = {
    where: DoctorWhereUniqueInput
    create: XOR<DoctorCreateWithoutUserInput, DoctorUncheckedCreateWithoutUserInput>
  }

  export type UserAdressCreateWithoutUserInput = {
    id?: string
    numericId?: number
    streetName: string
    zipCode: string
    district: string
    state: string
    city: string
    number: string
    complement?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type UserAdressUncheckedCreateWithoutUserInput = {
    id?: string
    numericId?: number
    streetName: string
    zipCode: string
    district: string
    state: string
    city: string
    number: string
    complement?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type UserAdressCreateOrConnectWithoutUserInput = {
    where: UserAdressWhereUniqueInput
    create: XOR<UserAdressCreateWithoutUserInput, UserAdressUncheckedCreateWithoutUserInput>
  }

  export type UserAdressCreateManyUserInputEnvelope = {
    data: Enumerable<UserAdressCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type UserContactCreateWithoutUserInput = {
    id?: string
    numericId?: number
    email?: string | null
    area: string
    phone: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type UserContactUncheckedCreateWithoutUserInput = {
    id?: string
    numericId?: number
    email?: string | null
    area: string
    phone: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type UserContactCreateOrConnectWithoutUserInput = {
    where: UserContactWhereUniqueInput
    create: XOR<UserContactCreateWithoutUserInput, UserContactUncheckedCreateWithoutUserInput>
  }

  export type UserContactCreateManyUserInputEnvelope = {
    data: Enumerable<UserContactCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type DoctorPatientCreateWithoutAssignedByInput = {
    createdAt?: Date | string
    active?: boolean
    doctor: DoctorCreateNestedOneWithoutDoctorPatientInput
    patient: PatientCreateNestedOneWithoutDoctorPatientInput
  }

  export type DoctorPatientUncheckedCreateWithoutAssignedByInput = {
    doctorId: string
    patientId: string
    createdAt?: Date | string
    active?: boolean
  }

  export type DoctorPatientCreateOrConnectWithoutAssignedByInput = {
    where: DoctorPatientWhereUniqueInput
    create: XOR<DoctorPatientCreateWithoutAssignedByInput, DoctorPatientUncheckedCreateWithoutAssignedByInput>
  }

  export type DoctorPatientCreateManyAssignedByInputEnvelope = {
    data: Enumerable<DoctorPatientCreateManyAssignedByInput>
    skipDuplicates?: boolean
  }

  export type ExerciseCreateWithoutCreatorInput = {
    id?: string
    numericId?: number
    title: string
    description: string
    links?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    specialty: SpecialtyCreateNestedOneWithoutExerciseInput
  }

  export type ExerciseUncheckedCreateWithoutCreatorInput = {
    id?: string
    numericId?: number
    title: string
    description: string
    links?: JsonNullValueInput | InputJsonValue
    specialtyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExerciseCreateOrConnectWithoutCreatorInput = {
    where: ExerciseWhereUniqueInput
    create: XOR<ExerciseCreateWithoutCreatorInput, ExerciseUncheckedCreateWithoutCreatorInput>
  }

  export type ExerciseCreateManyCreatorInputEnvelope = {
    data: Enumerable<ExerciseCreateManyCreatorInput>
    skipDuplicates?: boolean
  }

  export type CourseCreateWithoutCreatorInput = {
    id?: string
    numericId?: number
    order?: number
    title: string
    cover?: string | null
    description: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    specialty: SpecialtyCreateNestedOneWithoutCourseInput
    lessons?: LessonCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutCreatorInput = {
    id?: string
    numericId?: number
    specialtyId: string
    order?: number
    title: string
    cover?: string | null
    description: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    lessons?: LessonUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutCreatorInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutCreatorInput, CourseUncheckedCreateWithoutCreatorInput>
  }

  export type CourseCreateManyCreatorInputEnvelope = {
    data: Enumerable<CourseCreateManyCreatorInput>
    skipDuplicates?: boolean
  }

  export type LessonCreateWithoutCreatorInput = {
    id?: string
    numericId?: number
    order?: number
    title: string
    description: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    course: CourseCreateNestedOneWithoutLessonsInput
    videos?: LessonVideoCreateNestedManyWithoutLessonInput
  }

  export type LessonUncheckedCreateWithoutCreatorInput = {
    id?: string
    numericId?: number
    courseId: string
    order?: number
    title: string
    description: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    videos?: LessonVideoUncheckedCreateNestedManyWithoutLessonInput
  }

  export type LessonCreateOrConnectWithoutCreatorInput = {
    where: LessonWhereUniqueInput
    create: XOR<LessonCreateWithoutCreatorInput, LessonUncheckedCreateWithoutCreatorInput>
  }

  export type LessonCreateManyCreatorInputEnvelope = {
    data: Enumerable<LessonCreateManyCreatorInput>
    skipDuplicates?: boolean
  }

  export type WatchedVideoCreateWithoutUserInput = {
    id?: string
    numericId?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    video: LessonVideoCreateNestedOneWithoutWatchedInput
  }

  export type WatchedVideoUncheckedCreateWithoutUserInput = {
    id?: string
    numericId?: number
    videoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type WatchedVideoCreateOrConnectWithoutUserInput = {
    where: WatchedVideoWhereUniqueInput
    create: XOR<WatchedVideoCreateWithoutUserInput, WatchedVideoUncheckedCreateWithoutUserInput>
  }

  export type WatchedVideoCreateManyUserInputEnvelope = {
    data: Enumerable<WatchedVideoCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type PatientUpsertWithoutUserInput = {
    update: XOR<PatientUpdateWithoutUserInput, PatientUncheckedUpdateWithoutUserInput>
    create: XOR<PatientCreateWithoutUserInput, PatientUncheckedCreateWithoutUserInput>
  }

  export type PatientUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    anamnesis?: AnamnesisUpdateManyWithoutPatientNestedInput
    evaluations?: EvaluationUpdateManyWithoutPatientNestedInput
    doctorPatient?: DoctorPatientUpdateManyWithoutPatientNestedInput
    evolutions?: EvolutionUpdateManyWithoutPatientNestedInput
    appointment?: AppointmentUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    anamnesis?: AnamnesisUncheckedUpdateManyWithoutPatientNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutPatientNestedInput
    doctorPatient?: DoctorPatientUncheckedUpdateManyWithoutPatientNestedInput
    evolutions?: EvolutionUncheckedUpdateManyWithoutPatientNestedInput
    appointment?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type DoctorUpsertWithoutUserInput = {
    update: XOR<DoctorUpdateWithoutUserInput, DoctorUncheckedUpdateWithoutUserInput>
    create: XOR<DoctorCreateWithoutUserInput, DoctorUncheckedCreateWithoutUserInput>
  }

  export type DoctorUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    crfa?: NullableStringFieldUpdateOperationsInput | string | null
    availability?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    specialty?: SpecialtyUpdateOneRequiredWithoutDoctorsNestedInput
    anamnesis?: AnamnesisUpdateManyWithoutDoctorNestedInput
    evaluations?: EvaluationUpdateManyWithoutDoctorNestedInput
    doctorPatient?: DoctorPatientUpdateManyWithoutDoctorNestedInput
    templates?: TemplateUpdateManyWithoutDoctorNestedInput
    evolutions?: EvolutionUpdateManyWithoutDoctorNestedInput
    appointments?: AppointmentUpdateManyWithoutDoctorNestedInput
  }

  export type DoctorUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    specialtyId?: StringFieldUpdateOperationsInput | string
    crfa?: NullableStringFieldUpdateOperationsInput | string | null
    availability?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    anamnesis?: AnamnesisUncheckedUpdateManyWithoutDoctorNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutDoctorNestedInput
    doctorPatient?: DoctorPatientUncheckedUpdateManyWithoutDoctorNestedInput
    templates?: TemplateUncheckedUpdateManyWithoutDoctorNestedInput
    evolutions?: EvolutionUncheckedUpdateManyWithoutDoctorNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
  }

  export type UserAdressUpsertWithWhereUniqueWithoutUserInput = {
    where: UserAdressWhereUniqueInput
    update: XOR<UserAdressUpdateWithoutUserInput, UserAdressUncheckedUpdateWithoutUserInput>
    create: XOR<UserAdressCreateWithoutUserInput, UserAdressUncheckedCreateWithoutUserInput>
  }

  export type UserAdressUpdateWithWhereUniqueWithoutUserInput = {
    where: UserAdressWhereUniqueInput
    data: XOR<UserAdressUpdateWithoutUserInput, UserAdressUncheckedUpdateWithoutUserInput>
  }

  export type UserAdressUpdateManyWithWhereWithoutUserInput = {
    where: UserAdressScalarWhereInput
    data: XOR<UserAdressUpdateManyMutationInput, UserAdressUncheckedUpdateManyWithoutAddressesInput>
  }

  export type UserAdressScalarWhereInput = {
    AND?: Enumerable<UserAdressScalarWhereInput>
    OR?: Enumerable<UserAdressScalarWhereInput>
    NOT?: Enumerable<UserAdressScalarWhereInput>
    id?: UuidFilter | string
    numericId?: IntFilter | number
    userId?: UuidFilter | string
    streetName?: StringFilter | string
    zipCode?: StringFilter | string
    district?: StringFilter | string
    state?: StringFilter | string
    city?: StringFilter | string
    number?: StringFilter | string
    complement?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type UserContactUpsertWithWhereUniqueWithoutUserInput = {
    where: UserContactWhereUniqueInput
    update: XOR<UserContactUpdateWithoutUserInput, UserContactUncheckedUpdateWithoutUserInput>
    create: XOR<UserContactCreateWithoutUserInput, UserContactUncheckedCreateWithoutUserInput>
  }

  export type UserContactUpdateWithWhereUniqueWithoutUserInput = {
    where: UserContactWhereUniqueInput
    data: XOR<UserContactUpdateWithoutUserInput, UserContactUncheckedUpdateWithoutUserInput>
  }

  export type UserContactUpdateManyWithWhereWithoutUserInput = {
    where: UserContactScalarWhereInput
    data: XOR<UserContactUpdateManyMutationInput, UserContactUncheckedUpdateManyWithoutContactsInput>
  }

  export type UserContactScalarWhereInput = {
    AND?: Enumerable<UserContactScalarWhereInput>
    OR?: Enumerable<UserContactScalarWhereInput>
    NOT?: Enumerable<UserContactScalarWhereInput>
    id?: UuidFilter | string
    numericId?: IntFilter | number
    userId?: UuidFilter | string
    email?: StringNullableFilter | string | null
    area?: StringFilter | string
    phone?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type DoctorPatientUpsertWithWhereUniqueWithoutAssignedByInput = {
    where: DoctorPatientWhereUniqueInput
    update: XOR<DoctorPatientUpdateWithoutAssignedByInput, DoctorPatientUncheckedUpdateWithoutAssignedByInput>
    create: XOR<DoctorPatientCreateWithoutAssignedByInput, DoctorPatientUncheckedCreateWithoutAssignedByInput>
  }

  export type DoctorPatientUpdateWithWhereUniqueWithoutAssignedByInput = {
    where: DoctorPatientWhereUniqueInput
    data: XOR<DoctorPatientUpdateWithoutAssignedByInput, DoctorPatientUncheckedUpdateWithoutAssignedByInput>
  }

  export type DoctorPatientUpdateManyWithWhereWithoutAssignedByInput = {
    where: DoctorPatientScalarWhereInput
    data: XOR<DoctorPatientUpdateManyMutationInput, DoctorPatientUncheckedUpdateManyWithoutDoctorPatientInput>
  }

  export type DoctorPatientScalarWhereInput = {
    AND?: Enumerable<DoctorPatientScalarWhereInput>
    OR?: Enumerable<DoctorPatientScalarWhereInput>
    NOT?: Enumerable<DoctorPatientScalarWhereInput>
    doctorId?: UuidFilter | string
    patientId?: UuidFilter | string
    assignedById?: UuidFilter | string
    createdAt?: DateTimeFilter | Date | string
    active?: BoolFilter | boolean
  }

  export type ExerciseUpsertWithWhereUniqueWithoutCreatorInput = {
    where: ExerciseWhereUniqueInput
    update: XOR<ExerciseUpdateWithoutCreatorInput, ExerciseUncheckedUpdateWithoutCreatorInput>
    create: XOR<ExerciseCreateWithoutCreatorInput, ExerciseUncheckedCreateWithoutCreatorInput>
  }

  export type ExerciseUpdateWithWhereUniqueWithoutCreatorInput = {
    where: ExerciseWhereUniqueInput
    data: XOR<ExerciseUpdateWithoutCreatorInput, ExerciseUncheckedUpdateWithoutCreatorInput>
  }

  export type ExerciseUpdateManyWithWhereWithoutCreatorInput = {
    where: ExerciseScalarWhereInput
    data: XOR<ExerciseUpdateManyMutationInput, ExerciseUncheckedUpdateManyWithoutExercisesInput>
  }

  export type ExerciseScalarWhereInput = {
    AND?: Enumerable<ExerciseScalarWhereInput>
    OR?: Enumerable<ExerciseScalarWhereInput>
    NOT?: Enumerable<ExerciseScalarWhereInput>
    id?: UuidFilter | string
    numericId?: IntFilter | number
    title?: StringFilter | string
    description?: StringFilter | string
    links?: JsonFilter
    creatorId?: UuidFilter | string
    specialtyId?: UuidFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
  }

  export type CourseUpsertWithWhereUniqueWithoutCreatorInput = {
    where: CourseWhereUniqueInput
    update: XOR<CourseUpdateWithoutCreatorInput, CourseUncheckedUpdateWithoutCreatorInput>
    create: XOR<CourseCreateWithoutCreatorInput, CourseUncheckedCreateWithoutCreatorInput>
  }

  export type CourseUpdateWithWhereUniqueWithoutCreatorInput = {
    where: CourseWhereUniqueInput
    data: XOR<CourseUpdateWithoutCreatorInput, CourseUncheckedUpdateWithoutCreatorInput>
  }

  export type CourseUpdateManyWithWhereWithoutCreatorInput = {
    where: CourseScalarWhereInput
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyWithoutCoursesInput>
  }

  export type CourseScalarWhereInput = {
    AND?: Enumerable<CourseScalarWhereInput>
    OR?: Enumerable<CourseScalarWhereInput>
    NOT?: Enumerable<CourseScalarWhereInput>
    id?: UuidFilter | string
    numericId?: IntFilter | number
    creatorId?: UuidFilter | string
    specialtyId?: UuidFilter | string
    order?: IntFilter | number
    title?: StringFilter | string
    cover?: StringNullableFilter | string | null
    description?: StringFilter | string
    isActive?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type LessonUpsertWithWhereUniqueWithoutCreatorInput = {
    where: LessonWhereUniqueInput
    update: XOR<LessonUpdateWithoutCreatorInput, LessonUncheckedUpdateWithoutCreatorInput>
    create: XOR<LessonCreateWithoutCreatorInput, LessonUncheckedCreateWithoutCreatorInput>
  }

  export type LessonUpdateWithWhereUniqueWithoutCreatorInput = {
    where: LessonWhereUniqueInput
    data: XOR<LessonUpdateWithoutCreatorInput, LessonUncheckedUpdateWithoutCreatorInput>
  }

  export type LessonUpdateManyWithWhereWithoutCreatorInput = {
    where: LessonScalarWhereInput
    data: XOR<LessonUpdateManyMutationInput, LessonUncheckedUpdateManyWithoutLessonsInput>
  }

  export type LessonScalarWhereInput = {
    AND?: Enumerable<LessonScalarWhereInput>
    OR?: Enumerable<LessonScalarWhereInput>
    NOT?: Enumerable<LessonScalarWhereInput>
    id?: UuidFilter | string
    numericId?: IntFilter | number
    creatorId?: UuidFilter | string
    courseId?: UuidFilter | string
    order?: IntFilter | number
    title?: StringFilter | string
    description?: StringFilter | string
    isActive?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type WatchedVideoUpsertWithWhereUniqueWithoutUserInput = {
    where: WatchedVideoWhereUniqueInput
    update: XOR<WatchedVideoUpdateWithoutUserInput, WatchedVideoUncheckedUpdateWithoutUserInput>
    create: XOR<WatchedVideoCreateWithoutUserInput, WatchedVideoUncheckedCreateWithoutUserInput>
  }

  export type WatchedVideoUpdateWithWhereUniqueWithoutUserInput = {
    where: WatchedVideoWhereUniqueInput
    data: XOR<WatchedVideoUpdateWithoutUserInput, WatchedVideoUncheckedUpdateWithoutUserInput>
  }

  export type WatchedVideoUpdateManyWithWhereWithoutUserInput = {
    where: WatchedVideoScalarWhereInput
    data: XOR<WatchedVideoUpdateManyMutationInput, WatchedVideoUncheckedUpdateManyWithoutWatchedInput>
  }

  export type WatchedVideoScalarWhereInput = {
    AND?: Enumerable<WatchedVideoScalarWhereInput>
    OR?: Enumerable<WatchedVideoScalarWhereInput>
    NOT?: Enumerable<WatchedVideoScalarWhereInput>
    id?: UuidFilter | string
    numericId?: IntFilter | number
    userId?: UuidFilter | string
    videoId?: UuidFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type UserCreateWithoutAddressesInput = {
    id?: string
    numericId?: number
    socialName?: string | null
    email: string
    name: string
    gender?: string | null
    customGender?: string | null
    cpf?: string | null
    birthDate?: Date | string | null
    password: string
    type?: UserType
    avatar?: string | null
    facebookToken?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    isAdmin?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    patientData?: PatientCreateNestedOneWithoutUserInput
    doctorData?: DoctorCreateNestedOneWithoutUserInput
    contacts?: UserContactCreateNestedManyWithoutUserInput
    DoctorPatient?: DoctorPatientCreateNestedManyWithoutAssignedByInput
    exercises?: ExerciseCreateNestedManyWithoutCreatorInput
    courses?: CourseCreateNestedManyWithoutCreatorInput
    lessons?: LessonCreateNestedManyWithoutCreatorInput
    watched?: WatchedVideoCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAddressesInput = {
    id?: string
    numericId?: number
    socialName?: string | null
    email: string
    name: string
    gender?: string | null
    customGender?: string | null
    cpf?: string | null
    birthDate?: Date | string | null
    password: string
    type?: UserType
    avatar?: string | null
    facebookToken?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    isAdmin?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    patientData?: PatientUncheckedCreateNestedOneWithoutUserInput
    doctorData?: DoctorUncheckedCreateNestedOneWithoutUserInput
    contacts?: UserContactUncheckedCreateNestedManyWithoutUserInput
    DoctorPatient?: DoctorPatientUncheckedCreateNestedManyWithoutAssignedByInput
    exercises?: ExerciseUncheckedCreateNestedManyWithoutCreatorInput
    courses?: CourseUncheckedCreateNestedManyWithoutCreatorInput
    lessons?: LessonUncheckedCreateNestedManyWithoutCreatorInput
    watched?: WatchedVideoUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAddressesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAddressesInput, UserUncheckedCreateWithoutAddressesInput>
  }

  export type UserUpsertWithoutAddressesInput = {
    update: XOR<UserUpdateWithoutAddressesInput, UserUncheckedUpdateWithoutAddressesInput>
    create: XOR<UserCreateWithoutAddressesInput, UserUncheckedCreateWithoutAddressesInput>
  }

  export type UserUpdateWithoutAddressesInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    socialName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    customGender?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    type?: EnumUserTypeFieldUpdateOperationsInput | UserType
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    facebookToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patientData?: PatientUpdateOneWithoutUserNestedInput
    doctorData?: DoctorUpdateOneWithoutUserNestedInput
    contacts?: UserContactUpdateManyWithoutUserNestedInput
    DoctorPatient?: DoctorPatientUpdateManyWithoutAssignedByNestedInput
    exercises?: ExerciseUpdateManyWithoutCreatorNestedInput
    courses?: CourseUpdateManyWithoutCreatorNestedInput
    lessons?: LessonUpdateManyWithoutCreatorNestedInput
    watched?: WatchedVideoUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAddressesInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    socialName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    customGender?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    type?: EnumUserTypeFieldUpdateOperationsInput | UserType
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    facebookToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patientData?: PatientUncheckedUpdateOneWithoutUserNestedInput
    doctorData?: DoctorUncheckedUpdateOneWithoutUserNestedInput
    contacts?: UserContactUncheckedUpdateManyWithoutUserNestedInput
    DoctorPatient?: DoctorPatientUncheckedUpdateManyWithoutAssignedByNestedInput
    exercises?: ExerciseUncheckedUpdateManyWithoutCreatorNestedInput
    courses?: CourseUncheckedUpdateManyWithoutCreatorNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutCreatorNestedInput
    watched?: WatchedVideoUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutContactsInput = {
    id?: string
    numericId?: number
    socialName?: string | null
    email: string
    name: string
    gender?: string | null
    customGender?: string | null
    cpf?: string | null
    birthDate?: Date | string | null
    password: string
    type?: UserType
    avatar?: string | null
    facebookToken?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    isAdmin?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    patientData?: PatientCreateNestedOneWithoutUserInput
    doctorData?: DoctorCreateNestedOneWithoutUserInput
    addresses?: UserAdressCreateNestedManyWithoutUserInput
    DoctorPatient?: DoctorPatientCreateNestedManyWithoutAssignedByInput
    exercises?: ExerciseCreateNestedManyWithoutCreatorInput
    courses?: CourseCreateNestedManyWithoutCreatorInput
    lessons?: LessonCreateNestedManyWithoutCreatorInput
    watched?: WatchedVideoCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutContactsInput = {
    id?: string
    numericId?: number
    socialName?: string | null
    email: string
    name: string
    gender?: string | null
    customGender?: string | null
    cpf?: string | null
    birthDate?: Date | string | null
    password: string
    type?: UserType
    avatar?: string | null
    facebookToken?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    isAdmin?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    patientData?: PatientUncheckedCreateNestedOneWithoutUserInput
    doctorData?: DoctorUncheckedCreateNestedOneWithoutUserInput
    addresses?: UserAdressUncheckedCreateNestedManyWithoutUserInput
    DoctorPatient?: DoctorPatientUncheckedCreateNestedManyWithoutAssignedByInput
    exercises?: ExerciseUncheckedCreateNestedManyWithoutCreatorInput
    courses?: CourseUncheckedCreateNestedManyWithoutCreatorInput
    lessons?: LessonUncheckedCreateNestedManyWithoutCreatorInput
    watched?: WatchedVideoUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutContactsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutContactsInput, UserUncheckedCreateWithoutContactsInput>
  }

  export type UserUpsertWithoutContactsInput = {
    update: XOR<UserUpdateWithoutContactsInput, UserUncheckedUpdateWithoutContactsInput>
    create: XOR<UserCreateWithoutContactsInput, UserUncheckedCreateWithoutContactsInput>
  }

  export type UserUpdateWithoutContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    socialName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    customGender?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    type?: EnumUserTypeFieldUpdateOperationsInput | UserType
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    facebookToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patientData?: PatientUpdateOneWithoutUserNestedInput
    doctorData?: DoctorUpdateOneWithoutUserNestedInput
    addresses?: UserAdressUpdateManyWithoutUserNestedInput
    DoctorPatient?: DoctorPatientUpdateManyWithoutAssignedByNestedInput
    exercises?: ExerciseUpdateManyWithoutCreatorNestedInput
    courses?: CourseUpdateManyWithoutCreatorNestedInput
    lessons?: LessonUpdateManyWithoutCreatorNestedInput
    watched?: WatchedVideoUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    socialName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    customGender?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    type?: EnumUserTypeFieldUpdateOperationsInput | UserType
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    facebookToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patientData?: PatientUncheckedUpdateOneWithoutUserNestedInput
    doctorData?: DoctorUncheckedUpdateOneWithoutUserNestedInput
    addresses?: UserAdressUncheckedUpdateManyWithoutUserNestedInput
    DoctorPatient?: DoctorPatientUncheckedUpdateManyWithoutAssignedByNestedInput
    exercises?: ExerciseUncheckedUpdateManyWithoutCreatorNestedInput
    courses?: CourseUncheckedUpdateManyWithoutCreatorNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutCreatorNestedInput
    watched?: WatchedVideoUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutPatientDataInput = {
    id?: string
    numericId?: number
    socialName?: string | null
    email: string
    name: string
    gender?: string | null
    customGender?: string | null
    cpf?: string | null
    birthDate?: Date | string | null
    password: string
    type?: UserType
    avatar?: string | null
    facebookToken?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    isAdmin?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    doctorData?: DoctorCreateNestedOneWithoutUserInput
    addresses?: UserAdressCreateNestedManyWithoutUserInput
    contacts?: UserContactCreateNestedManyWithoutUserInput
    DoctorPatient?: DoctorPatientCreateNestedManyWithoutAssignedByInput
    exercises?: ExerciseCreateNestedManyWithoutCreatorInput
    courses?: CourseCreateNestedManyWithoutCreatorInput
    lessons?: LessonCreateNestedManyWithoutCreatorInput
    watched?: WatchedVideoCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPatientDataInput = {
    id?: string
    numericId?: number
    socialName?: string | null
    email: string
    name: string
    gender?: string | null
    customGender?: string | null
    cpf?: string | null
    birthDate?: Date | string | null
    password: string
    type?: UserType
    avatar?: string | null
    facebookToken?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    isAdmin?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    doctorData?: DoctorUncheckedCreateNestedOneWithoutUserInput
    addresses?: UserAdressUncheckedCreateNestedManyWithoutUserInput
    contacts?: UserContactUncheckedCreateNestedManyWithoutUserInput
    DoctorPatient?: DoctorPatientUncheckedCreateNestedManyWithoutAssignedByInput
    exercises?: ExerciseUncheckedCreateNestedManyWithoutCreatorInput
    courses?: CourseUncheckedCreateNestedManyWithoutCreatorInput
    lessons?: LessonUncheckedCreateNestedManyWithoutCreatorInput
    watched?: WatchedVideoUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPatientDataInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPatientDataInput, UserUncheckedCreateWithoutPatientDataInput>
  }

  export type AnamnesisCreateWithoutPatientInput = {
    id?: string
    numericId?: number
    questions?: JsonNullValueInput | InputJsonValue
    title?: string | null
    text?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    doctor: DoctorCreateNestedOneWithoutAnamnesisInput
    specialty: SpecialtyCreateNestedOneWithoutAnamnesisInput
  }

  export type AnamnesisUncheckedCreateWithoutPatientInput = {
    id?: string
    numericId?: number
    doctorId: string
    specialtyId: string
    questions?: JsonNullValueInput | InputJsonValue
    title?: string | null
    text?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AnamnesisCreateOrConnectWithoutPatientInput = {
    where: AnamnesisWhereUniqueInput
    create: XOR<AnamnesisCreateWithoutPatientInput, AnamnesisUncheckedCreateWithoutPatientInput>
  }

  export type AnamnesisCreateManyPatientInputEnvelope = {
    data: Enumerable<AnamnesisCreateManyPatientInput>
    skipDuplicates?: boolean
  }

  export type EvaluationCreateWithoutPatientInput = {
    id?: string
    numericId?: number
    text?: string | null
    title?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    doctor: DoctorCreateNestedOneWithoutEvaluationsInput
    specialty: SpecialtyCreateNestedOneWithoutEvaluationsInput
  }

  export type EvaluationUncheckedCreateWithoutPatientInput = {
    id?: string
    numericId?: number
    doctorId: string
    specialtyId: string
    text?: string | null
    title?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type EvaluationCreateOrConnectWithoutPatientInput = {
    where: EvaluationWhereUniqueInput
    create: XOR<EvaluationCreateWithoutPatientInput, EvaluationUncheckedCreateWithoutPatientInput>
  }

  export type EvaluationCreateManyPatientInputEnvelope = {
    data: Enumerable<EvaluationCreateManyPatientInput>
    skipDuplicates?: boolean
  }

  export type DoctorPatientCreateWithoutPatientInput = {
    createdAt?: Date | string
    active?: boolean
    doctor: DoctorCreateNestedOneWithoutDoctorPatientInput
    assignedBy: UserCreateNestedOneWithoutDoctorPatientInput
  }

  export type DoctorPatientUncheckedCreateWithoutPatientInput = {
    doctorId: string
    assignedById: string
    createdAt?: Date | string
    active?: boolean
  }

  export type DoctorPatientCreateOrConnectWithoutPatientInput = {
    where: DoctorPatientWhereUniqueInput
    create: XOR<DoctorPatientCreateWithoutPatientInput, DoctorPatientUncheckedCreateWithoutPatientInput>
  }

  export type DoctorPatientCreateManyPatientInputEnvelope = {
    data: Enumerable<DoctorPatientCreateManyPatientInput>
    skipDuplicates?: boolean
  }

  export type EvolutionCreateWithoutPatientInput = {
    id?: string
    numericId?: number
    exercises?: JsonNullValueInput | InputJsonValue
    text?: string | null
    title?: string | null
    appointmentDate?: Date | string
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    doctor: DoctorCreateNestedOneWithoutEvolutionsInput
    specialty: SpecialtyCreateNestedOneWithoutEvolutionInput
  }

  export type EvolutionUncheckedCreateWithoutPatientInput = {
    id?: string
    numericId?: number
    doctorId: string
    specialtyId: string
    exercises?: JsonNullValueInput | InputJsonValue
    text?: string | null
    title?: string | null
    appointmentDate?: Date | string
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type EvolutionCreateOrConnectWithoutPatientInput = {
    where: EvolutionWhereUniqueInput
    create: XOR<EvolutionCreateWithoutPatientInput, EvolutionUncheckedCreateWithoutPatientInput>
  }

  export type EvolutionCreateManyPatientInputEnvelope = {
    data: Enumerable<EvolutionCreateManyPatientInput>
    skipDuplicates?: boolean
  }

  export type AppointmentCreateWithoutPatientInput = {
    id?: string
    numericId?: number
    when: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    status?: AppointmentStatus
    doctor: DoctorCreateNestedOneWithoutAppointmentsInput
  }

  export type AppointmentUncheckedCreateWithoutPatientInput = {
    id?: string
    numericId?: number
    doctorId: string
    when: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    status?: AppointmentStatus
  }

  export type AppointmentCreateOrConnectWithoutPatientInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput>
  }

  export type AppointmentCreateManyPatientInputEnvelope = {
    data: Enumerable<AppointmentCreateManyPatientInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutPatientDataInput = {
    update: XOR<UserUpdateWithoutPatientDataInput, UserUncheckedUpdateWithoutPatientDataInput>
    create: XOR<UserCreateWithoutPatientDataInput, UserUncheckedCreateWithoutPatientDataInput>
  }

  export type UserUpdateWithoutPatientDataInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    socialName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    customGender?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    type?: EnumUserTypeFieldUpdateOperationsInput | UserType
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    facebookToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctorData?: DoctorUpdateOneWithoutUserNestedInput
    addresses?: UserAdressUpdateManyWithoutUserNestedInput
    contacts?: UserContactUpdateManyWithoutUserNestedInput
    DoctorPatient?: DoctorPatientUpdateManyWithoutAssignedByNestedInput
    exercises?: ExerciseUpdateManyWithoutCreatorNestedInput
    courses?: CourseUpdateManyWithoutCreatorNestedInput
    lessons?: LessonUpdateManyWithoutCreatorNestedInput
    watched?: WatchedVideoUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPatientDataInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    socialName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    customGender?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    type?: EnumUserTypeFieldUpdateOperationsInput | UserType
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    facebookToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctorData?: DoctorUncheckedUpdateOneWithoutUserNestedInput
    addresses?: UserAdressUncheckedUpdateManyWithoutUserNestedInput
    contacts?: UserContactUncheckedUpdateManyWithoutUserNestedInput
    DoctorPatient?: DoctorPatientUncheckedUpdateManyWithoutAssignedByNestedInput
    exercises?: ExerciseUncheckedUpdateManyWithoutCreatorNestedInput
    courses?: CourseUncheckedUpdateManyWithoutCreatorNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutCreatorNestedInput
    watched?: WatchedVideoUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AnamnesisUpsertWithWhereUniqueWithoutPatientInput = {
    where: AnamnesisWhereUniqueInput
    update: XOR<AnamnesisUpdateWithoutPatientInput, AnamnesisUncheckedUpdateWithoutPatientInput>
    create: XOR<AnamnesisCreateWithoutPatientInput, AnamnesisUncheckedCreateWithoutPatientInput>
  }

  export type AnamnesisUpdateWithWhereUniqueWithoutPatientInput = {
    where: AnamnesisWhereUniqueInput
    data: XOR<AnamnesisUpdateWithoutPatientInput, AnamnesisUncheckedUpdateWithoutPatientInput>
  }

  export type AnamnesisUpdateManyWithWhereWithoutPatientInput = {
    where: AnamnesisScalarWhereInput
    data: XOR<AnamnesisUpdateManyMutationInput, AnamnesisUncheckedUpdateManyWithoutAnamnesisInput>
  }

  export type AnamnesisScalarWhereInput = {
    AND?: Enumerable<AnamnesisScalarWhereInput>
    OR?: Enumerable<AnamnesisScalarWhereInput>
    NOT?: Enumerable<AnamnesisScalarWhereInput>
    id?: UuidFilter | string
    numericId?: IntFilter | number
    patientId?: UuidFilter | string
    doctorId?: UuidFilter | string
    specialtyId?: UuidFilter | string
    questions?: JsonFilter
    title?: StringNullableFilter | string | null
    text?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type EvaluationUpsertWithWhereUniqueWithoutPatientInput = {
    where: EvaluationWhereUniqueInput
    update: XOR<EvaluationUpdateWithoutPatientInput, EvaluationUncheckedUpdateWithoutPatientInput>
    create: XOR<EvaluationCreateWithoutPatientInput, EvaluationUncheckedCreateWithoutPatientInput>
  }

  export type EvaluationUpdateWithWhereUniqueWithoutPatientInput = {
    where: EvaluationWhereUniqueInput
    data: XOR<EvaluationUpdateWithoutPatientInput, EvaluationUncheckedUpdateWithoutPatientInput>
  }

  export type EvaluationUpdateManyWithWhereWithoutPatientInput = {
    where: EvaluationScalarWhereInput
    data: XOR<EvaluationUpdateManyMutationInput, EvaluationUncheckedUpdateManyWithoutEvaluationsInput>
  }

  export type EvaluationScalarWhereInput = {
    AND?: Enumerable<EvaluationScalarWhereInput>
    OR?: Enumerable<EvaluationScalarWhereInput>
    NOT?: Enumerable<EvaluationScalarWhereInput>
    id?: UuidFilter | string
    numericId?: IntFilter | number
    patientId?: UuidFilter | string
    doctorId?: UuidFilter | string
    specialtyId?: UuidFilter | string
    text?: StringNullableFilter | string | null
    title?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type DoctorPatientUpsertWithWhereUniqueWithoutPatientInput = {
    where: DoctorPatientWhereUniqueInput
    update: XOR<DoctorPatientUpdateWithoutPatientInput, DoctorPatientUncheckedUpdateWithoutPatientInput>
    create: XOR<DoctorPatientCreateWithoutPatientInput, DoctorPatientUncheckedCreateWithoutPatientInput>
  }

  export type DoctorPatientUpdateWithWhereUniqueWithoutPatientInput = {
    where: DoctorPatientWhereUniqueInput
    data: XOR<DoctorPatientUpdateWithoutPatientInput, DoctorPatientUncheckedUpdateWithoutPatientInput>
  }

  export type DoctorPatientUpdateManyWithWhereWithoutPatientInput = {
    where: DoctorPatientScalarWhereInput
    data: XOR<DoctorPatientUpdateManyMutationInput, DoctorPatientUncheckedUpdateManyWithoutDoctorPatientInput>
  }

  export type EvolutionUpsertWithWhereUniqueWithoutPatientInput = {
    where: EvolutionWhereUniqueInput
    update: XOR<EvolutionUpdateWithoutPatientInput, EvolutionUncheckedUpdateWithoutPatientInput>
    create: XOR<EvolutionCreateWithoutPatientInput, EvolutionUncheckedCreateWithoutPatientInput>
  }

  export type EvolutionUpdateWithWhereUniqueWithoutPatientInput = {
    where: EvolutionWhereUniqueInput
    data: XOR<EvolutionUpdateWithoutPatientInput, EvolutionUncheckedUpdateWithoutPatientInput>
  }

  export type EvolutionUpdateManyWithWhereWithoutPatientInput = {
    where: EvolutionScalarWhereInput
    data: XOR<EvolutionUpdateManyMutationInput, EvolutionUncheckedUpdateManyWithoutEvolutionsInput>
  }

  export type EvolutionScalarWhereInput = {
    AND?: Enumerable<EvolutionScalarWhereInput>
    OR?: Enumerable<EvolutionScalarWhereInput>
    NOT?: Enumerable<EvolutionScalarWhereInput>
    id?: UuidFilter | string
    numericId?: IntFilter | number
    patientId?: UuidFilter | string
    doctorId?: UuidFilter | string
    specialtyId?: UuidFilter | string
    exercises?: JsonFilter
    text?: StringNullableFilter | string | null
    title?: StringNullableFilter | string | null
    appointmentDate?: DateTimeFilter | Date | string
    comments?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type AppointmentUpsertWithWhereUniqueWithoutPatientInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutPatientInput, AppointmentUncheckedUpdateWithoutPatientInput>
    create: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutPatientInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutPatientInput, AppointmentUncheckedUpdateWithoutPatientInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutPatientInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutAppointmentInput>
  }

  export type AppointmentScalarWhereInput = {
    AND?: Enumerable<AppointmentScalarWhereInput>
    OR?: Enumerable<AppointmentScalarWhereInput>
    NOT?: Enumerable<AppointmentScalarWhereInput>
    id?: UuidFilter | string
    numericId?: IntFilter | number
    doctorId?: UuidFilter | string
    patientId?: UuidFilter | string
    when?: DateTimeFilter | Date | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
    status?: EnumAppointmentStatusFilter | AppointmentStatus
  }

  export type DoctorCreateWithoutAppointmentsInput = {
    id?: string
    numericId?: number
    crfa?: string | null
    availability?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    specialty: SpecialtyCreateNestedOneWithoutDoctorsInput
    user: UserCreateNestedOneWithoutDoctorDataInput
    anamnesis?: AnamnesisCreateNestedManyWithoutDoctorInput
    evaluations?: EvaluationCreateNestedManyWithoutDoctorInput
    doctorPatient?: DoctorPatientCreateNestedManyWithoutDoctorInput
    templates?: TemplateCreateNestedManyWithoutDoctorInput
    evolutions?: EvolutionCreateNestedManyWithoutDoctorInput
  }

  export type DoctorUncheckedCreateWithoutAppointmentsInput = {
    id?: string
    numericId?: number
    userId: string
    specialtyId: string
    crfa?: string | null
    availability?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    anamnesis?: AnamnesisUncheckedCreateNestedManyWithoutDoctorInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutDoctorInput
    doctorPatient?: DoctorPatientUncheckedCreateNestedManyWithoutDoctorInput
    templates?: TemplateUncheckedCreateNestedManyWithoutDoctorInput
    evolutions?: EvolutionUncheckedCreateNestedManyWithoutDoctorInput
  }

  export type DoctorCreateOrConnectWithoutAppointmentsInput = {
    where: DoctorWhereUniqueInput
    create: XOR<DoctorCreateWithoutAppointmentsInput, DoctorUncheckedCreateWithoutAppointmentsInput>
  }

  export type PatientCreateWithoutAppointmentInput = {
    id?: string
    numericId?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutPatientDataInput
    anamnesis?: AnamnesisCreateNestedManyWithoutPatientInput
    evaluations?: EvaluationCreateNestedManyWithoutPatientInput
    doctorPatient?: DoctorPatientCreateNestedManyWithoutPatientInput
    evolutions?: EvolutionCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutAppointmentInput = {
    id?: string
    numericId?: number
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    anamnesis?: AnamnesisUncheckedCreateNestedManyWithoutPatientInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutPatientInput
    doctorPatient?: DoctorPatientUncheckedCreateNestedManyWithoutPatientInput
    evolutions?: EvolutionUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutAppointmentInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutAppointmentInput, PatientUncheckedCreateWithoutAppointmentInput>
  }

  export type DoctorUpsertWithoutAppointmentsInput = {
    update: XOR<DoctorUpdateWithoutAppointmentsInput, DoctorUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<DoctorCreateWithoutAppointmentsInput, DoctorUncheckedCreateWithoutAppointmentsInput>
  }

  export type DoctorUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    crfa?: NullableStringFieldUpdateOperationsInput | string | null
    availability?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    specialty?: SpecialtyUpdateOneRequiredWithoutDoctorsNestedInput
    user?: UserUpdateOneRequiredWithoutDoctorDataNestedInput
    anamnesis?: AnamnesisUpdateManyWithoutDoctorNestedInput
    evaluations?: EvaluationUpdateManyWithoutDoctorNestedInput
    doctorPatient?: DoctorPatientUpdateManyWithoutDoctorNestedInput
    templates?: TemplateUpdateManyWithoutDoctorNestedInput
    evolutions?: EvolutionUpdateManyWithoutDoctorNestedInput
  }

  export type DoctorUncheckedUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    specialtyId?: StringFieldUpdateOperationsInput | string
    crfa?: NullableStringFieldUpdateOperationsInput | string | null
    availability?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    anamnesis?: AnamnesisUncheckedUpdateManyWithoutDoctorNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutDoctorNestedInput
    doctorPatient?: DoctorPatientUncheckedUpdateManyWithoutDoctorNestedInput
    templates?: TemplateUncheckedUpdateManyWithoutDoctorNestedInput
    evolutions?: EvolutionUncheckedUpdateManyWithoutDoctorNestedInput
  }

  export type PatientUpsertWithoutAppointmentInput = {
    update: XOR<PatientUpdateWithoutAppointmentInput, PatientUncheckedUpdateWithoutAppointmentInput>
    create: XOR<PatientCreateWithoutAppointmentInput, PatientUncheckedCreateWithoutAppointmentInput>
  }

  export type PatientUpdateWithoutAppointmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutPatientDataNestedInput
    anamnesis?: AnamnesisUpdateManyWithoutPatientNestedInput
    evaluations?: EvaluationUpdateManyWithoutPatientNestedInput
    doctorPatient?: DoctorPatientUpdateManyWithoutPatientNestedInput
    evolutions?: EvolutionUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutAppointmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    anamnesis?: AnamnesisUncheckedUpdateManyWithoutPatientNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutPatientNestedInput
    doctorPatient?: DoctorPatientUncheckedUpdateManyWithoutPatientNestedInput
    evolutions?: EvolutionUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type SpecialtyCreateWithoutDoctorsInput = {
    id?: string
    numericId?: number
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    templates?: TemplateCreateNestedManyWithoutSpecialtyInput
    evaluations?: EvaluationCreateNestedManyWithoutSpecialtyInput
    anamnesis?: AnamnesisCreateNestedManyWithoutSpecialtyInput
    evolution?: EvolutionCreateNestedManyWithoutSpecialtyInput
    exercise?: ExerciseCreateNestedManyWithoutSpecialtyInput
    course?: CourseCreateNestedManyWithoutSpecialtyInput
  }

  export type SpecialtyUncheckedCreateWithoutDoctorsInput = {
    id?: string
    numericId?: number
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    templates?: TemplateUncheckedCreateNestedManyWithoutSpecialtyInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutSpecialtyInput
    anamnesis?: AnamnesisUncheckedCreateNestedManyWithoutSpecialtyInput
    evolution?: EvolutionUncheckedCreateNestedManyWithoutSpecialtyInput
    exercise?: ExerciseUncheckedCreateNestedManyWithoutSpecialtyInput
    course?: CourseUncheckedCreateNestedManyWithoutSpecialtyInput
  }

  export type SpecialtyCreateOrConnectWithoutDoctorsInput = {
    where: SpecialtyWhereUniqueInput
    create: XOR<SpecialtyCreateWithoutDoctorsInput, SpecialtyUncheckedCreateWithoutDoctorsInput>
  }

  export type UserCreateWithoutDoctorDataInput = {
    id?: string
    numericId?: number
    socialName?: string | null
    email: string
    name: string
    gender?: string | null
    customGender?: string | null
    cpf?: string | null
    birthDate?: Date | string | null
    password: string
    type?: UserType
    avatar?: string | null
    facebookToken?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    isAdmin?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    patientData?: PatientCreateNestedOneWithoutUserInput
    addresses?: UserAdressCreateNestedManyWithoutUserInput
    contacts?: UserContactCreateNestedManyWithoutUserInput
    DoctorPatient?: DoctorPatientCreateNestedManyWithoutAssignedByInput
    exercises?: ExerciseCreateNestedManyWithoutCreatorInput
    courses?: CourseCreateNestedManyWithoutCreatorInput
    lessons?: LessonCreateNestedManyWithoutCreatorInput
    watched?: WatchedVideoCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDoctorDataInput = {
    id?: string
    numericId?: number
    socialName?: string | null
    email: string
    name: string
    gender?: string | null
    customGender?: string | null
    cpf?: string | null
    birthDate?: Date | string | null
    password: string
    type?: UserType
    avatar?: string | null
    facebookToken?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    isAdmin?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    patientData?: PatientUncheckedCreateNestedOneWithoutUserInput
    addresses?: UserAdressUncheckedCreateNestedManyWithoutUserInput
    contacts?: UserContactUncheckedCreateNestedManyWithoutUserInput
    DoctorPatient?: DoctorPatientUncheckedCreateNestedManyWithoutAssignedByInput
    exercises?: ExerciseUncheckedCreateNestedManyWithoutCreatorInput
    courses?: CourseUncheckedCreateNestedManyWithoutCreatorInput
    lessons?: LessonUncheckedCreateNestedManyWithoutCreatorInput
    watched?: WatchedVideoUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDoctorDataInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDoctorDataInput, UserUncheckedCreateWithoutDoctorDataInput>
  }

  export type AnamnesisCreateWithoutDoctorInput = {
    id?: string
    numericId?: number
    questions?: JsonNullValueInput | InputJsonValue
    title?: string | null
    text?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    patient: PatientCreateNestedOneWithoutAnamnesisInput
    specialty: SpecialtyCreateNestedOneWithoutAnamnesisInput
  }

  export type AnamnesisUncheckedCreateWithoutDoctorInput = {
    id?: string
    numericId?: number
    patientId: string
    specialtyId: string
    questions?: JsonNullValueInput | InputJsonValue
    title?: string | null
    text?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AnamnesisCreateOrConnectWithoutDoctorInput = {
    where: AnamnesisWhereUniqueInput
    create: XOR<AnamnesisCreateWithoutDoctorInput, AnamnesisUncheckedCreateWithoutDoctorInput>
  }

  export type AnamnesisCreateManyDoctorInputEnvelope = {
    data: Enumerable<AnamnesisCreateManyDoctorInput>
    skipDuplicates?: boolean
  }

  export type EvaluationCreateWithoutDoctorInput = {
    id?: string
    numericId?: number
    text?: string | null
    title?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    patient: PatientCreateNestedOneWithoutEvaluationsInput
    specialty: SpecialtyCreateNestedOneWithoutEvaluationsInput
  }

  export type EvaluationUncheckedCreateWithoutDoctorInput = {
    id?: string
    numericId?: number
    patientId: string
    specialtyId: string
    text?: string | null
    title?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type EvaluationCreateOrConnectWithoutDoctorInput = {
    where: EvaluationWhereUniqueInput
    create: XOR<EvaluationCreateWithoutDoctorInput, EvaluationUncheckedCreateWithoutDoctorInput>
  }

  export type EvaluationCreateManyDoctorInputEnvelope = {
    data: Enumerable<EvaluationCreateManyDoctorInput>
    skipDuplicates?: boolean
  }

  export type DoctorPatientCreateWithoutDoctorInput = {
    createdAt?: Date | string
    active?: boolean
    patient: PatientCreateNestedOneWithoutDoctorPatientInput
    assignedBy: UserCreateNestedOneWithoutDoctorPatientInput
  }

  export type DoctorPatientUncheckedCreateWithoutDoctorInput = {
    patientId: string
    assignedById: string
    createdAt?: Date | string
    active?: boolean
  }

  export type DoctorPatientCreateOrConnectWithoutDoctorInput = {
    where: DoctorPatientWhereUniqueInput
    create: XOR<DoctorPatientCreateWithoutDoctorInput, DoctorPatientUncheckedCreateWithoutDoctorInput>
  }

  export type DoctorPatientCreateManyDoctorInputEnvelope = {
    data: Enumerable<DoctorPatientCreateManyDoctorInput>
    skipDuplicates?: boolean
  }

  export type TemplateCreateWithoutDoctorInput = {
    id?: string
    numericId?: number
    type: TemplateType
    title: string
    html: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    specialty: SpecialtyCreateNestedOneWithoutTemplatesInput
  }

  export type TemplateUncheckedCreateWithoutDoctorInput = {
    id?: string
    numericId?: number
    type: TemplateType
    specialtyId: string
    title: string
    html: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type TemplateCreateOrConnectWithoutDoctorInput = {
    where: TemplateWhereUniqueInput
    create: XOR<TemplateCreateWithoutDoctorInput, TemplateUncheckedCreateWithoutDoctorInput>
  }

  export type TemplateCreateManyDoctorInputEnvelope = {
    data: Enumerable<TemplateCreateManyDoctorInput>
    skipDuplicates?: boolean
  }

  export type EvolutionCreateWithoutDoctorInput = {
    id?: string
    numericId?: number
    exercises?: JsonNullValueInput | InputJsonValue
    text?: string | null
    title?: string | null
    appointmentDate?: Date | string
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    patient: PatientCreateNestedOneWithoutEvolutionsInput
    specialty: SpecialtyCreateNestedOneWithoutEvolutionInput
  }

  export type EvolutionUncheckedCreateWithoutDoctorInput = {
    id?: string
    numericId?: number
    patientId: string
    specialtyId: string
    exercises?: JsonNullValueInput | InputJsonValue
    text?: string | null
    title?: string | null
    appointmentDate?: Date | string
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type EvolutionCreateOrConnectWithoutDoctorInput = {
    where: EvolutionWhereUniqueInput
    create: XOR<EvolutionCreateWithoutDoctorInput, EvolutionUncheckedCreateWithoutDoctorInput>
  }

  export type EvolutionCreateManyDoctorInputEnvelope = {
    data: Enumerable<EvolutionCreateManyDoctorInput>
    skipDuplicates?: boolean
  }

  export type AppointmentCreateWithoutDoctorInput = {
    id?: string
    numericId?: number
    when: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    status?: AppointmentStatus
    patient: PatientCreateNestedOneWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateWithoutDoctorInput = {
    id?: string
    numericId?: number
    patientId: string
    when: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    status?: AppointmentStatus
  }

  export type AppointmentCreateOrConnectWithoutDoctorInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutDoctorInput, AppointmentUncheckedCreateWithoutDoctorInput>
  }

  export type AppointmentCreateManyDoctorInputEnvelope = {
    data: Enumerable<AppointmentCreateManyDoctorInput>
    skipDuplicates?: boolean
  }

  export type SpecialtyUpsertWithoutDoctorsInput = {
    update: XOR<SpecialtyUpdateWithoutDoctorsInput, SpecialtyUncheckedUpdateWithoutDoctorsInput>
    create: XOR<SpecialtyCreateWithoutDoctorsInput, SpecialtyUncheckedCreateWithoutDoctorsInput>
  }

  export type SpecialtyUpdateWithoutDoctorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    templates?: TemplateUpdateManyWithoutSpecialtyNestedInput
    evaluations?: EvaluationUpdateManyWithoutSpecialtyNestedInput
    anamnesis?: AnamnesisUpdateManyWithoutSpecialtyNestedInput
    evolution?: EvolutionUpdateManyWithoutSpecialtyNestedInput
    exercise?: ExerciseUpdateManyWithoutSpecialtyNestedInput
    course?: CourseUpdateManyWithoutSpecialtyNestedInput
  }

  export type SpecialtyUncheckedUpdateWithoutDoctorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    templates?: TemplateUncheckedUpdateManyWithoutSpecialtyNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutSpecialtyNestedInput
    anamnesis?: AnamnesisUncheckedUpdateManyWithoutSpecialtyNestedInput
    evolution?: EvolutionUncheckedUpdateManyWithoutSpecialtyNestedInput
    exercise?: ExerciseUncheckedUpdateManyWithoutSpecialtyNestedInput
    course?: CourseUncheckedUpdateManyWithoutSpecialtyNestedInput
  }

  export type UserUpsertWithoutDoctorDataInput = {
    update: XOR<UserUpdateWithoutDoctorDataInput, UserUncheckedUpdateWithoutDoctorDataInput>
    create: XOR<UserCreateWithoutDoctorDataInput, UserUncheckedCreateWithoutDoctorDataInput>
  }

  export type UserUpdateWithoutDoctorDataInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    socialName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    customGender?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    type?: EnumUserTypeFieldUpdateOperationsInput | UserType
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    facebookToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patientData?: PatientUpdateOneWithoutUserNestedInput
    addresses?: UserAdressUpdateManyWithoutUserNestedInput
    contacts?: UserContactUpdateManyWithoutUserNestedInput
    DoctorPatient?: DoctorPatientUpdateManyWithoutAssignedByNestedInput
    exercises?: ExerciseUpdateManyWithoutCreatorNestedInput
    courses?: CourseUpdateManyWithoutCreatorNestedInput
    lessons?: LessonUpdateManyWithoutCreatorNestedInput
    watched?: WatchedVideoUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDoctorDataInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    socialName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    customGender?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    type?: EnumUserTypeFieldUpdateOperationsInput | UserType
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    facebookToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patientData?: PatientUncheckedUpdateOneWithoutUserNestedInput
    addresses?: UserAdressUncheckedUpdateManyWithoutUserNestedInput
    contacts?: UserContactUncheckedUpdateManyWithoutUserNestedInput
    DoctorPatient?: DoctorPatientUncheckedUpdateManyWithoutAssignedByNestedInput
    exercises?: ExerciseUncheckedUpdateManyWithoutCreatorNestedInput
    courses?: CourseUncheckedUpdateManyWithoutCreatorNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutCreatorNestedInput
    watched?: WatchedVideoUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AnamnesisUpsertWithWhereUniqueWithoutDoctorInput = {
    where: AnamnesisWhereUniqueInput
    update: XOR<AnamnesisUpdateWithoutDoctorInput, AnamnesisUncheckedUpdateWithoutDoctorInput>
    create: XOR<AnamnesisCreateWithoutDoctorInput, AnamnesisUncheckedCreateWithoutDoctorInput>
  }

  export type AnamnesisUpdateWithWhereUniqueWithoutDoctorInput = {
    where: AnamnesisWhereUniqueInput
    data: XOR<AnamnesisUpdateWithoutDoctorInput, AnamnesisUncheckedUpdateWithoutDoctorInput>
  }

  export type AnamnesisUpdateManyWithWhereWithoutDoctorInput = {
    where: AnamnesisScalarWhereInput
    data: XOR<AnamnesisUpdateManyMutationInput, AnamnesisUncheckedUpdateManyWithoutAnamnesisInput>
  }

  export type EvaluationUpsertWithWhereUniqueWithoutDoctorInput = {
    where: EvaluationWhereUniqueInput
    update: XOR<EvaluationUpdateWithoutDoctorInput, EvaluationUncheckedUpdateWithoutDoctorInput>
    create: XOR<EvaluationCreateWithoutDoctorInput, EvaluationUncheckedCreateWithoutDoctorInput>
  }

  export type EvaluationUpdateWithWhereUniqueWithoutDoctorInput = {
    where: EvaluationWhereUniqueInput
    data: XOR<EvaluationUpdateWithoutDoctorInput, EvaluationUncheckedUpdateWithoutDoctorInput>
  }

  export type EvaluationUpdateManyWithWhereWithoutDoctorInput = {
    where: EvaluationScalarWhereInput
    data: XOR<EvaluationUpdateManyMutationInput, EvaluationUncheckedUpdateManyWithoutEvaluationsInput>
  }

  export type DoctorPatientUpsertWithWhereUniqueWithoutDoctorInput = {
    where: DoctorPatientWhereUniqueInput
    update: XOR<DoctorPatientUpdateWithoutDoctorInput, DoctorPatientUncheckedUpdateWithoutDoctorInput>
    create: XOR<DoctorPatientCreateWithoutDoctorInput, DoctorPatientUncheckedCreateWithoutDoctorInput>
  }

  export type DoctorPatientUpdateWithWhereUniqueWithoutDoctorInput = {
    where: DoctorPatientWhereUniqueInput
    data: XOR<DoctorPatientUpdateWithoutDoctorInput, DoctorPatientUncheckedUpdateWithoutDoctorInput>
  }

  export type DoctorPatientUpdateManyWithWhereWithoutDoctorInput = {
    where: DoctorPatientScalarWhereInput
    data: XOR<DoctorPatientUpdateManyMutationInput, DoctorPatientUncheckedUpdateManyWithoutDoctorPatientInput>
  }

  export type TemplateUpsertWithWhereUniqueWithoutDoctorInput = {
    where: TemplateWhereUniqueInput
    update: XOR<TemplateUpdateWithoutDoctorInput, TemplateUncheckedUpdateWithoutDoctorInput>
    create: XOR<TemplateCreateWithoutDoctorInput, TemplateUncheckedCreateWithoutDoctorInput>
  }

  export type TemplateUpdateWithWhereUniqueWithoutDoctorInput = {
    where: TemplateWhereUniqueInput
    data: XOR<TemplateUpdateWithoutDoctorInput, TemplateUncheckedUpdateWithoutDoctorInput>
  }

  export type TemplateUpdateManyWithWhereWithoutDoctorInput = {
    where: TemplateScalarWhereInput
    data: XOR<TemplateUpdateManyMutationInput, TemplateUncheckedUpdateManyWithoutTemplatesInput>
  }

  export type TemplateScalarWhereInput = {
    AND?: Enumerable<TemplateScalarWhereInput>
    OR?: Enumerable<TemplateScalarWhereInput>
    NOT?: Enumerable<TemplateScalarWhereInput>
    id?: UuidFilter | string
    numericId?: IntFilter | number
    doctorId?: UuidFilter | string
    type?: EnumTemplateTypeFilter | TemplateType
    specialtyId?: UuidFilter | string
    title?: StringFilter | string
    html?: StringFilter | string
    isActive?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type EvolutionUpsertWithWhereUniqueWithoutDoctorInput = {
    where: EvolutionWhereUniqueInput
    update: XOR<EvolutionUpdateWithoutDoctorInput, EvolutionUncheckedUpdateWithoutDoctorInput>
    create: XOR<EvolutionCreateWithoutDoctorInput, EvolutionUncheckedCreateWithoutDoctorInput>
  }

  export type EvolutionUpdateWithWhereUniqueWithoutDoctorInput = {
    where: EvolutionWhereUniqueInput
    data: XOR<EvolutionUpdateWithoutDoctorInput, EvolutionUncheckedUpdateWithoutDoctorInput>
  }

  export type EvolutionUpdateManyWithWhereWithoutDoctorInput = {
    where: EvolutionScalarWhereInput
    data: XOR<EvolutionUpdateManyMutationInput, EvolutionUncheckedUpdateManyWithoutEvolutionsInput>
  }

  export type AppointmentUpsertWithWhereUniqueWithoutDoctorInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutDoctorInput, AppointmentUncheckedUpdateWithoutDoctorInput>
    create: XOR<AppointmentCreateWithoutDoctorInput, AppointmentUncheckedCreateWithoutDoctorInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutDoctorInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutDoctorInput, AppointmentUncheckedUpdateWithoutDoctorInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutDoctorInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutAppointmentsInput>
  }

  export type DoctorCreateWithoutDoctorPatientInput = {
    id?: string
    numericId?: number
    crfa?: string | null
    availability?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    specialty: SpecialtyCreateNestedOneWithoutDoctorsInput
    user: UserCreateNestedOneWithoutDoctorDataInput
    anamnesis?: AnamnesisCreateNestedManyWithoutDoctorInput
    evaluations?: EvaluationCreateNestedManyWithoutDoctorInput
    templates?: TemplateCreateNestedManyWithoutDoctorInput
    evolutions?: EvolutionCreateNestedManyWithoutDoctorInput
    appointments?: AppointmentCreateNestedManyWithoutDoctorInput
  }

  export type DoctorUncheckedCreateWithoutDoctorPatientInput = {
    id?: string
    numericId?: number
    userId: string
    specialtyId: string
    crfa?: string | null
    availability?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    anamnesis?: AnamnesisUncheckedCreateNestedManyWithoutDoctorInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutDoctorInput
    templates?: TemplateUncheckedCreateNestedManyWithoutDoctorInput
    evolutions?: EvolutionUncheckedCreateNestedManyWithoutDoctorInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
  }

  export type DoctorCreateOrConnectWithoutDoctorPatientInput = {
    where: DoctorWhereUniqueInput
    create: XOR<DoctorCreateWithoutDoctorPatientInput, DoctorUncheckedCreateWithoutDoctorPatientInput>
  }

  export type PatientCreateWithoutDoctorPatientInput = {
    id?: string
    numericId?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutPatientDataInput
    anamnesis?: AnamnesisCreateNestedManyWithoutPatientInput
    evaluations?: EvaluationCreateNestedManyWithoutPatientInput
    evolutions?: EvolutionCreateNestedManyWithoutPatientInput
    appointment?: AppointmentCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutDoctorPatientInput = {
    id?: string
    numericId?: number
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    anamnesis?: AnamnesisUncheckedCreateNestedManyWithoutPatientInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutPatientInput
    evolutions?: EvolutionUncheckedCreateNestedManyWithoutPatientInput
    appointment?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutDoctorPatientInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutDoctorPatientInput, PatientUncheckedCreateWithoutDoctorPatientInput>
  }

  export type UserCreateWithoutDoctorPatientInput = {
    id?: string
    numericId?: number
    socialName?: string | null
    email: string
    name: string
    gender?: string | null
    customGender?: string | null
    cpf?: string | null
    birthDate?: Date | string | null
    password: string
    type?: UserType
    avatar?: string | null
    facebookToken?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    isAdmin?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    patientData?: PatientCreateNestedOneWithoutUserInput
    doctorData?: DoctorCreateNestedOneWithoutUserInput
    addresses?: UserAdressCreateNestedManyWithoutUserInput
    contacts?: UserContactCreateNestedManyWithoutUserInput
    exercises?: ExerciseCreateNestedManyWithoutCreatorInput
    courses?: CourseCreateNestedManyWithoutCreatorInput
    lessons?: LessonCreateNestedManyWithoutCreatorInput
    watched?: WatchedVideoCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDoctorPatientInput = {
    id?: string
    numericId?: number
    socialName?: string | null
    email: string
    name: string
    gender?: string | null
    customGender?: string | null
    cpf?: string | null
    birthDate?: Date | string | null
    password: string
    type?: UserType
    avatar?: string | null
    facebookToken?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    isAdmin?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    patientData?: PatientUncheckedCreateNestedOneWithoutUserInput
    doctorData?: DoctorUncheckedCreateNestedOneWithoutUserInput
    addresses?: UserAdressUncheckedCreateNestedManyWithoutUserInput
    contacts?: UserContactUncheckedCreateNestedManyWithoutUserInput
    exercises?: ExerciseUncheckedCreateNestedManyWithoutCreatorInput
    courses?: CourseUncheckedCreateNestedManyWithoutCreatorInput
    lessons?: LessonUncheckedCreateNestedManyWithoutCreatorInput
    watched?: WatchedVideoUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDoctorPatientInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDoctorPatientInput, UserUncheckedCreateWithoutDoctorPatientInput>
  }

  export type DoctorUpsertWithoutDoctorPatientInput = {
    update: XOR<DoctorUpdateWithoutDoctorPatientInput, DoctorUncheckedUpdateWithoutDoctorPatientInput>
    create: XOR<DoctorCreateWithoutDoctorPatientInput, DoctorUncheckedCreateWithoutDoctorPatientInput>
  }

  export type DoctorUpdateWithoutDoctorPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    crfa?: NullableStringFieldUpdateOperationsInput | string | null
    availability?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    specialty?: SpecialtyUpdateOneRequiredWithoutDoctorsNestedInput
    user?: UserUpdateOneRequiredWithoutDoctorDataNestedInput
    anamnesis?: AnamnesisUpdateManyWithoutDoctorNestedInput
    evaluations?: EvaluationUpdateManyWithoutDoctorNestedInput
    templates?: TemplateUpdateManyWithoutDoctorNestedInput
    evolutions?: EvolutionUpdateManyWithoutDoctorNestedInput
    appointments?: AppointmentUpdateManyWithoutDoctorNestedInput
  }

  export type DoctorUncheckedUpdateWithoutDoctorPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    specialtyId?: StringFieldUpdateOperationsInput | string
    crfa?: NullableStringFieldUpdateOperationsInput | string | null
    availability?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    anamnesis?: AnamnesisUncheckedUpdateManyWithoutDoctorNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutDoctorNestedInput
    templates?: TemplateUncheckedUpdateManyWithoutDoctorNestedInput
    evolutions?: EvolutionUncheckedUpdateManyWithoutDoctorNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
  }

  export type PatientUpsertWithoutDoctorPatientInput = {
    update: XOR<PatientUpdateWithoutDoctorPatientInput, PatientUncheckedUpdateWithoutDoctorPatientInput>
    create: XOR<PatientCreateWithoutDoctorPatientInput, PatientUncheckedCreateWithoutDoctorPatientInput>
  }

  export type PatientUpdateWithoutDoctorPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutPatientDataNestedInput
    anamnesis?: AnamnesisUpdateManyWithoutPatientNestedInput
    evaluations?: EvaluationUpdateManyWithoutPatientNestedInput
    evolutions?: EvolutionUpdateManyWithoutPatientNestedInput
    appointment?: AppointmentUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutDoctorPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    anamnesis?: AnamnesisUncheckedUpdateManyWithoutPatientNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutPatientNestedInput
    evolutions?: EvolutionUncheckedUpdateManyWithoutPatientNestedInput
    appointment?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type UserUpsertWithoutDoctorPatientInput = {
    update: XOR<UserUpdateWithoutDoctorPatientInput, UserUncheckedUpdateWithoutDoctorPatientInput>
    create: XOR<UserCreateWithoutDoctorPatientInput, UserUncheckedCreateWithoutDoctorPatientInput>
  }

  export type UserUpdateWithoutDoctorPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    socialName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    customGender?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    type?: EnumUserTypeFieldUpdateOperationsInput | UserType
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    facebookToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patientData?: PatientUpdateOneWithoutUserNestedInput
    doctorData?: DoctorUpdateOneWithoutUserNestedInput
    addresses?: UserAdressUpdateManyWithoutUserNestedInput
    contacts?: UserContactUpdateManyWithoutUserNestedInput
    exercises?: ExerciseUpdateManyWithoutCreatorNestedInput
    courses?: CourseUpdateManyWithoutCreatorNestedInput
    lessons?: LessonUpdateManyWithoutCreatorNestedInput
    watched?: WatchedVideoUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDoctorPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    socialName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    customGender?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    type?: EnumUserTypeFieldUpdateOperationsInput | UserType
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    facebookToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patientData?: PatientUncheckedUpdateOneWithoutUserNestedInput
    doctorData?: DoctorUncheckedUpdateOneWithoutUserNestedInput
    addresses?: UserAdressUncheckedUpdateManyWithoutUserNestedInput
    contacts?: UserContactUncheckedUpdateManyWithoutUserNestedInput
    exercises?: ExerciseUncheckedUpdateManyWithoutCreatorNestedInput
    courses?: CourseUncheckedUpdateManyWithoutCreatorNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutCreatorNestedInput
    watched?: WatchedVideoUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DoctorCreateWithoutSpecialtyInput = {
    id?: string
    numericId?: number
    crfa?: string | null
    availability?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutDoctorDataInput
    anamnesis?: AnamnesisCreateNestedManyWithoutDoctorInput
    evaluations?: EvaluationCreateNestedManyWithoutDoctorInput
    doctorPatient?: DoctorPatientCreateNestedManyWithoutDoctorInput
    templates?: TemplateCreateNestedManyWithoutDoctorInput
    evolutions?: EvolutionCreateNestedManyWithoutDoctorInput
    appointments?: AppointmentCreateNestedManyWithoutDoctorInput
  }

  export type DoctorUncheckedCreateWithoutSpecialtyInput = {
    id?: string
    numericId?: number
    userId: string
    crfa?: string | null
    availability?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    anamnesis?: AnamnesisUncheckedCreateNestedManyWithoutDoctorInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutDoctorInput
    doctorPatient?: DoctorPatientUncheckedCreateNestedManyWithoutDoctorInput
    templates?: TemplateUncheckedCreateNestedManyWithoutDoctorInput
    evolutions?: EvolutionUncheckedCreateNestedManyWithoutDoctorInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
  }

  export type DoctorCreateOrConnectWithoutSpecialtyInput = {
    where: DoctorWhereUniqueInput
    create: XOR<DoctorCreateWithoutSpecialtyInput, DoctorUncheckedCreateWithoutSpecialtyInput>
  }

  export type DoctorCreateManySpecialtyInputEnvelope = {
    data: Enumerable<DoctorCreateManySpecialtyInput>
    skipDuplicates?: boolean
  }

  export type TemplateCreateWithoutSpecialtyInput = {
    id?: string
    numericId?: number
    type: TemplateType
    title: string
    html: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    doctor: DoctorCreateNestedOneWithoutTemplatesInput
  }

  export type TemplateUncheckedCreateWithoutSpecialtyInput = {
    id?: string
    numericId?: number
    doctorId: string
    type: TemplateType
    title: string
    html: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type TemplateCreateOrConnectWithoutSpecialtyInput = {
    where: TemplateWhereUniqueInput
    create: XOR<TemplateCreateWithoutSpecialtyInput, TemplateUncheckedCreateWithoutSpecialtyInput>
  }

  export type TemplateCreateManySpecialtyInputEnvelope = {
    data: Enumerable<TemplateCreateManySpecialtyInput>
    skipDuplicates?: boolean
  }

  export type EvaluationCreateWithoutSpecialtyInput = {
    id?: string
    numericId?: number
    text?: string | null
    title?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    patient: PatientCreateNestedOneWithoutEvaluationsInput
    doctor: DoctorCreateNestedOneWithoutEvaluationsInput
  }

  export type EvaluationUncheckedCreateWithoutSpecialtyInput = {
    id?: string
    numericId?: number
    patientId: string
    doctorId: string
    text?: string | null
    title?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type EvaluationCreateOrConnectWithoutSpecialtyInput = {
    where: EvaluationWhereUniqueInput
    create: XOR<EvaluationCreateWithoutSpecialtyInput, EvaluationUncheckedCreateWithoutSpecialtyInput>
  }

  export type EvaluationCreateManySpecialtyInputEnvelope = {
    data: Enumerable<EvaluationCreateManySpecialtyInput>
    skipDuplicates?: boolean
  }

  export type AnamnesisCreateWithoutSpecialtyInput = {
    id?: string
    numericId?: number
    questions?: JsonNullValueInput | InputJsonValue
    title?: string | null
    text?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    patient: PatientCreateNestedOneWithoutAnamnesisInput
    doctor: DoctorCreateNestedOneWithoutAnamnesisInput
  }

  export type AnamnesisUncheckedCreateWithoutSpecialtyInput = {
    id?: string
    numericId?: number
    patientId: string
    doctorId: string
    questions?: JsonNullValueInput | InputJsonValue
    title?: string | null
    text?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AnamnesisCreateOrConnectWithoutSpecialtyInput = {
    where: AnamnesisWhereUniqueInput
    create: XOR<AnamnesisCreateWithoutSpecialtyInput, AnamnesisUncheckedCreateWithoutSpecialtyInput>
  }

  export type AnamnesisCreateManySpecialtyInputEnvelope = {
    data: Enumerable<AnamnesisCreateManySpecialtyInput>
    skipDuplicates?: boolean
  }

  export type EvolutionCreateWithoutSpecialtyInput = {
    id?: string
    numericId?: number
    exercises?: JsonNullValueInput | InputJsonValue
    text?: string | null
    title?: string | null
    appointmentDate?: Date | string
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    patient: PatientCreateNestedOneWithoutEvolutionsInput
    doctor: DoctorCreateNestedOneWithoutEvolutionsInput
  }

  export type EvolutionUncheckedCreateWithoutSpecialtyInput = {
    id?: string
    numericId?: number
    patientId: string
    doctorId: string
    exercises?: JsonNullValueInput | InputJsonValue
    text?: string | null
    title?: string | null
    appointmentDate?: Date | string
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type EvolutionCreateOrConnectWithoutSpecialtyInput = {
    where: EvolutionWhereUniqueInput
    create: XOR<EvolutionCreateWithoutSpecialtyInput, EvolutionUncheckedCreateWithoutSpecialtyInput>
  }

  export type EvolutionCreateManySpecialtyInputEnvelope = {
    data: Enumerable<EvolutionCreateManySpecialtyInput>
    skipDuplicates?: boolean
  }

  export type ExerciseCreateWithoutSpecialtyInput = {
    id?: string
    numericId?: number
    title: string
    description: string
    links?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutExercisesInput
  }

  export type ExerciseUncheckedCreateWithoutSpecialtyInput = {
    id?: string
    numericId?: number
    title: string
    description: string
    links?: JsonNullValueInput | InputJsonValue
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExerciseCreateOrConnectWithoutSpecialtyInput = {
    where: ExerciseWhereUniqueInput
    create: XOR<ExerciseCreateWithoutSpecialtyInput, ExerciseUncheckedCreateWithoutSpecialtyInput>
  }

  export type ExerciseCreateManySpecialtyInputEnvelope = {
    data: Enumerable<ExerciseCreateManySpecialtyInput>
    skipDuplicates?: boolean
  }

  export type CourseCreateWithoutSpecialtyInput = {
    id?: string
    numericId?: number
    order?: number
    title: string
    cover?: string | null
    description: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    creator: UserCreateNestedOneWithoutCoursesInput
    lessons?: LessonCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutSpecialtyInput = {
    id?: string
    numericId?: number
    creatorId: string
    order?: number
    title: string
    cover?: string | null
    description: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    lessons?: LessonUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutSpecialtyInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutSpecialtyInput, CourseUncheckedCreateWithoutSpecialtyInput>
  }

  export type CourseCreateManySpecialtyInputEnvelope = {
    data: Enumerable<CourseCreateManySpecialtyInput>
    skipDuplicates?: boolean
  }

  export type DoctorUpsertWithWhereUniqueWithoutSpecialtyInput = {
    where: DoctorWhereUniqueInput
    update: XOR<DoctorUpdateWithoutSpecialtyInput, DoctorUncheckedUpdateWithoutSpecialtyInput>
    create: XOR<DoctorCreateWithoutSpecialtyInput, DoctorUncheckedCreateWithoutSpecialtyInput>
  }

  export type DoctorUpdateWithWhereUniqueWithoutSpecialtyInput = {
    where: DoctorWhereUniqueInput
    data: XOR<DoctorUpdateWithoutSpecialtyInput, DoctorUncheckedUpdateWithoutSpecialtyInput>
  }

  export type DoctorUpdateManyWithWhereWithoutSpecialtyInput = {
    where: DoctorScalarWhereInput
    data: XOR<DoctorUpdateManyMutationInput, DoctorUncheckedUpdateManyWithoutDoctorsInput>
  }

  export type DoctorScalarWhereInput = {
    AND?: Enumerable<DoctorScalarWhereInput>
    OR?: Enumerable<DoctorScalarWhereInput>
    NOT?: Enumerable<DoctorScalarWhereInput>
    id?: UuidFilter | string
    numericId?: IntFilter | number
    userId?: UuidFilter | string
    specialtyId?: UuidFilter | string
    crfa?: StringNullableFilter | string | null
    availability?: JsonFilter
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type TemplateUpsertWithWhereUniqueWithoutSpecialtyInput = {
    where: TemplateWhereUniqueInput
    update: XOR<TemplateUpdateWithoutSpecialtyInput, TemplateUncheckedUpdateWithoutSpecialtyInput>
    create: XOR<TemplateCreateWithoutSpecialtyInput, TemplateUncheckedCreateWithoutSpecialtyInput>
  }

  export type TemplateUpdateWithWhereUniqueWithoutSpecialtyInput = {
    where: TemplateWhereUniqueInput
    data: XOR<TemplateUpdateWithoutSpecialtyInput, TemplateUncheckedUpdateWithoutSpecialtyInput>
  }

  export type TemplateUpdateManyWithWhereWithoutSpecialtyInput = {
    where: TemplateScalarWhereInput
    data: XOR<TemplateUpdateManyMutationInput, TemplateUncheckedUpdateManyWithoutTemplatesInput>
  }

  export type EvaluationUpsertWithWhereUniqueWithoutSpecialtyInput = {
    where: EvaluationWhereUniqueInput
    update: XOR<EvaluationUpdateWithoutSpecialtyInput, EvaluationUncheckedUpdateWithoutSpecialtyInput>
    create: XOR<EvaluationCreateWithoutSpecialtyInput, EvaluationUncheckedCreateWithoutSpecialtyInput>
  }

  export type EvaluationUpdateWithWhereUniqueWithoutSpecialtyInput = {
    where: EvaluationWhereUniqueInput
    data: XOR<EvaluationUpdateWithoutSpecialtyInput, EvaluationUncheckedUpdateWithoutSpecialtyInput>
  }

  export type EvaluationUpdateManyWithWhereWithoutSpecialtyInput = {
    where: EvaluationScalarWhereInput
    data: XOR<EvaluationUpdateManyMutationInput, EvaluationUncheckedUpdateManyWithoutEvaluationsInput>
  }

  export type AnamnesisUpsertWithWhereUniqueWithoutSpecialtyInput = {
    where: AnamnesisWhereUniqueInput
    update: XOR<AnamnesisUpdateWithoutSpecialtyInput, AnamnesisUncheckedUpdateWithoutSpecialtyInput>
    create: XOR<AnamnesisCreateWithoutSpecialtyInput, AnamnesisUncheckedCreateWithoutSpecialtyInput>
  }

  export type AnamnesisUpdateWithWhereUniqueWithoutSpecialtyInput = {
    where: AnamnesisWhereUniqueInput
    data: XOR<AnamnesisUpdateWithoutSpecialtyInput, AnamnesisUncheckedUpdateWithoutSpecialtyInput>
  }

  export type AnamnesisUpdateManyWithWhereWithoutSpecialtyInput = {
    where: AnamnesisScalarWhereInput
    data: XOR<AnamnesisUpdateManyMutationInput, AnamnesisUncheckedUpdateManyWithoutAnamnesisInput>
  }

  export type EvolutionUpsertWithWhereUniqueWithoutSpecialtyInput = {
    where: EvolutionWhereUniqueInput
    update: XOR<EvolutionUpdateWithoutSpecialtyInput, EvolutionUncheckedUpdateWithoutSpecialtyInput>
    create: XOR<EvolutionCreateWithoutSpecialtyInput, EvolutionUncheckedCreateWithoutSpecialtyInput>
  }

  export type EvolutionUpdateWithWhereUniqueWithoutSpecialtyInput = {
    where: EvolutionWhereUniqueInput
    data: XOR<EvolutionUpdateWithoutSpecialtyInput, EvolutionUncheckedUpdateWithoutSpecialtyInput>
  }

  export type EvolutionUpdateManyWithWhereWithoutSpecialtyInput = {
    where: EvolutionScalarWhereInput
    data: XOR<EvolutionUpdateManyMutationInput, EvolutionUncheckedUpdateManyWithoutEvolutionInput>
  }

  export type ExerciseUpsertWithWhereUniqueWithoutSpecialtyInput = {
    where: ExerciseWhereUniqueInput
    update: XOR<ExerciseUpdateWithoutSpecialtyInput, ExerciseUncheckedUpdateWithoutSpecialtyInput>
    create: XOR<ExerciseCreateWithoutSpecialtyInput, ExerciseUncheckedCreateWithoutSpecialtyInput>
  }

  export type ExerciseUpdateWithWhereUniqueWithoutSpecialtyInput = {
    where: ExerciseWhereUniqueInput
    data: XOR<ExerciseUpdateWithoutSpecialtyInput, ExerciseUncheckedUpdateWithoutSpecialtyInput>
  }

  export type ExerciseUpdateManyWithWhereWithoutSpecialtyInput = {
    where: ExerciseScalarWhereInput
    data: XOR<ExerciseUpdateManyMutationInput, ExerciseUncheckedUpdateManyWithoutExerciseInput>
  }

  export type CourseUpsertWithWhereUniqueWithoutSpecialtyInput = {
    where: CourseWhereUniqueInput
    update: XOR<CourseUpdateWithoutSpecialtyInput, CourseUncheckedUpdateWithoutSpecialtyInput>
    create: XOR<CourseCreateWithoutSpecialtyInput, CourseUncheckedCreateWithoutSpecialtyInput>
  }

  export type CourseUpdateWithWhereUniqueWithoutSpecialtyInput = {
    where: CourseWhereUniqueInput
    data: XOR<CourseUpdateWithoutSpecialtyInput, CourseUncheckedUpdateWithoutSpecialtyInput>
  }

  export type CourseUpdateManyWithWhereWithoutSpecialtyInput = {
    where: CourseScalarWhereInput
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyWithoutCourseInput>
  }

  export type PatientCreateWithoutAnamnesisInput = {
    id?: string
    numericId?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutPatientDataInput
    evaluations?: EvaluationCreateNestedManyWithoutPatientInput
    doctorPatient?: DoctorPatientCreateNestedManyWithoutPatientInput
    evolutions?: EvolutionCreateNestedManyWithoutPatientInput
    appointment?: AppointmentCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutAnamnesisInput = {
    id?: string
    numericId?: number
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutPatientInput
    doctorPatient?: DoctorPatientUncheckedCreateNestedManyWithoutPatientInput
    evolutions?: EvolutionUncheckedCreateNestedManyWithoutPatientInput
    appointment?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutAnamnesisInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutAnamnesisInput, PatientUncheckedCreateWithoutAnamnesisInput>
  }

  export type DoctorCreateWithoutAnamnesisInput = {
    id?: string
    numericId?: number
    crfa?: string | null
    availability?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    specialty: SpecialtyCreateNestedOneWithoutDoctorsInput
    user: UserCreateNestedOneWithoutDoctorDataInput
    evaluations?: EvaluationCreateNestedManyWithoutDoctorInput
    doctorPatient?: DoctorPatientCreateNestedManyWithoutDoctorInput
    templates?: TemplateCreateNestedManyWithoutDoctorInput
    evolutions?: EvolutionCreateNestedManyWithoutDoctorInput
    appointments?: AppointmentCreateNestedManyWithoutDoctorInput
  }

  export type DoctorUncheckedCreateWithoutAnamnesisInput = {
    id?: string
    numericId?: number
    userId: string
    specialtyId: string
    crfa?: string | null
    availability?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutDoctorInput
    doctorPatient?: DoctorPatientUncheckedCreateNestedManyWithoutDoctorInput
    templates?: TemplateUncheckedCreateNestedManyWithoutDoctorInput
    evolutions?: EvolutionUncheckedCreateNestedManyWithoutDoctorInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
  }

  export type DoctorCreateOrConnectWithoutAnamnesisInput = {
    where: DoctorWhereUniqueInput
    create: XOR<DoctorCreateWithoutAnamnesisInput, DoctorUncheckedCreateWithoutAnamnesisInput>
  }

  export type SpecialtyCreateWithoutAnamnesisInput = {
    id?: string
    numericId?: number
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    doctors?: DoctorCreateNestedManyWithoutSpecialtyInput
    templates?: TemplateCreateNestedManyWithoutSpecialtyInput
    evaluations?: EvaluationCreateNestedManyWithoutSpecialtyInput
    evolution?: EvolutionCreateNestedManyWithoutSpecialtyInput
    exercise?: ExerciseCreateNestedManyWithoutSpecialtyInput
    course?: CourseCreateNestedManyWithoutSpecialtyInput
  }

  export type SpecialtyUncheckedCreateWithoutAnamnesisInput = {
    id?: string
    numericId?: number
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    doctors?: DoctorUncheckedCreateNestedManyWithoutSpecialtyInput
    templates?: TemplateUncheckedCreateNestedManyWithoutSpecialtyInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutSpecialtyInput
    evolution?: EvolutionUncheckedCreateNestedManyWithoutSpecialtyInput
    exercise?: ExerciseUncheckedCreateNestedManyWithoutSpecialtyInput
    course?: CourseUncheckedCreateNestedManyWithoutSpecialtyInput
  }

  export type SpecialtyCreateOrConnectWithoutAnamnesisInput = {
    where: SpecialtyWhereUniqueInput
    create: XOR<SpecialtyCreateWithoutAnamnesisInput, SpecialtyUncheckedCreateWithoutAnamnesisInput>
  }

  export type PatientUpsertWithoutAnamnesisInput = {
    update: XOR<PatientUpdateWithoutAnamnesisInput, PatientUncheckedUpdateWithoutAnamnesisInput>
    create: XOR<PatientCreateWithoutAnamnesisInput, PatientUncheckedCreateWithoutAnamnesisInput>
  }

  export type PatientUpdateWithoutAnamnesisInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutPatientDataNestedInput
    evaluations?: EvaluationUpdateManyWithoutPatientNestedInput
    doctorPatient?: DoctorPatientUpdateManyWithoutPatientNestedInput
    evolutions?: EvolutionUpdateManyWithoutPatientNestedInput
    appointment?: AppointmentUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutAnamnesisInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    evaluations?: EvaluationUncheckedUpdateManyWithoutPatientNestedInput
    doctorPatient?: DoctorPatientUncheckedUpdateManyWithoutPatientNestedInput
    evolutions?: EvolutionUncheckedUpdateManyWithoutPatientNestedInput
    appointment?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type DoctorUpsertWithoutAnamnesisInput = {
    update: XOR<DoctorUpdateWithoutAnamnesisInput, DoctorUncheckedUpdateWithoutAnamnesisInput>
    create: XOR<DoctorCreateWithoutAnamnesisInput, DoctorUncheckedCreateWithoutAnamnesisInput>
  }

  export type DoctorUpdateWithoutAnamnesisInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    crfa?: NullableStringFieldUpdateOperationsInput | string | null
    availability?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    specialty?: SpecialtyUpdateOneRequiredWithoutDoctorsNestedInput
    user?: UserUpdateOneRequiredWithoutDoctorDataNestedInput
    evaluations?: EvaluationUpdateManyWithoutDoctorNestedInput
    doctorPatient?: DoctorPatientUpdateManyWithoutDoctorNestedInput
    templates?: TemplateUpdateManyWithoutDoctorNestedInput
    evolutions?: EvolutionUpdateManyWithoutDoctorNestedInput
    appointments?: AppointmentUpdateManyWithoutDoctorNestedInput
  }

  export type DoctorUncheckedUpdateWithoutAnamnesisInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    specialtyId?: StringFieldUpdateOperationsInput | string
    crfa?: NullableStringFieldUpdateOperationsInput | string | null
    availability?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    evaluations?: EvaluationUncheckedUpdateManyWithoutDoctorNestedInput
    doctorPatient?: DoctorPatientUncheckedUpdateManyWithoutDoctorNestedInput
    templates?: TemplateUncheckedUpdateManyWithoutDoctorNestedInput
    evolutions?: EvolutionUncheckedUpdateManyWithoutDoctorNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
  }

  export type SpecialtyUpsertWithoutAnamnesisInput = {
    update: XOR<SpecialtyUpdateWithoutAnamnesisInput, SpecialtyUncheckedUpdateWithoutAnamnesisInput>
    create: XOR<SpecialtyCreateWithoutAnamnesisInput, SpecialtyUncheckedCreateWithoutAnamnesisInput>
  }

  export type SpecialtyUpdateWithoutAnamnesisInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctors?: DoctorUpdateManyWithoutSpecialtyNestedInput
    templates?: TemplateUpdateManyWithoutSpecialtyNestedInput
    evaluations?: EvaluationUpdateManyWithoutSpecialtyNestedInput
    evolution?: EvolutionUpdateManyWithoutSpecialtyNestedInput
    exercise?: ExerciseUpdateManyWithoutSpecialtyNestedInput
    course?: CourseUpdateManyWithoutSpecialtyNestedInput
  }

  export type SpecialtyUncheckedUpdateWithoutAnamnesisInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctors?: DoctorUncheckedUpdateManyWithoutSpecialtyNestedInput
    templates?: TemplateUncheckedUpdateManyWithoutSpecialtyNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutSpecialtyNestedInput
    evolution?: EvolutionUncheckedUpdateManyWithoutSpecialtyNestedInput
    exercise?: ExerciseUncheckedUpdateManyWithoutSpecialtyNestedInput
    course?: CourseUncheckedUpdateManyWithoutSpecialtyNestedInput
  }

  export type PatientCreateWithoutEvolutionsInput = {
    id?: string
    numericId?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutPatientDataInput
    anamnesis?: AnamnesisCreateNestedManyWithoutPatientInput
    evaluations?: EvaluationCreateNestedManyWithoutPatientInput
    doctorPatient?: DoctorPatientCreateNestedManyWithoutPatientInput
    appointment?: AppointmentCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutEvolutionsInput = {
    id?: string
    numericId?: number
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    anamnesis?: AnamnesisUncheckedCreateNestedManyWithoutPatientInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutPatientInput
    doctorPatient?: DoctorPatientUncheckedCreateNestedManyWithoutPatientInput
    appointment?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutEvolutionsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutEvolutionsInput, PatientUncheckedCreateWithoutEvolutionsInput>
  }

  export type DoctorCreateWithoutEvolutionsInput = {
    id?: string
    numericId?: number
    crfa?: string | null
    availability?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    specialty: SpecialtyCreateNestedOneWithoutDoctorsInput
    user: UserCreateNestedOneWithoutDoctorDataInput
    anamnesis?: AnamnesisCreateNestedManyWithoutDoctorInput
    evaluations?: EvaluationCreateNestedManyWithoutDoctorInput
    doctorPatient?: DoctorPatientCreateNestedManyWithoutDoctorInput
    templates?: TemplateCreateNestedManyWithoutDoctorInput
    appointments?: AppointmentCreateNestedManyWithoutDoctorInput
  }

  export type DoctorUncheckedCreateWithoutEvolutionsInput = {
    id?: string
    numericId?: number
    userId: string
    specialtyId: string
    crfa?: string | null
    availability?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    anamnesis?: AnamnesisUncheckedCreateNestedManyWithoutDoctorInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutDoctorInput
    doctorPatient?: DoctorPatientUncheckedCreateNestedManyWithoutDoctorInput
    templates?: TemplateUncheckedCreateNestedManyWithoutDoctorInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
  }

  export type DoctorCreateOrConnectWithoutEvolutionsInput = {
    where: DoctorWhereUniqueInput
    create: XOR<DoctorCreateWithoutEvolutionsInput, DoctorUncheckedCreateWithoutEvolutionsInput>
  }

  export type SpecialtyCreateWithoutEvolutionInput = {
    id?: string
    numericId?: number
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    doctors?: DoctorCreateNestedManyWithoutSpecialtyInput
    templates?: TemplateCreateNestedManyWithoutSpecialtyInput
    evaluations?: EvaluationCreateNestedManyWithoutSpecialtyInput
    anamnesis?: AnamnesisCreateNestedManyWithoutSpecialtyInput
    exercise?: ExerciseCreateNestedManyWithoutSpecialtyInput
    course?: CourseCreateNestedManyWithoutSpecialtyInput
  }

  export type SpecialtyUncheckedCreateWithoutEvolutionInput = {
    id?: string
    numericId?: number
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    doctors?: DoctorUncheckedCreateNestedManyWithoutSpecialtyInput
    templates?: TemplateUncheckedCreateNestedManyWithoutSpecialtyInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutSpecialtyInput
    anamnesis?: AnamnesisUncheckedCreateNestedManyWithoutSpecialtyInput
    exercise?: ExerciseUncheckedCreateNestedManyWithoutSpecialtyInput
    course?: CourseUncheckedCreateNestedManyWithoutSpecialtyInput
  }

  export type SpecialtyCreateOrConnectWithoutEvolutionInput = {
    where: SpecialtyWhereUniqueInput
    create: XOR<SpecialtyCreateWithoutEvolutionInput, SpecialtyUncheckedCreateWithoutEvolutionInput>
  }

  export type PatientUpsertWithoutEvolutionsInput = {
    update: XOR<PatientUpdateWithoutEvolutionsInput, PatientUncheckedUpdateWithoutEvolutionsInput>
    create: XOR<PatientCreateWithoutEvolutionsInput, PatientUncheckedCreateWithoutEvolutionsInput>
  }

  export type PatientUpdateWithoutEvolutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutPatientDataNestedInput
    anamnesis?: AnamnesisUpdateManyWithoutPatientNestedInput
    evaluations?: EvaluationUpdateManyWithoutPatientNestedInput
    doctorPatient?: DoctorPatientUpdateManyWithoutPatientNestedInput
    appointment?: AppointmentUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutEvolutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    anamnesis?: AnamnesisUncheckedUpdateManyWithoutPatientNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutPatientNestedInput
    doctorPatient?: DoctorPatientUncheckedUpdateManyWithoutPatientNestedInput
    appointment?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type DoctorUpsertWithoutEvolutionsInput = {
    update: XOR<DoctorUpdateWithoutEvolutionsInput, DoctorUncheckedUpdateWithoutEvolutionsInput>
    create: XOR<DoctorCreateWithoutEvolutionsInput, DoctorUncheckedCreateWithoutEvolutionsInput>
  }

  export type DoctorUpdateWithoutEvolutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    crfa?: NullableStringFieldUpdateOperationsInput | string | null
    availability?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    specialty?: SpecialtyUpdateOneRequiredWithoutDoctorsNestedInput
    user?: UserUpdateOneRequiredWithoutDoctorDataNestedInput
    anamnesis?: AnamnesisUpdateManyWithoutDoctorNestedInput
    evaluations?: EvaluationUpdateManyWithoutDoctorNestedInput
    doctorPatient?: DoctorPatientUpdateManyWithoutDoctorNestedInput
    templates?: TemplateUpdateManyWithoutDoctorNestedInput
    appointments?: AppointmentUpdateManyWithoutDoctorNestedInput
  }

  export type DoctorUncheckedUpdateWithoutEvolutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    specialtyId?: StringFieldUpdateOperationsInput | string
    crfa?: NullableStringFieldUpdateOperationsInput | string | null
    availability?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    anamnesis?: AnamnesisUncheckedUpdateManyWithoutDoctorNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutDoctorNestedInput
    doctorPatient?: DoctorPatientUncheckedUpdateManyWithoutDoctorNestedInput
    templates?: TemplateUncheckedUpdateManyWithoutDoctorNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
  }

  export type SpecialtyUpsertWithoutEvolutionInput = {
    update: XOR<SpecialtyUpdateWithoutEvolutionInput, SpecialtyUncheckedUpdateWithoutEvolutionInput>
    create: XOR<SpecialtyCreateWithoutEvolutionInput, SpecialtyUncheckedCreateWithoutEvolutionInput>
  }

  export type SpecialtyUpdateWithoutEvolutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctors?: DoctorUpdateManyWithoutSpecialtyNestedInput
    templates?: TemplateUpdateManyWithoutSpecialtyNestedInput
    evaluations?: EvaluationUpdateManyWithoutSpecialtyNestedInput
    anamnesis?: AnamnesisUpdateManyWithoutSpecialtyNestedInput
    exercise?: ExerciseUpdateManyWithoutSpecialtyNestedInput
    course?: CourseUpdateManyWithoutSpecialtyNestedInput
  }

  export type SpecialtyUncheckedUpdateWithoutEvolutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctors?: DoctorUncheckedUpdateManyWithoutSpecialtyNestedInput
    templates?: TemplateUncheckedUpdateManyWithoutSpecialtyNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutSpecialtyNestedInput
    anamnesis?: AnamnesisUncheckedUpdateManyWithoutSpecialtyNestedInput
    exercise?: ExerciseUncheckedUpdateManyWithoutSpecialtyNestedInput
    course?: CourseUncheckedUpdateManyWithoutSpecialtyNestedInput
  }

  export type PatientCreateWithoutEvaluationsInput = {
    id?: string
    numericId?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutPatientDataInput
    anamnesis?: AnamnesisCreateNestedManyWithoutPatientInput
    doctorPatient?: DoctorPatientCreateNestedManyWithoutPatientInput
    evolutions?: EvolutionCreateNestedManyWithoutPatientInput
    appointment?: AppointmentCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutEvaluationsInput = {
    id?: string
    numericId?: number
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    anamnesis?: AnamnesisUncheckedCreateNestedManyWithoutPatientInput
    doctorPatient?: DoctorPatientUncheckedCreateNestedManyWithoutPatientInput
    evolutions?: EvolutionUncheckedCreateNestedManyWithoutPatientInput
    appointment?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutEvaluationsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutEvaluationsInput, PatientUncheckedCreateWithoutEvaluationsInput>
  }

  export type DoctorCreateWithoutEvaluationsInput = {
    id?: string
    numericId?: number
    crfa?: string | null
    availability?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    specialty: SpecialtyCreateNestedOneWithoutDoctorsInput
    user: UserCreateNestedOneWithoutDoctorDataInput
    anamnesis?: AnamnesisCreateNestedManyWithoutDoctorInput
    doctorPatient?: DoctorPatientCreateNestedManyWithoutDoctorInput
    templates?: TemplateCreateNestedManyWithoutDoctorInput
    evolutions?: EvolutionCreateNestedManyWithoutDoctorInput
    appointments?: AppointmentCreateNestedManyWithoutDoctorInput
  }

  export type DoctorUncheckedCreateWithoutEvaluationsInput = {
    id?: string
    numericId?: number
    userId: string
    specialtyId: string
    crfa?: string | null
    availability?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    anamnesis?: AnamnesisUncheckedCreateNestedManyWithoutDoctorInput
    doctorPatient?: DoctorPatientUncheckedCreateNestedManyWithoutDoctorInput
    templates?: TemplateUncheckedCreateNestedManyWithoutDoctorInput
    evolutions?: EvolutionUncheckedCreateNestedManyWithoutDoctorInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
  }

  export type DoctorCreateOrConnectWithoutEvaluationsInput = {
    where: DoctorWhereUniqueInput
    create: XOR<DoctorCreateWithoutEvaluationsInput, DoctorUncheckedCreateWithoutEvaluationsInput>
  }

  export type SpecialtyCreateWithoutEvaluationsInput = {
    id?: string
    numericId?: number
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    doctors?: DoctorCreateNestedManyWithoutSpecialtyInput
    templates?: TemplateCreateNestedManyWithoutSpecialtyInput
    anamnesis?: AnamnesisCreateNestedManyWithoutSpecialtyInput
    evolution?: EvolutionCreateNestedManyWithoutSpecialtyInput
    exercise?: ExerciseCreateNestedManyWithoutSpecialtyInput
    course?: CourseCreateNestedManyWithoutSpecialtyInput
  }

  export type SpecialtyUncheckedCreateWithoutEvaluationsInput = {
    id?: string
    numericId?: number
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    doctors?: DoctorUncheckedCreateNestedManyWithoutSpecialtyInput
    templates?: TemplateUncheckedCreateNestedManyWithoutSpecialtyInput
    anamnesis?: AnamnesisUncheckedCreateNestedManyWithoutSpecialtyInput
    evolution?: EvolutionUncheckedCreateNestedManyWithoutSpecialtyInput
    exercise?: ExerciseUncheckedCreateNestedManyWithoutSpecialtyInput
    course?: CourseUncheckedCreateNestedManyWithoutSpecialtyInput
  }

  export type SpecialtyCreateOrConnectWithoutEvaluationsInput = {
    where: SpecialtyWhereUniqueInput
    create: XOR<SpecialtyCreateWithoutEvaluationsInput, SpecialtyUncheckedCreateWithoutEvaluationsInput>
  }

  export type PatientUpsertWithoutEvaluationsInput = {
    update: XOR<PatientUpdateWithoutEvaluationsInput, PatientUncheckedUpdateWithoutEvaluationsInput>
    create: XOR<PatientCreateWithoutEvaluationsInput, PatientUncheckedCreateWithoutEvaluationsInput>
  }

  export type PatientUpdateWithoutEvaluationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutPatientDataNestedInput
    anamnesis?: AnamnesisUpdateManyWithoutPatientNestedInput
    doctorPatient?: DoctorPatientUpdateManyWithoutPatientNestedInput
    evolutions?: EvolutionUpdateManyWithoutPatientNestedInput
    appointment?: AppointmentUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutEvaluationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    anamnesis?: AnamnesisUncheckedUpdateManyWithoutPatientNestedInput
    doctorPatient?: DoctorPatientUncheckedUpdateManyWithoutPatientNestedInput
    evolutions?: EvolutionUncheckedUpdateManyWithoutPatientNestedInput
    appointment?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type DoctorUpsertWithoutEvaluationsInput = {
    update: XOR<DoctorUpdateWithoutEvaluationsInput, DoctorUncheckedUpdateWithoutEvaluationsInput>
    create: XOR<DoctorCreateWithoutEvaluationsInput, DoctorUncheckedCreateWithoutEvaluationsInput>
  }

  export type DoctorUpdateWithoutEvaluationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    crfa?: NullableStringFieldUpdateOperationsInput | string | null
    availability?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    specialty?: SpecialtyUpdateOneRequiredWithoutDoctorsNestedInput
    user?: UserUpdateOneRequiredWithoutDoctorDataNestedInput
    anamnesis?: AnamnesisUpdateManyWithoutDoctorNestedInput
    doctorPatient?: DoctorPatientUpdateManyWithoutDoctorNestedInput
    templates?: TemplateUpdateManyWithoutDoctorNestedInput
    evolutions?: EvolutionUpdateManyWithoutDoctorNestedInput
    appointments?: AppointmentUpdateManyWithoutDoctorNestedInput
  }

  export type DoctorUncheckedUpdateWithoutEvaluationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    specialtyId?: StringFieldUpdateOperationsInput | string
    crfa?: NullableStringFieldUpdateOperationsInput | string | null
    availability?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    anamnesis?: AnamnesisUncheckedUpdateManyWithoutDoctorNestedInput
    doctorPatient?: DoctorPatientUncheckedUpdateManyWithoutDoctorNestedInput
    templates?: TemplateUncheckedUpdateManyWithoutDoctorNestedInput
    evolutions?: EvolutionUncheckedUpdateManyWithoutDoctorNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
  }

  export type SpecialtyUpsertWithoutEvaluationsInput = {
    update: XOR<SpecialtyUpdateWithoutEvaluationsInput, SpecialtyUncheckedUpdateWithoutEvaluationsInput>
    create: XOR<SpecialtyCreateWithoutEvaluationsInput, SpecialtyUncheckedCreateWithoutEvaluationsInput>
  }

  export type SpecialtyUpdateWithoutEvaluationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctors?: DoctorUpdateManyWithoutSpecialtyNestedInput
    templates?: TemplateUpdateManyWithoutSpecialtyNestedInput
    anamnesis?: AnamnesisUpdateManyWithoutSpecialtyNestedInput
    evolution?: EvolutionUpdateManyWithoutSpecialtyNestedInput
    exercise?: ExerciseUpdateManyWithoutSpecialtyNestedInput
    course?: CourseUpdateManyWithoutSpecialtyNestedInput
  }

  export type SpecialtyUncheckedUpdateWithoutEvaluationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctors?: DoctorUncheckedUpdateManyWithoutSpecialtyNestedInput
    templates?: TemplateUncheckedUpdateManyWithoutSpecialtyNestedInput
    anamnesis?: AnamnesisUncheckedUpdateManyWithoutSpecialtyNestedInput
    evolution?: EvolutionUncheckedUpdateManyWithoutSpecialtyNestedInput
    exercise?: ExerciseUncheckedUpdateManyWithoutSpecialtyNestedInput
    course?: CourseUncheckedUpdateManyWithoutSpecialtyNestedInput
  }

  export type UserCreateWithoutExercisesInput = {
    id?: string
    numericId?: number
    socialName?: string | null
    email: string
    name: string
    gender?: string | null
    customGender?: string | null
    cpf?: string | null
    birthDate?: Date | string | null
    password: string
    type?: UserType
    avatar?: string | null
    facebookToken?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    isAdmin?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    patientData?: PatientCreateNestedOneWithoutUserInput
    doctorData?: DoctorCreateNestedOneWithoutUserInput
    addresses?: UserAdressCreateNestedManyWithoutUserInput
    contacts?: UserContactCreateNestedManyWithoutUserInput
    DoctorPatient?: DoctorPatientCreateNestedManyWithoutAssignedByInput
    courses?: CourseCreateNestedManyWithoutCreatorInput
    lessons?: LessonCreateNestedManyWithoutCreatorInput
    watched?: WatchedVideoCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutExercisesInput = {
    id?: string
    numericId?: number
    socialName?: string | null
    email: string
    name: string
    gender?: string | null
    customGender?: string | null
    cpf?: string | null
    birthDate?: Date | string | null
    password: string
    type?: UserType
    avatar?: string | null
    facebookToken?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    isAdmin?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    patientData?: PatientUncheckedCreateNestedOneWithoutUserInput
    doctorData?: DoctorUncheckedCreateNestedOneWithoutUserInput
    addresses?: UserAdressUncheckedCreateNestedManyWithoutUserInput
    contacts?: UserContactUncheckedCreateNestedManyWithoutUserInput
    DoctorPatient?: DoctorPatientUncheckedCreateNestedManyWithoutAssignedByInput
    courses?: CourseUncheckedCreateNestedManyWithoutCreatorInput
    lessons?: LessonUncheckedCreateNestedManyWithoutCreatorInput
    watched?: WatchedVideoUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutExercisesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutExercisesInput, UserUncheckedCreateWithoutExercisesInput>
  }

  export type SpecialtyCreateWithoutExerciseInput = {
    id?: string
    numericId?: number
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    doctors?: DoctorCreateNestedManyWithoutSpecialtyInput
    templates?: TemplateCreateNestedManyWithoutSpecialtyInput
    evaluations?: EvaluationCreateNestedManyWithoutSpecialtyInput
    anamnesis?: AnamnesisCreateNestedManyWithoutSpecialtyInput
    evolution?: EvolutionCreateNestedManyWithoutSpecialtyInput
    course?: CourseCreateNestedManyWithoutSpecialtyInput
  }

  export type SpecialtyUncheckedCreateWithoutExerciseInput = {
    id?: string
    numericId?: number
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    doctors?: DoctorUncheckedCreateNestedManyWithoutSpecialtyInput
    templates?: TemplateUncheckedCreateNestedManyWithoutSpecialtyInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutSpecialtyInput
    anamnesis?: AnamnesisUncheckedCreateNestedManyWithoutSpecialtyInput
    evolution?: EvolutionUncheckedCreateNestedManyWithoutSpecialtyInput
    course?: CourseUncheckedCreateNestedManyWithoutSpecialtyInput
  }

  export type SpecialtyCreateOrConnectWithoutExerciseInput = {
    where: SpecialtyWhereUniqueInput
    create: XOR<SpecialtyCreateWithoutExerciseInput, SpecialtyUncheckedCreateWithoutExerciseInput>
  }

  export type UserUpsertWithoutExercisesInput = {
    update: XOR<UserUpdateWithoutExercisesInput, UserUncheckedUpdateWithoutExercisesInput>
    create: XOR<UserCreateWithoutExercisesInput, UserUncheckedCreateWithoutExercisesInput>
  }

  export type UserUpdateWithoutExercisesInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    socialName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    customGender?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    type?: EnumUserTypeFieldUpdateOperationsInput | UserType
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    facebookToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patientData?: PatientUpdateOneWithoutUserNestedInput
    doctorData?: DoctorUpdateOneWithoutUserNestedInput
    addresses?: UserAdressUpdateManyWithoutUserNestedInput
    contacts?: UserContactUpdateManyWithoutUserNestedInput
    DoctorPatient?: DoctorPatientUpdateManyWithoutAssignedByNestedInput
    courses?: CourseUpdateManyWithoutCreatorNestedInput
    lessons?: LessonUpdateManyWithoutCreatorNestedInput
    watched?: WatchedVideoUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutExercisesInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    socialName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    customGender?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    type?: EnumUserTypeFieldUpdateOperationsInput | UserType
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    facebookToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patientData?: PatientUncheckedUpdateOneWithoutUserNestedInput
    doctorData?: DoctorUncheckedUpdateOneWithoutUserNestedInput
    addresses?: UserAdressUncheckedUpdateManyWithoutUserNestedInput
    contacts?: UserContactUncheckedUpdateManyWithoutUserNestedInput
    DoctorPatient?: DoctorPatientUncheckedUpdateManyWithoutAssignedByNestedInput
    courses?: CourseUncheckedUpdateManyWithoutCreatorNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutCreatorNestedInput
    watched?: WatchedVideoUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SpecialtyUpsertWithoutExerciseInput = {
    update: XOR<SpecialtyUpdateWithoutExerciseInput, SpecialtyUncheckedUpdateWithoutExerciseInput>
    create: XOR<SpecialtyCreateWithoutExerciseInput, SpecialtyUncheckedCreateWithoutExerciseInput>
  }

  export type SpecialtyUpdateWithoutExerciseInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctors?: DoctorUpdateManyWithoutSpecialtyNestedInput
    templates?: TemplateUpdateManyWithoutSpecialtyNestedInput
    evaluations?: EvaluationUpdateManyWithoutSpecialtyNestedInput
    anamnesis?: AnamnesisUpdateManyWithoutSpecialtyNestedInput
    evolution?: EvolutionUpdateManyWithoutSpecialtyNestedInput
    course?: CourseUpdateManyWithoutSpecialtyNestedInput
  }

  export type SpecialtyUncheckedUpdateWithoutExerciseInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctors?: DoctorUncheckedUpdateManyWithoutSpecialtyNestedInput
    templates?: TemplateUncheckedUpdateManyWithoutSpecialtyNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutSpecialtyNestedInput
    anamnesis?: AnamnesisUncheckedUpdateManyWithoutSpecialtyNestedInput
    evolution?: EvolutionUncheckedUpdateManyWithoutSpecialtyNestedInput
    course?: CourseUncheckedUpdateManyWithoutSpecialtyNestedInput
  }

  export type DoctorCreateWithoutTemplatesInput = {
    id?: string
    numericId?: number
    crfa?: string | null
    availability?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    specialty: SpecialtyCreateNestedOneWithoutDoctorsInput
    user: UserCreateNestedOneWithoutDoctorDataInput
    anamnesis?: AnamnesisCreateNestedManyWithoutDoctorInput
    evaluations?: EvaluationCreateNestedManyWithoutDoctorInput
    doctorPatient?: DoctorPatientCreateNestedManyWithoutDoctorInput
    evolutions?: EvolutionCreateNestedManyWithoutDoctorInput
    appointments?: AppointmentCreateNestedManyWithoutDoctorInput
  }

  export type DoctorUncheckedCreateWithoutTemplatesInput = {
    id?: string
    numericId?: number
    userId: string
    specialtyId: string
    crfa?: string | null
    availability?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    anamnesis?: AnamnesisUncheckedCreateNestedManyWithoutDoctorInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutDoctorInput
    doctorPatient?: DoctorPatientUncheckedCreateNestedManyWithoutDoctorInput
    evolutions?: EvolutionUncheckedCreateNestedManyWithoutDoctorInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
  }

  export type DoctorCreateOrConnectWithoutTemplatesInput = {
    where: DoctorWhereUniqueInput
    create: XOR<DoctorCreateWithoutTemplatesInput, DoctorUncheckedCreateWithoutTemplatesInput>
  }

  export type SpecialtyCreateWithoutTemplatesInput = {
    id?: string
    numericId?: number
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    doctors?: DoctorCreateNestedManyWithoutSpecialtyInput
    evaluations?: EvaluationCreateNestedManyWithoutSpecialtyInput
    anamnesis?: AnamnesisCreateNestedManyWithoutSpecialtyInput
    evolution?: EvolutionCreateNestedManyWithoutSpecialtyInput
    exercise?: ExerciseCreateNestedManyWithoutSpecialtyInput
    course?: CourseCreateNestedManyWithoutSpecialtyInput
  }

  export type SpecialtyUncheckedCreateWithoutTemplatesInput = {
    id?: string
    numericId?: number
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    doctors?: DoctorUncheckedCreateNestedManyWithoutSpecialtyInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutSpecialtyInput
    anamnesis?: AnamnesisUncheckedCreateNestedManyWithoutSpecialtyInput
    evolution?: EvolutionUncheckedCreateNestedManyWithoutSpecialtyInput
    exercise?: ExerciseUncheckedCreateNestedManyWithoutSpecialtyInput
    course?: CourseUncheckedCreateNestedManyWithoutSpecialtyInput
  }

  export type SpecialtyCreateOrConnectWithoutTemplatesInput = {
    where: SpecialtyWhereUniqueInput
    create: XOR<SpecialtyCreateWithoutTemplatesInput, SpecialtyUncheckedCreateWithoutTemplatesInput>
  }

  export type DoctorUpsertWithoutTemplatesInput = {
    update: XOR<DoctorUpdateWithoutTemplatesInput, DoctorUncheckedUpdateWithoutTemplatesInput>
    create: XOR<DoctorCreateWithoutTemplatesInput, DoctorUncheckedCreateWithoutTemplatesInput>
  }

  export type DoctorUpdateWithoutTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    crfa?: NullableStringFieldUpdateOperationsInput | string | null
    availability?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    specialty?: SpecialtyUpdateOneRequiredWithoutDoctorsNestedInput
    user?: UserUpdateOneRequiredWithoutDoctorDataNestedInput
    anamnesis?: AnamnesisUpdateManyWithoutDoctorNestedInput
    evaluations?: EvaluationUpdateManyWithoutDoctorNestedInput
    doctorPatient?: DoctorPatientUpdateManyWithoutDoctorNestedInput
    evolutions?: EvolutionUpdateManyWithoutDoctorNestedInput
    appointments?: AppointmentUpdateManyWithoutDoctorNestedInput
  }

  export type DoctorUncheckedUpdateWithoutTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    specialtyId?: StringFieldUpdateOperationsInput | string
    crfa?: NullableStringFieldUpdateOperationsInput | string | null
    availability?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    anamnesis?: AnamnesisUncheckedUpdateManyWithoutDoctorNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutDoctorNestedInput
    doctorPatient?: DoctorPatientUncheckedUpdateManyWithoutDoctorNestedInput
    evolutions?: EvolutionUncheckedUpdateManyWithoutDoctorNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
  }

  export type SpecialtyUpsertWithoutTemplatesInput = {
    update: XOR<SpecialtyUpdateWithoutTemplatesInput, SpecialtyUncheckedUpdateWithoutTemplatesInput>
    create: XOR<SpecialtyCreateWithoutTemplatesInput, SpecialtyUncheckedCreateWithoutTemplatesInput>
  }

  export type SpecialtyUpdateWithoutTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctors?: DoctorUpdateManyWithoutSpecialtyNestedInput
    evaluations?: EvaluationUpdateManyWithoutSpecialtyNestedInput
    anamnesis?: AnamnesisUpdateManyWithoutSpecialtyNestedInput
    evolution?: EvolutionUpdateManyWithoutSpecialtyNestedInput
    exercise?: ExerciseUpdateManyWithoutSpecialtyNestedInput
    course?: CourseUpdateManyWithoutSpecialtyNestedInput
  }

  export type SpecialtyUncheckedUpdateWithoutTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctors?: DoctorUncheckedUpdateManyWithoutSpecialtyNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutSpecialtyNestedInput
    anamnesis?: AnamnesisUncheckedUpdateManyWithoutSpecialtyNestedInput
    evolution?: EvolutionUncheckedUpdateManyWithoutSpecialtyNestedInput
    exercise?: ExerciseUncheckedUpdateManyWithoutSpecialtyNestedInput
    course?: CourseUncheckedUpdateManyWithoutSpecialtyNestedInput
  }

  export type UserCreateWithoutCoursesInput = {
    id?: string
    numericId?: number
    socialName?: string | null
    email: string
    name: string
    gender?: string | null
    customGender?: string | null
    cpf?: string | null
    birthDate?: Date | string | null
    password: string
    type?: UserType
    avatar?: string | null
    facebookToken?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    isAdmin?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    patientData?: PatientCreateNestedOneWithoutUserInput
    doctorData?: DoctorCreateNestedOneWithoutUserInput
    addresses?: UserAdressCreateNestedManyWithoutUserInput
    contacts?: UserContactCreateNestedManyWithoutUserInput
    DoctorPatient?: DoctorPatientCreateNestedManyWithoutAssignedByInput
    exercises?: ExerciseCreateNestedManyWithoutCreatorInput
    lessons?: LessonCreateNestedManyWithoutCreatorInput
    watched?: WatchedVideoCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCoursesInput = {
    id?: string
    numericId?: number
    socialName?: string | null
    email: string
    name: string
    gender?: string | null
    customGender?: string | null
    cpf?: string | null
    birthDate?: Date | string | null
    password: string
    type?: UserType
    avatar?: string | null
    facebookToken?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    isAdmin?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    patientData?: PatientUncheckedCreateNestedOneWithoutUserInput
    doctorData?: DoctorUncheckedCreateNestedOneWithoutUserInput
    addresses?: UserAdressUncheckedCreateNestedManyWithoutUserInput
    contacts?: UserContactUncheckedCreateNestedManyWithoutUserInput
    DoctorPatient?: DoctorPatientUncheckedCreateNestedManyWithoutAssignedByInput
    exercises?: ExerciseUncheckedCreateNestedManyWithoutCreatorInput
    lessons?: LessonUncheckedCreateNestedManyWithoutCreatorInput
    watched?: WatchedVideoUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCoursesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCoursesInput, UserUncheckedCreateWithoutCoursesInput>
  }

  export type SpecialtyCreateWithoutCourseInput = {
    id?: string
    numericId?: number
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    doctors?: DoctorCreateNestedManyWithoutSpecialtyInput
    templates?: TemplateCreateNestedManyWithoutSpecialtyInput
    evaluations?: EvaluationCreateNestedManyWithoutSpecialtyInput
    anamnesis?: AnamnesisCreateNestedManyWithoutSpecialtyInput
    evolution?: EvolutionCreateNestedManyWithoutSpecialtyInput
    exercise?: ExerciseCreateNestedManyWithoutSpecialtyInput
  }

  export type SpecialtyUncheckedCreateWithoutCourseInput = {
    id?: string
    numericId?: number
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    doctors?: DoctorUncheckedCreateNestedManyWithoutSpecialtyInput
    templates?: TemplateUncheckedCreateNestedManyWithoutSpecialtyInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutSpecialtyInput
    anamnesis?: AnamnesisUncheckedCreateNestedManyWithoutSpecialtyInput
    evolution?: EvolutionUncheckedCreateNestedManyWithoutSpecialtyInput
    exercise?: ExerciseUncheckedCreateNestedManyWithoutSpecialtyInput
  }

  export type SpecialtyCreateOrConnectWithoutCourseInput = {
    where: SpecialtyWhereUniqueInput
    create: XOR<SpecialtyCreateWithoutCourseInput, SpecialtyUncheckedCreateWithoutCourseInput>
  }

  export type LessonCreateWithoutCourseInput = {
    id?: string
    numericId?: number
    order?: number
    title: string
    description: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    creator: UserCreateNestedOneWithoutLessonsInput
    videos?: LessonVideoCreateNestedManyWithoutLessonInput
  }

  export type LessonUncheckedCreateWithoutCourseInput = {
    id?: string
    numericId?: number
    creatorId: string
    order?: number
    title: string
    description: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    videos?: LessonVideoUncheckedCreateNestedManyWithoutLessonInput
  }

  export type LessonCreateOrConnectWithoutCourseInput = {
    where: LessonWhereUniqueInput
    create: XOR<LessonCreateWithoutCourseInput, LessonUncheckedCreateWithoutCourseInput>
  }

  export type LessonCreateManyCourseInputEnvelope = {
    data: Enumerable<LessonCreateManyCourseInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCoursesInput = {
    update: XOR<UserUpdateWithoutCoursesInput, UserUncheckedUpdateWithoutCoursesInput>
    create: XOR<UserCreateWithoutCoursesInput, UserUncheckedCreateWithoutCoursesInput>
  }

  export type UserUpdateWithoutCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    socialName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    customGender?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    type?: EnumUserTypeFieldUpdateOperationsInput | UserType
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    facebookToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patientData?: PatientUpdateOneWithoutUserNestedInput
    doctorData?: DoctorUpdateOneWithoutUserNestedInput
    addresses?: UserAdressUpdateManyWithoutUserNestedInput
    contacts?: UserContactUpdateManyWithoutUserNestedInput
    DoctorPatient?: DoctorPatientUpdateManyWithoutAssignedByNestedInput
    exercises?: ExerciseUpdateManyWithoutCreatorNestedInput
    lessons?: LessonUpdateManyWithoutCreatorNestedInput
    watched?: WatchedVideoUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    socialName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    customGender?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    type?: EnumUserTypeFieldUpdateOperationsInput | UserType
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    facebookToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patientData?: PatientUncheckedUpdateOneWithoutUserNestedInput
    doctorData?: DoctorUncheckedUpdateOneWithoutUserNestedInput
    addresses?: UserAdressUncheckedUpdateManyWithoutUserNestedInput
    contacts?: UserContactUncheckedUpdateManyWithoutUserNestedInput
    DoctorPatient?: DoctorPatientUncheckedUpdateManyWithoutAssignedByNestedInput
    exercises?: ExerciseUncheckedUpdateManyWithoutCreatorNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutCreatorNestedInput
    watched?: WatchedVideoUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SpecialtyUpsertWithoutCourseInput = {
    update: XOR<SpecialtyUpdateWithoutCourseInput, SpecialtyUncheckedUpdateWithoutCourseInput>
    create: XOR<SpecialtyCreateWithoutCourseInput, SpecialtyUncheckedCreateWithoutCourseInput>
  }

  export type SpecialtyUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctors?: DoctorUpdateManyWithoutSpecialtyNestedInput
    templates?: TemplateUpdateManyWithoutSpecialtyNestedInput
    evaluations?: EvaluationUpdateManyWithoutSpecialtyNestedInput
    anamnesis?: AnamnesisUpdateManyWithoutSpecialtyNestedInput
    evolution?: EvolutionUpdateManyWithoutSpecialtyNestedInput
    exercise?: ExerciseUpdateManyWithoutSpecialtyNestedInput
  }

  export type SpecialtyUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctors?: DoctorUncheckedUpdateManyWithoutSpecialtyNestedInput
    templates?: TemplateUncheckedUpdateManyWithoutSpecialtyNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutSpecialtyNestedInput
    anamnesis?: AnamnesisUncheckedUpdateManyWithoutSpecialtyNestedInput
    evolution?: EvolutionUncheckedUpdateManyWithoutSpecialtyNestedInput
    exercise?: ExerciseUncheckedUpdateManyWithoutSpecialtyNestedInput
  }

  export type LessonUpsertWithWhereUniqueWithoutCourseInput = {
    where: LessonWhereUniqueInput
    update: XOR<LessonUpdateWithoutCourseInput, LessonUncheckedUpdateWithoutCourseInput>
    create: XOR<LessonCreateWithoutCourseInput, LessonUncheckedCreateWithoutCourseInput>
  }

  export type LessonUpdateWithWhereUniqueWithoutCourseInput = {
    where: LessonWhereUniqueInput
    data: XOR<LessonUpdateWithoutCourseInput, LessonUncheckedUpdateWithoutCourseInput>
  }

  export type LessonUpdateManyWithWhereWithoutCourseInput = {
    where: LessonScalarWhereInput
    data: XOR<LessonUpdateManyMutationInput, LessonUncheckedUpdateManyWithoutLessonsInput>
  }

  export type UserCreateWithoutLessonsInput = {
    id?: string
    numericId?: number
    socialName?: string | null
    email: string
    name: string
    gender?: string | null
    customGender?: string | null
    cpf?: string | null
    birthDate?: Date | string | null
    password: string
    type?: UserType
    avatar?: string | null
    facebookToken?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    isAdmin?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    patientData?: PatientCreateNestedOneWithoutUserInput
    doctorData?: DoctorCreateNestedOneWithoutUserInput
    addresses?: UserAdressCreateNestedManyWithoutUserInput
    contacts?: UserContactCreateNestedManyWithoutUserInput
    DoctorPatient?: DoctorPatientCreateNestedManyWithoutAssignedByInput
    exercises?: ExerciseCreateNestedManyWithoutCreatorInput
    courses?: CourseCreateNestedManyWithoutCreatorInput
    watched?: WatchedVideoCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLessonsInput = {
    id?: string
    numericId?: number
    socialName?: string | null
    email: string
    name: string
    gender?: string | null
    customGender?: string | null
    cpf?: string | null
    birthDate?: Date | string | null
    password: string
    type?: UserType
    avatar?: string | null
    facebookToken?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    isAdmin?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    patientData?: PatientUncheckedCreateNestedOneWithoutUserInput
    doctorData?: DoctorUncheckedCreateNestedOneWithoutUserInput
    addresses?: UserAdressUncheckedCreateNestedManyWithoutUserInput
    contacts?: UserContactUncheckedCreateNestedManyWithoutUserInput
    DoctorPatient?: DoctorPatientUncheckedCreateNestedManyWithoutAssignedByInput
    exercises?: ExerciseUncheckedCreateNestedManyWithoutCreatorInput
    courses?: CourseUncheckedCreateNestedManyWithoutCreatorInput
    watched?: WatchedVideoUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLessonsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLessonsInput, UserUncheckedCreateWithoutLessonsInput>
  }

  export type CourseCreateWithoutLessonsInput = {
    id?: string
    numericId?: number
    order?: number
    title: string
    cover?: string | null
    description: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    creator: UserCreateNestedOneWithoutCoursesInput
    specialty: SpecialtyCreateNestedOneWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutLessonsInput = {
    id?: string
    numericId?: number
    creatorId: string
    specialtyId: string
    order?: number
    title: string
    cover?: string | null
    description: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type CourseCreateOrConnectWithoutLessonsInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutLessonsInput, CourseUncheckedCreateWithoutLessonsInput>
  }

  export type LessonVideoCreateWithoutLessonInput = {
    id?: string
    numericId?: number
    order?: number
    title: string
    video: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    watched?: WatchedVideoCreateNestedManyWithoutVideoInput
  }

  export type LessonVideoUncheckedCreateWithoutLessonInput = {
    id?: string
    numericId?: number
    order?: number
    title: string
    video: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    watched?: WatchedVideoUncheckedCreateNestedManyWithoutVideoInput
  }

  export type LessonVideoCreateOrConnectWithoutLessonInput = {
    where: LessonVideoWhereUniqueInput
    create: XOR<LessonVideoCreateWithoutLessonInput, LessonVideoUncheckedCreateWithoutLessonInput>
  }

  export type LessonVideoCreateManyLessonInputEnvelope = {
    data: Enumerable<LessonVideoCreateManyLessonInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutLessonsInput = {
    update: XOR<UserUpdateWithoutLessonsInput, UserUncheckedUpdateWithoutLessonsInput>
    create: XOR<UserCreateWithoutLessonsInput, UserUncheckedCreateWithoutLessonsInput>
  }

  export type UserUpdateWithoutLessonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    socialName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    customGender?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    type?: EnumUserTypeFieldUpdateOperationsInput | UserType
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    facebookToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patientData?: PatientUpdateOneWithoutUserNestedInput
    doctorData?: DoctorUpdateOneWithoutUserNestedInput
    addresses?: UserAdressUpdateManyWithoutUserNestedInput
    contacts?: UserContactUpdateManyWithoutUserNestedInput
    DoctorPatient?: DoctorPatientUpdateManyWithoutAssignedByNestedInput
    exercises?: ExerciseUpdateManyWithoutCreatorNestedInput
    courses?: CourseUpdateManyWithoutCreatorNestedInput
    watched?: WatchedVideoUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLessonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    socialName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    customGender?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    type?: EnumUserTypeFieldUpdateOperationsInput | UserType
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    facebookToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patientData?: PatientUncheckedUpdateOneWithoutUserNestedInput
    doctorData?: DoctorUncheckedUpdateOneWithoutUserNestedInput
    addresses?: UserAdressUncheckedUpdateManyWithoutUserNestedInput
    contacts?: UserContactUncheckedUpdateManyWithoutUserNestedInput
    DoctorPatient?: DoctorPatientUncheckedUpdateManyWithoutAssignedByNestedInput
    exercises?: ExerciseUncheckedUpdateManyWithoutCreatorNestedInput
    courses?: CourseUncheckedUpdateManyWithoutCreatorNestedInput
    watched?: WatchedVideoUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CourseUpsertWithoutLessonsInput = {
    update: XOR<CourseUpdateWithoutLessonsInput, CourseUncheckedUpdateWithoutLessonsInput>
    create: XOR<CourseCreateWithoutLessonsInput, CourseUncheckedCreateWithoutLessonsInput>
  }

  export type CourseUpdateWithoutLessonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creator?: UserUpdateOneRequiredWithoutCoursesNestedInput
    specialty?: SpecialtyUpdateOneRequiredWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutLessonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    creatorId?: StringFieldUpdateOperationsInput | string
    specialtyId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LessonVideoUpsertWithWhereUniqueWithoutLessonInput = {
    where: LessonVideoWhereUniqueInput
    update: XOR<LessonVideoUpdateWithoutLessonInput, LessonVideoUncheckedUpdateWithoutLessonInput>
    create: XOR<LessonVideoCreateWithoutLessonInput, LessonVideoUncheckedCreateWithoutLessonInput>
  }

  export type LessonVideoUpdateWithWhereUniqueWithoutLessonInput = {
    where: LessonVideoWhereUniqueInput
    data: XOR<LessonVideoUpdateWithoutLessonInput, LessonVideoUncheckedUpdateWithoutLessonInput>
  }

  export type LessonVideoUpdateManyWithWhereWithoutLessonInput = {
    where: LessonVideoScalarWhereInput
    data: XOR<LessonVideoUpdateManyMutationInput, LessonVideoUncheckedUpdateManyWithoutVideosInput>
  }

  export type LessonVideoScalarWhereInput = {
    AND?: Enumerable<LessonVideoScalarWhereInput>
    OR?: Enumerable<LessonVideoScalarWhereInput>
    NOT?: Enumerable<LessonVideoScalarWhereInput>
    id?: UuidFilter | string
    numericId?: IntFilter | number
    lessonId?: UuidFilter | string
    order?: IntFilter | number
    title?: StringFilter | string
    video?: StringFilter | string
    isActive?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deletedAt?: DateTimeNullableFilter | Date | string | null
  }

  export type LessonCreateWithoutVideosInput = {
    id?: string
    numericId?: number
    order?: number
    title: string
    description: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    creator: UserCreateNestedOneWithoutLessonsInput
    course: CourseCreateNestedOneWithoutLessonsInput
  }

  export type LessonUncheckedCreateWithoutVideosInput = {
    id?: string
    numericId?: number
    creatorId: string
    courseId: string
    order?: number
    title: string
    description: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type LessonCreateOrConnectWithoutVideosInput = {
    where: LessonWhereUniqueInput
    create: XOR<LessonCreateWithoutVideosInput, LessonUncheckedCreateWithoutVideosInput>
  }

  export type WatchedVideoCreateWithoutVideoInput = {
    id?: string
    numericId?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user: UserCreateNestedOneWithoutWatchedInput
  }

  export type WatchedVideoUncheckedCreateWithoutVideoInput = {
    id?: string
    numericId?: number
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type WatchedVideoCreateOrConnectWithoutVideoInput = {
    where: WatchedVideoWhereUniqueInput
    create: XOR<WatchedVideoCreateWithoutVideoInput, WatchedVideoUncheckedCreateWithoutVideoInput>
  }

  export type WatchedVideoCreateManyVideoInputEnvelope = {
    data: Enumerable<WatchedVideoCreateManyVideoInput>
    skipDuplicates?: boolean
  }

  export type LessonUpsertWithoutVideosInput = {
    update: XOR<LessonUpdateWithoutVideosInput, LessonUncheckedUpdateWithoutVideosInput>
    create: XOR<LessonCreateWithoutVideosInput, LessonUncheckedCreateWithoutVideosInput>
  }

  export type LessonUpdateWithoutVideosInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creator?: UserUpdateOneRequiredWithoutLessonsNestedInput
    course?: CourseUpdateOneRequiredWithoutLessonsNestedInput
  }

  export type LessonUncheckedUpdateWithoutVideosInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    creatorId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WatchedVideoUpsertWithWhereUniqueWithoutVideoInput = {
    where: WatchedVideoWhereUniqueInput
    update: XOR<WatchedVideoUpdateWithoutVideoInput, WatchedVideoUncheckedUpdateWithoutVideoInput>
    create: XOR<WatchedVideoCreateWithoutVideoInput, WatchedVideoUncheckedCreateWithoutVideoInput>
  }

  export type WatchedVideoUpdateWithWhereUniqueWithoutVideoInput = {
    where: WatchedVideoWhereUniqueInput
    data: XOR<WatchedVideoUpdateWithoutVideoInput, WatchedVideoUncheckedUpdateWithoutVideoInput>
  }

  export type WatchedVideoUpdateManyWithWhereWithoutVideoInput = {
    where: WatchedVideoScalarWhereInput
    data: XOR<WatchedVideoUpdateManyMutationInput, WatchedVideoUncheckedUpdateManyWithoutWatchedInput>
  }

  export type UserCreateWithoutWatchedInput = {
    id?: string
    numericId?: number
    socialName?: string | null
    email: string
    name: string
    gender?: string | null
    customGender?: string | null
    cpf?: string | null
    birthDate?: Date | string | null
    password: string
    type?: UserType
    avatar?: string | null
    facebookToken?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    isAdmin?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    patientData?: PatientCreateNestedOneWithoutUserInput
    doctorData?: DoctorCreateNestedOneWithoutUserInput
    addresses?: UserAdressCreateNestedManyWithoutUserInput
    contacts?: UserContactCreateNestedManyWithoutUserInput
    DoctorPatient?: DoctorPatientCreateNestedManyWithoutAssignedByInput
    exercises?: ExerciseCreateNestedManyWithoutCreatorInput
    courses?: CourseCreateNestedManyWithoutCreatorInput
    lessons?: LessonCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutWatchedInput = {
    id?: string
    numericId?: number
    socialName?: string | null
    email: string
    name: string
    gender?: string | null
    customGender?: string | null
    cpf?: string | null
    birthDate?: Date | string | null
    password: string
    type?: UserType
    avatar?: string | null
    facebookToken?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    isAdmin?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    patientData?: PatientUncheckedCreateNestedOneWithoutUserInput
    doctorData?: DoctorUncheckedCreateNestedOneWithoutUserInput
    addresses?: UserAdressUncheckedCreateNestedManyWithoutUserInput
    contacts?: UserContactUncheckedCreateNestedManyWithoutUserInput
    DoctorPatient?: DoctorPatientUncheckedCreateNestedManyWithoutAssignedByInput
    exercises?: ExerciseUncheckedCreateNestedManyWithoutCreatorInput
    courses?: CourseUncheckedCreateNestedManyWithoutCreatorInput
    lessons?: LessonUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutWatchedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWatchedInput, UserUncheckedCreateWithoutWatchedInput>
  }

  export type LessonVideoCreateWithoutWatchedInput = {
    id?: string
    numericId?: number
    order?: number
    title: string
    video: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    lesson: LessonCreateNestedOneWithoutVideosInput
  }

  export type LessonVideoUncheckedCreateWithoutWatchedInput = {
    id?: string
    numericId?: number
    lessonId: string
    order?: number
    title: string
    video: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type LessonVideoCreateOrConnectWithoutWatchedInput = {
    where: LessonVideoWhereUniqueInput
    create: XOR<LessonVideoCreateWithoutWatchedInput, LessonVideoUncheckedCreateWithoutWatchedInput>
  }

  export type UserUpsertWithoutWatchedInput = {
    update: XOR<UserUpdateWithoutWatchedInput, UserUncheckedUpdateWithoutWatchedInput>
    create: XOR<UserCreateWithoutWatchedInput, UserUncheckedCreateWithoutWatchedInput>
  }

  export type UserUpdateWithoutWatchedInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    socialName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    customGender?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    type?: EnumUserTypeFieldUpdateOperationsInput | UserType
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    facebookToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patientData?: PatientUpdateOneWithoutUserNestedInput
    doctorData?: DoctorUpdateOneWithoutUserNestedInput
    addresses?: UserAdressUpdateManyWithoutUserNestedInput
    contacts?: UserContactUpdateManyWithoutUserNestedInput
    DoctorPatient?: DoctorPatientUpdateManyWithoutAssignedByNestedInput
    exercises?: ExerciseUpdateManyWithoutCreatorNestedInput
    courses?: CourseUpdateManyWithoutCreatorNestedInput
    lessons?: LessonUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutWatchedInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    socialName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    customGender?: NullableStringFieldUpdateOperationsInput | string | null
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    type?: EnumUserTypeFieldUpdateOperationsInput | UserType
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    facebookToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patientData?: PatientUncheckedUpdateOneWithoutUserNestedInput
    doctorData?: DoctorUncheckedUpdateOneWithoutUserNestedInput
    addresses?: UserAdressUncheckedUpdateManyWithoutUserNestedInput
    contacts?: UserContactUncheckedUpdateManyWithoutUserNestedInput
    DoctorPatient?: DoctorPatientUncheckedUpdateManyWithoutAssignedByNestedInput
    exercises?: ExerciseUncheckedUpdateManyWithoutCreatorNestedInput
    courses?: CourseUncheckedUpdateManyWithoutCreatorNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type LessonVideoUpsertWithoutWatchedInput = {
    update: XOR<LessonVideoUpdateWithoutWatchedInput, LessonVideoUncheckedUpdateWithoutWatchedInput>
    create: XOR<LessonVideoCreateWithoutWatchedInput, LessonVideoUncheckedCreateWithoutWatchedInput>
  }

  export type LessonVideoUpdateWithoutWatchedInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    video?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lesson?: LessonUpdateOneRequiredWithoutVideosNestedInput
  }

  export type LessonVideoUncheckedUpdateWithoutWatchedInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    lessonId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    video?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserAdressCreateManyUserInput = {
    id?: string
    numericId?: number
    streetName: string
    zipCode: string
    district: string
    state: string
    city: string
    number: string
    complement?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type UserContactCreateManyUserInput = {
    id?: string
    numericId?: number
    email?: string | null
    area: string
    phone: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type DoctorPatientCreateManyAssignedByInput = {
    doctorId: string
    patientId: string
    createdAt?: Date | string
    active?: boolean
  }

  export type ExerciseCreateManyCreatorInput = {
    id?: string
    numericId?: number
    title: string
    description: string
    links?: JsonNullValueInput | InputJsonValue
    specialtyId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourseCreateManyCreatorInput = {
    id?: string
    numericId?: number
    specialtyId: string
    order?: number
    title: string
    cover?: string | null
    description: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type LessonCreateManyCreatorInput = {
    id?: string
    numericId?: number
    courseId: string
    order?: number
    title: string
    description: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type WatchedVideoCreateManyUserInput = {
    id?: string
    numericId?: number
    videoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type UserAdressUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    streetName?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserAdressUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    streetName?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserAdressUncheckedUpdateManyWithoutAddressesInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    streetName?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    number?: StringFieldUpdateOperationsInput | string
    complement?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserContactUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    email?: NullableStringFieldUpdateOperationsInput | string | null
    area?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserContactUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    email?: NullableStringFieldUpdateOperationsInput | string | null
    area?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserContactUncheckedUpdateManyWithoutContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    email?: NullableStringFieldUpdateOperationsInput | string | null
    area?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DoctorPatientUpdateWithoutAssignedByInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    doctor?: DoctorUpdateOneRequiredWithoutDoctorPatientNestedInput
    patient?: PatientUpdateOneRequiredWithoutDoctorPatientNestedInput
  }

  export type DoctorPatientUncheckedUpdateWithoutAssignedByInput = {
    doctorId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DoctorPatientUncheckedUpdateManyWithoutDoctorPatientInput = {
    doctorId?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ExerciseUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    links?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    specialty?: SpecialtyUpdateOneRequiredWithoutExerciseNestedInput
  }

  export type ExerciseUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    links?: JsonNullValueInput | InputJsonValue
    specialtyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExerciseUncheckedUpdateManyWithoutExercisesInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    links?: JsonNullValueInput | InputJsonValue
    specialtyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    specialty?: SpecialtyUpdateOneRequiredWithoutCourseNestedInput
    lessons?: LessonUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    specialtyId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lessons?: LessonUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateManyWithoutCoursesInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    specialtyId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LessonUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    course?: CourseUpdateOneRequiredWithoutLessonsNestedInput
    videos?: LessonVideoUpdateManyWithoutLessonNestedInput
  }

  export type LessonUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    courseId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    videos?: LessonVideoUncheckedUpdateManyWithoutLessonNestedInput
  }

  export type LessonUncheckedUpdateManyWithoutLessonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    courseId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WatchedVideoUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    video?: LessonVideoUpdateOneRequiredWithoutWatchedNestedInput
  }

  export type WatchedVideoUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    videoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WatchedVideoUncheckedUpdateManyWithoutWatchedInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    videoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AnamnesisCreateManyPatientInput = {
    id?: string
    numericId?: number
    doctorId: string
    specialtyId: string
    questions?: JsonNullValueInput | InputJsonValue
    title?: string | null
    text?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type EvaluationCreateManyPatientInput = {
    id?: string
    numericId?: number
    doctorId: string
    specialtyId: string
    text?: string | null
    title?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type DoctorPatientCreateManyPatientInput = {
    doctorId: string
    assignedById: string
    createdAt?: Date | string
    active?: boolean
  }

  export type EvolutionCreateManyPatientInput = {
    id?: string
    numericId?: number
    doctorId: string
    specialtyId: string
    exercises?: JsonNullValueInput | InputJsonValue
    text?: string | null
    title?: string | null
    appointmentDate?: Date | string
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AppointmentCreateManyPatientInput = {
    id?: string
    numericId?: number
    doctorId: string
    when: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    status?: AppointmentStatus
  }

  export type AnamnesisUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    questions?: JsonNullValueInput | InputJsonValue
    title?: NullableStringFieldUpdateOperationsInput | string | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctor?: DoctorUpdateOneRequiredWithoutAnamnesisNestedInput
    specialty?: SpecialtyUpdateOneRequiredWithoutAnamnesisNestedInput
  }

  export type AnamnesisUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    doctorId?: StringFieldUpdateOperationsInput | string
    specialtyId?: StringFieldUpdateOperationsInput | string
    questions?: JsonNullValueInput | InputJsonValue
    title?: NullableStringFieldUpdateOperationsInput | string | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AnamnesisUncheckedUpdateManyWithoutAnamnesisInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    doctorId?: StringFieldUpdateOperationsInput | string
    specialtyId?: StringFieldUpdateOperationsInput | string
    questions?: JsonNullValueInput | InputJsonValue
    title?: NullableStringFieldUpdateOperationsInput | string | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EvaluationUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    text?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctor?: DoctorUpdateOneRequiredWithoutEvaluationsNestedInput
    specialty?: SpecialtyUpdateOneRequiredWithoutEvaluationsNestedInput
  }

  export type EvaluationUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    doctorId?: StringFieldUpdateOperationsInput | string
    specialtyId?: StringFieldUpdateOperationsInput | string
    text?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EvaluationUncheckedUpdateManyWithoutEvaluationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    doctorId?: StringFieldUpdateOperationsInput | string
    specialtyId?: StringFieldUpdateOperationsInput | string
    text?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DoctorPatientUpdateWithoutPatientInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    doctor?: DoctorUpdateOneRequiredWithoutDoctorPatientNestedInput
    assignedBy?: UserUpdateOneRequiredWithoutDoctorPatientNestedInput
  }

  export type DoctorPatientUncheckedUpdateWithoutPatientInput = {
    doctorId?: StringFieldUpdateOperationsInput | string
    assignedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EvolutionUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    exercises?: JsonNullValueInput | InputJsonValue
    text?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctor?: DoctorUpdateOneRequiredWithoutEvolutionsNestedInput
    specialty?: SpecialtyUpdateOneRequiredWithoutEvolutionNestedInput
  }

  export type EvolutionUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    doctorId?: StringFieldUpdateOperationsInput | string
    specialtyId?: StringFieldUpdateOperationsInput | string
    exercises?: JsonNullValueInput | InputJsonValue
    text?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EvolutionUncheckedUpdateManyWithoutEvolutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    doctorId?: StringFieldUpdateOperationsInput | string
    specialtyId?: StringFieldUpdateOperationsInput | string
    exercises?: JsonNullValueInput | InputJsonValue
    text?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AppointmentUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    when?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | AppointmentStatus
    doctor?: DoctorUpdateOneRequiredWithoutAppointmentsNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    doctorId?: StringFieldUpdateOperationsInput | string
    when?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | AppointmentStatus
  }

  export type AppointmentUncheckedUpdateManyWithoutAppointmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    doctorId?: StringFieldUpdateOperationsInput | string
    when?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | AppointmentStatus
  }

  export type AnamnesisCreateManyDoctorInput = {
    id?: string
    numericId?: number
    patientId: string
    specialtyId: string
    questions?: JsonNullValueInput | InputJsonValue
    title?: string | null
    text?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type EvaluationCreateManyDoctorInput = {
    id?: string
    numericId?: number
    patientId: string
    specialtyId: string
    text?: string | null
    title?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type DoctorPatientCreateManyDoctorInput = {
    patientId: string
    assignedById: string
    createdAt?: Date | string
    active?: boolean
  }

  export type TemplateCreateManyDoctorInput = {
    id?: string
    numericId?: number
    type: TemplateType
    specialtyId: string
    title: string
    html: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type EvolutionCreateManyDoctorInput = {
    id?: string
    numericId?: number
    patientId: string
    specialtyId: string
    exercises?: JsonNullValueInput | InputJsonValue
    text?: string | null
    title?: string | null
    appointmentDate?: Date | string
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AppointmentCreateManyDoctorInput = {
    id?: string
    numericId?: number
    patientId: string
    when: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    status?: AppointmentStatus
  }

  export type AnamnesisUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    questions?: JsonNullValueInput | InputJsonValue
    title?: NullableStringFieldUpdateOperationsInput | string | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patient?: PatientUpdateOneRequiredWithoutAnamnesisNestedInput
    specialty?: SpecialtyUpdateOneRequiredWithoutAnamnesisNestedInput
  }

  export type AnamnesisUncheckedUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    patientId?: StringFieldUpdateOperationsInput | string
    specialtyId?: StringFieldUpdateOperationsInput | string
    questions?: JsonNullValueInput | InputJsonValue
    title?: NullableStringFieldUpdateOperationsInput | string | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EvaluationUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    text?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patient?: PatientUpdateOneRequiredWithoutEvaluationsNestedInput
    specialty?: SpecialtyUpdateOneRequiredWithoutEvaluationsNestedInput
  }

  export type EvaluationUncheckedUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    patientId?: StringFieldUpdateOperationsInput | string
    specialtyId?: StringFieldUpdateOperationsInput | string
    text?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DoctorPatientUpdateWithoutDoctorInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
    patient?: PatientUpdateOneRequiredWithoutDoctorPatientNestedInput
    assignedBy?: UserUpdateOneRequiredWithoutDoctorPatientNestedInput
  }

  export type DoctorPatientUncheckedUpdateWithoutDoctorInput = {
    patientId?: StringFieldUpdateOperationsInput | string
    assignedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TemplateUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    type?: EnumTemplateTypeFieldUpdateOperationsInput | TemplateType
    title?: StringFieldUpdateOperationsInput | string
    html?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    specialty?: SpecialtyUpdateOneRequiredWithoutTemplatesNestedInput
  }

  export type TemplateUncheckedUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    type?: EnumTemplateTypeFieldUpdateOperationsInput | TemplateType
    specialtyId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    html?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TemplateUncheckedUpdateManyWithoutTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    type?: EnumTemplateTypeFieldUpdateOperationsInput | TemplateType
    specialtyId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    html?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EvolutionUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    exercises?: JsonNullValueInput | InputJsonValue
    text?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patient?: PatientUpdateOneRequiredWithoutEvolutionsNestedInput
    specialty?: SpecialtyUpdateOneRequiredWithoutEvolutionNestedInput
  }

  export type EvolutionUncheckedUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    patientId?: StringFieldUpdateOperationsInput | string
    specialtyId?: StringFieldUpdateOperationsInput | string
    exercises?: JsonNullValueInput | InputJsonValue
    text?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AppointmentUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    when?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | AppointmentStatus
    patient?: PatientUpdateOneRequiredWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    patientId?: StringFieldUpdateOperationsInput | string
    when?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | AppointmentStatus
  }

  export type AppointmentUncheckedUpdateManyWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    patientId?: StringFieldUpdateOperationsInput | string
    when?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | AppointmentStatus
  }

  export type DoctorCreateManySpecialtyInput = {
    id?: string
    numericId?: number
    userId: string
    crfa?: string | null
    availability?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type TemplateCreateManySpecialtyInput = {
    id?: string
    numericId?: number
    doctorId: string
    type: TemplateType
    title: string
    html: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type EvaluationCreateManySpecialtyInput = {
    id?: string
    numericId?: number
    patientId: string
    doctorId: string
    text?: string | null
    title?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AnamnesisCreateManySpecialtyInput = {
    id?: string
    numericId?: number
    patientId: string
    doctorId: string
    questions?: JsonNullValueInput | InputJsonValue
    title?: string | null
    text?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type EvolutionCreateManySpecialtyInput = {
    id?: string
    numericId?: number
    patientId: string
    doctorId: string
    exercises?: JsonNullValueInput | InputJsonValue
    text?: string | null
    title?: string | null
    appointmentDate?: Date | string
    comments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ExerciseCreateManySpecialtyInput = {
    id?: string
    numericId?: number
    title: string
    description: string
    links?: JsonNullValueInput | InputJsonValue
    creatorId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourseCreateManySpecialtyInput = {
    id?: string
    numericId?: number
    creatorId: string
    order?: number
    title: string
    cover?: string | null
    description: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type DoctorUpdateWithoutSpecialtyInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    crfa?: NullableStringFieldUpdateOperationsInput | string | null
    availability?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutDoctorDataNestedInput
    anamnesis?: AnamnesisUpdateManyWithoutDoctorNestedInput
    evaluations?: EvaluationUpdateManyWithoutDoctorNestedInput
    doctorPatient?: DoctorPatientUpdateManyWithoutDoctorNestedInput
    templates?: TemplateUpdateManyWithoutDoctorNestedInput
    evolutions?: EvolutionUpdateManyWithoutDoctorNestedInput
    appointments?: AppointmentUpdateManyWithoutDoctorNestedInput
  }

  export type DoctorUncheckedUpdateWithoutSpecialtyInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    crfa?: NullableStringFieldUpdateOperationsInput | string | null
    availability?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    anamnesis?: AnamnesisUncheckedUpdateManyWithoutDoctorNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutDoctorNestedInput
    doctorPatient?: DoctorPatientUncheckedUpdateManyWithoutDoctorNestedInput
    templates?: TemplateUncheckedUpdateManyWithoutDoctorNestedInput
    evolutions?: EvolutionUncheckedUpdateManyWithoutDoctorNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
  }

  export type DoctorUncheckedUpdateManyWithoutDoctorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    crfa?: NullableStringFieldUpdateOperationsInput | string | null
    availability?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TemplateUpdateWithoutSpecialtyInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    type?: EnumTemplateTypeFieldUpdateOperationsInput | TemplateType
    title?: StringFieldUpdateOperationsInput | string
    html?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doctor?: DoctorUpdateOneRequiredWithoutTemplatesNestedInput
  }

  export type TemplateUncheckedUpdateWithoutSpecialtyInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    doctorId?: StringFieldUpdateOperationsInput | string
    type?: EnumTemplateTypeFieldUpdateOperationsInput | TemplateType
    title?: StringFieldUpdateOperationsInput | string
    html?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EvaluationUpdateWithoutSpecialtyInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    text?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patient?: PatientUpdateOneRequiredWithoutEvaluationsNestedInput
    doctor?: DoctorUpdateOneRequiredWithoutEvaluationsNestedInput
  }

  export type EvaluationUncheckedUpdateWithoutSpecialtyInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    text?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AnamnesisUpdateWithoutSpecialtyInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    questions?: JsonNullValueInput | InputJsonValue
    title?: NullableStringFieldUpdateOperationsInput | string | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patient?: PatientUpdateOneRequiredWithoutAnamnesisNestedInput
    doctor?: DoctorUpdateOneRequiredWithoutAnamnesisNestedInput
  }

  export type AnamnesisUncheckedUpdateWithoutSpecialtyInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    questions?: JsonNullValueInput | InputJsonValue
    title?: NullableStringFieldUpdateOperationsInput | string | null
    text?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EvolutionUpdateWithoutSpecialtyInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    exercises?: JsonNullValueInput | InputJsonValue
    text?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patient?: PatientUpdateOneRequiredWithoutEvolutionsNestedInput
    doctor?: DoctorUpdateOneRequiredWithoutEvolutionsNestedInput
  }

  export type EvolutionUncheckedUpdateWithoutSpecialtyInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    exercises?: JsonNullValueInput | InputJsonValue
    text?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EvolutionUncheckedUpdateManyWithoutEvolutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    exercises?: JsonNullValueInput | InputJsonValue
    text?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ExerciseUpdateWithoutSpecialtyInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    links?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutExercisesNestedInput
  }

  export type ExerciseUncheckedUpdateWithoutSpecialtyInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    links?: JsonNullValueInput | InputJsonValue
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExerciseUncheckedUpdateManyWithoutExerciseInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    links?: JsonNullValueInput | InputJsonValue
    creatorId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseUpdateWithoutSpecialtyInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creator?: UserUpdateOneRequiredWithoutCoursesNestedInput
    lessons?: LessonUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutSpecialtyInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    creatorId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lessons?: LessonUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    creatorId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    cover?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LessonCreateManyCourseInput = {
    id?: string
    numericId?: number
    creatorId: string
    order?: number
    title: string
    description: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type LessonUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creator?: UserUpdateOneRequiredWithoutLessonsNestedInput
    videos?: LessonVideoUpdateManyWithoutLessonNestedInput
  }

  export type LessonUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    creatorId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    videos?: LessonVideoUncheckedUpdateManyWithoutLessonNestedInput
  }

  export type LessonVideoCreateManyLessonInput = {
    id?: string
    numericId?: number
    order?: number
    title: string
    video: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type LessonVideoUpdateWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    video?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    watched?: WatchedVideoUpdateManyWithoutVideoNestedInput
  }

  export type LessonVideoUncheckedUpdateWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    video?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    watched?: WatchedVideoUncheckedUpdateManyWithoutVideoNestedInput
  }

  export type LessonVideoUncheckedUpdateManyWithoutVideosInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    video?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WatchedVideoCreateManyVideoInput = {
    id?: string
    numericId?: number
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type WatchedVideoUpdateWithoutVideoInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutWatchedNestedInput
  }

  export type WatchedVideoUncheckedUpdateWithoutVideoInput = {
    id?: StringFieldUpdateOperationsInput | string
    numericId?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}