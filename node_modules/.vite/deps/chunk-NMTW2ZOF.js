import {
  getUnit,
  init_styles,
  toUnitless
} from "./chunk-Z6GJWKOZ.js";
import {
  KeyboardArrowLeft_default,
  KeyboardArrowRight_default,
  init_KeyboardArrowLeft,
  init_KeyboardArrowRight
} from "./chunk-C6ZL2RHX.js";
import {
  ButtonBase_default,
  init_ButtonBase
} from "./chunk-NSKKDHTI.js";
import {
  init_useTheme,
  useTheme
} from "./chunk-72WB36JH.js";
import {
  init_utils
} from "./chunk-M7TYGQ5N.js";
import {
  debounce_default,
  init_debounce,
  init_ownerDocument,
  init_ownerWindow,
  ownerDocument_default,
  ownerWindow_default
} from "./chunk-PDQDL7RV.js";
import {
  capitalize_default,
  init_base,
  init_capitalize,
  require_react_is,
  useSlotProps
} from "./chunk-QCRFQG4L.js";
import {
  init_useEventCallback,
  useEventCallback_default
} from "./chunk-NK755PVH.js";
import {
  init_useThemeProps,
  useThemeProps
} from "./chunk-ORUJFTGG.js";
import {
  init_styled,
  rootShouldForwardProp,
  styled_default
} from "./chunk-YP54SQIN.js";
import {
  init_generateUtilityClass
} from "./chunk-KW225RNL.js";
import {
  _objectWithoutPropertiesLoose,
  alpha,
  composeClasses,
  css,
  detectScrollType,
  generateUtilityClass,
  generateUtilityClasses,
  getNormalizedScrollLeft,
  init_esm,
  init_esm2,
  init_objectWithoutPropertiesLoose,
  keyframes,
  refType_default,
  require_prop_types,
  resolveProps
} from "./chunk-6UQGC4GI.js";
import {
  clsx_m_default,
  init_clsx_m
} from "./chunk-GZZJSLR2.js";
import {
  _extends,
  init_extends
} from "./chunk-M5CWVIST.js";
import {
  require_jsx_runtime
} from "./chunk-FEVPAJEA.js";
import {
  require_react
} from "./chunk-X6MODOAL.js";
import {
  __esm,
  __toESM
} from "./chunk-J43GMYXM.js";

// node_modules/@mui/material/Button/buttonClasses.js
function getButtonUtilityClass(slot) {
  return generateUtilityClass("MuiButton", slot);
}
var buttonClasses, buttonClasses_default;
var init_buttonClasses = __esm({
  "node_modules/@mui/material/Button/buttonClasses.js"() {
    init_esm();
    init_generateUtilityClass();
    buttonClasses = generateUtilityClasses("MuiButton", ["root", "text", "textInherit", "textPrimary", "textSecondary", "textSuccess", "textError", "textInfo", "textWarning", "outlined", "outlinedInherit", "outlinedPrimary", "outlinedSecondary", "outlinedSuccess", "outlinedError", "outlinedInfo", "outlinedWarning", "contained", "containedInherit", "containedPrimary", "containedSecondary", "containedSuccess", "containedError", "containedInfo", "containedWarning", "disableElevation", "focusVisible", "disabled", "colorInherit", "textSizeSmall", "textSizeMedium", "textSizeLarge", "outlinedSizeSmall", "outlinedSizeMedium", "outlinedSizeLarge", "containedSizeSmall", "containedSizeMedium", "containedSizeLarge", "sizeMedium", "sizeSmall", "sizeLarge", "fullWidth", "startIcon", "endIcon", "iconSizeSmall", "iconSizeMedium", "iconSizeLarge"]);
    buttonClasses_default = buttonClasses;
  }
});

// node_modules/@mui/material/ButtonGroup/ButtonGroupContext.js
var React, ButtonGroupContext, ButtonGroupContext_default;
var init_ButtonGroupContext = __esm({
  "node_modules/@mui/material/ButtonGroup/ButtonGroupContext.js"() {
    React = __toESM(require_react());
    ButtonGroupContext = React.createContext({});
    if (true) {
      ButtonGroupContext.displayName = "ButtonGroupContext";
    }
    ButtonGroupContext_default = ButtonGroupContext;
  }
});

// node_modules/@mui/material/Button/Button.js
var React2, import_prop_types, import_jsx_runtime, import_jsx_runtime2, _excluded, useUtilityClasses, commonIconStyles, ButtonRoot, ButtonStartIcon, ButtonEndIcon, Button, Button_default;
var init_Button = __esm({
  "node_modules/@mui/material/Button/Button.js"() {
    init_objectWithoutPropertiesLoose();
    init_extends();
    React2 = __toESM(require_react());
    import_prop_types = __toESM(require_prop_types());
    init_clsx_m();
    init_esm();
    init_base();
    init_esm2();
    init_styled();
    init_useThemeProps();
    init_ButtonBase();
    init_capitalize();
    init_buttonClasses();
    init_ButtonGroupContext();
    import_jsx_runtime = __toESM(require_jsx_runtime());
    import_jsx_runtime2 = __toESM(require_jsx_runtime());
    _excluded = ["children", "color", "component", "className", "disabled", "disableElevation", "disableFocusRipple", "endIcon", "focusVisibleClassName", "fullWidth", "size", "startIcon", "type", "variant"];
    useUtilityClasses = (ownerState) => {
      const {
        color,
        disableElevation,
        fullWidth,
        size,
        variant,
        classes
      } = ownerState;
      const slots = {
        root: ["root", variant, `${variant}${capitalize_default(color)}`, `size${capitalize_default(size)}`, `${variant}Size${capitalize_default(size)}`, color === "inherit" && "colorInherit", disableElevation && "disableElevation", fullWidth && "fullWidth"],
        label: ["label"],
        startIcon: ["startIcon", `iconSize${capitalize_default(size)}`],
        endIcon: ["endIcon", `iconSize${capitalize_default(size)}`]
      };
      const composedClasses = composeClasses(slots, getButtonUtilityClass, classes);
      return _extends({}, classes, composedClasses);
    };
    commonIconStyles = (ownerState) => _extends({}, ownerState.size === "small" && {
      "& > *:nth-of-type(1)": {
        fontSize: 18
      }
    }, ownerState.size === "medium" && {
      "& > *:nth-of-type(1)": {
        fontSize: 20
      }
    }, ownerState.size === "large" && {
      "& > *:nth-of-type(1)": {
        fontSize: 22
      }
    });
    ButtonRoot = styled_default(ButtonBase_default, {
      shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
      name: "MuiButton",
      slot: "Root",
      overridesResolver: (props, styles2) => {
        const {
          ownerState
        } = props;
        return [styles2.root, styles2[ownerState.variant], styles2[`${ownerState.variant}${capitalize_default(ownerState.color)}`], styles2[`size${capitalize_default(ownerState.size)}`], styles2[`${ownerState.variant}Size${capitalize_default(ownerState.size)}`], ownerState.color === "inherit" && styles2.colorInherit, ownerState.disableElevation && styles2.disableElevation, ownerState.fullWidth && styles2.fullWidth];
      }
    })(({
      theme,
      ownerState
    }) => {
      var _theme$palette$getCon, _theme$palette;
      return _extends({}, theme.typography.button, {
        minWidth: 64,
        padding: "6px 16px",
        borderRadius: (theme.vars || theme).shape.borderRadius,
        transition: theme.transitions.create(["background-color", "box-shadow", "border-color", "color"], {
          duration: theme.transitions.duration.short
        }),
        "&:hover": _extends({
          textDecoration: "none",
          backgroundColor: theme.vars ? `rgba(${theme.vars.palette.text.primaryChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette.text.primary, theme.palette.action.hoverOpacity),
          "@media (hover: none)": {
            backgroundColor: "transparent"
          }
        }, ownerState.variant === "text" && ownerState.color !== "inherit" && {
          backgroundColor: theme.vars ? `rgba(${theme.vars.palette[ownerState.color].mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette[ownerState.color].main, theme.palette.action.hoverOpacity),
          "@media (hover: none)": {
            backgroundColor: "transparent"
          }
        }, ownerState.variant === "outlined" && ownerState.color !== "inherit" && {
          border: `1px solid ${(theme.vars || theme).palette[ownerState.color].main}`,
          backgroundColor: theme.vars ? `rgba(${theme.vars.palette[ownerState.color].mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette[ownerState.color].main, theme.palette.action.hoverOpacity),
          "@media (hover: none)": {
            backgroundColor: "transparent"
          }
        }, ownerState.variant === "contained" && {
          backgroundColor: (theme.vars || theme).palette.grey.A100,
          boxShadow: (theme.vars || theme).shadows[4],
          "@media (hover: none)": {
            boxShadow: (theme.vars || theme).shadows[2],
            backgroundColor: (theme.vars || theme).palette.grey[300]
          }
        }, ownerState.variant === "contained" && ownerState.color !== "inherit" && {
          backgroundColor: (theme.vars || theme).palette[ownerState.color].dark,
          "@media (hover: none)": {
            backgroundColor: (theme.vars || theme).palette[ownerState.color].main
          }
        }),
        "&:active": _extends({}, ownerState.variant === "contained" && {
          boxShadow: (theme.vars || theme).shadows[8]
        }),
        [`&.${buttonClasses_default.focusVisible}`]: _extends({}, ownerState.variant === "contained" && {
          boxShadow: (theme.vars || theme).shadows[6]
        }),
        [`&.${buttonClasses_default.disabled}`]: _extends({
          color: (theme.vars || theme).palette.action.disabled
        }, ownerState.variant === "outlined" && {
          border: `1px solid ${(theme.vars || theme).palette.action.disabledBackground}`
        }, ownerState.variant === "contained" && {
          color: (theme.vars || theme).palette.action.disabled,
          boxShadow: (theme.vars || theme).shadows[0],
          backgroundColor: (theme.vars || theme).palette.action.disabledBackground
        })
      }, ownerState.variant === "text" && {
        padding: "6px 8px"
      }, ownerState.variant === "text" && ownerState.color !== "inherit" && {
        color: (theme.vars || theme).palette[ownerState.color].main
      }, ownerState.variant === "outlined" && {
        padding: "5px 15px",
        border: "1px solid currentColor"
      }, ownerState.variant === "outlined" && ownerState.color !== "inherit" && {
        color: (theme.vars || theme).palette[ownerState.color].main,
        border: theme.vars ? `1px solid rgba(${theme.vars.palette[ownerState.color].mainChannel} / 0.5)` : `1px solid ${alpha(theme.palette[ownerState.color].main, 0.5)}`
      }, ownerState.variant === "contained" && {
        color: theme.vars ? theme.vars.palette.text.primary : (_theme$palette$getCon = (_theme$palette = theme.palette).getContrastText) == null ? void 0 : _theme$palette$getCon.call(_theme$palette, theme.palette.grey[300]),
        backgroundColor: (theme.vars || theme).palette.grey[300],
        boxShadow: (theme.vars || theme).shadows[2]
      }, ownerState.variant === "contained" && ownerState.color !== "inherit" && {
        color: (theme.vars || theme).palette[ownerState.color].contrastText,
        backgroundColor: (theme.vars || theme).palette[ownerState.color].main
      }, ownerState.color === "inherit" && {
        color: "inherit",
        borderColor: "currentColor"
      }, ownerState.size === "small" && ownerState.variant === "text" && {
        padding: "4px 5px",
        fontSize: theme.typography.pxToRem(13)
      }, ownerState.size === "large" && ownerState.variant === "text" && {
        padding: "8px 11px",
        fontSize: theme.typography.pxToRem(15)
      }, ownerState.size === "small" && ownerState.variant === "outlined" && {
        padding: "3px 9px",
        fontSize: theme.typography.pxToRem(13)
      }, ownerState.size === "large" && ownerState.variant === "outlined" && {
        padding: "7px 21px",
        fontSize: theme.typography.pxToRem(15)
      }, ownerState.size === "small" && ownerState.variant === "contained" && {
        padding: "4px 10px",
        fontSize: theme.typography.pxToRem(13)
      }, ownerState.size === "large" && ownerState.variant === "contained" && {
        padding: "8px 22px",
        fontSize: theme.typography.pxToRem(15)
      }, ownerState.fullWidth && {
        width: "100%"
      });
    }, ({
      ownerState
    }) => ownerState.disableElevation && {
      boxShadow: "none",
      "&:hover": {
        boxShadow: "none"
      },
      [`&.${buttonClasses_default.focusVisible}`]: {
        boxShadow: "none"
      },
      "&:active": {
        boxShadow: "none"
      },
      [`&.${buttonClasses_default.disabled}`]: {
        boxShadow: "none"
      }
    });
    ButtonStartIcon = styled_default("span", {
      name: "MuiButton",
      slot: "StartIcon",
      overridesResolver: (props, styles2) => {
        const {
          ownerState
        } = props;
        return [styles2.startIcon, styles2[`iconSize${capitalize_default(ownerState.size)}`]];
      }
    })(({
      ownerState
    }) => _extends({
      display: "inherit",
      marginRight: 8,
      marginLeft: -4
    }, ownerState.size === "small" && {
      marginLeft: -2
    }, commonIconStyles(ownerState)));
    ButtonEndIcon = styled_default("span", {
      name: "MuiButton",
      slot: "EndIcon",
      overridesResolver: (props, styles2) => {
        const {
          ownerState
        } = props;
        return [styles2.endIcon, styles2[`iconSize${capitalize_default(ownerState.size)}`]];
      }
    })(({
      ownerState
    }) => _extends({
      display: "inherit",
      marginRight: -4,
      marginLeft: 8
    }, ownerState.size === "small" && {
      marginRight: -2
    }, commonIconStyles(ownerState)));
    Button = React2.forwardRef(function Button2(inProps, ref) {
      const contextProps = React2.useContext(ButtonGroupContext_default);
      const resolvedProps = resolveProps(contextProps, inProps);
      const props = useThemeProps({
        props: resolvedProps,
        name: "MuiButton"
      });
      const {
        children,
        color = "primary",
        component = "button",
        className,
        disabled = false,
        disableElevation = false,
        disableFocusRipple = false,
        endIcon: endIconProp,
        focusVisibleClassName,
        fullWidth = false,
        size = "medium",
        startIcon: startIconProp,
        type,
        variant = "text"
      } = props, other = _objectWithoutPropertiesLoose(props, _excluded);
      const ownerState = _extends({}, props, {
        color,
        component,
        disabled,
        disableElevation,
        disableFocusRipple,
        fullWidth,
        size,
        type,
        variant
      });
      const classes = useUtilityClasses(ownerState);
      const startIcon = startIconProp && (0, import_jsx_runtime.jsx)(ButtonStartIcon, {
        className: classes.startIcon,
        ownerState,
        children: startIconProp
      });
      const endIcon = endIconProp && (0, import_jsx_runtime.jsx)(ButtonEndIcon, {
        className: classes.endIcon,
        ownerState,
        children: endIconProp
      });
      return (0, import_jsx_runtime2.jsxs)(ButtonRoot, _extends({
        ownerState,
        className: clsx_m_default(contextProps.className, classes.root, className),
        component,
        disabled,
        focusRipple: !disableFocusRipple,
        focusVisibleClassName: clsx_m_default(classes.focusVisible, focusVisibleClassName),
        ref,
        type
      }, other, {
        classes,
        children: [startIcon, children, endIcon]
      }));
    });
    true ? Button.propTypes = {
      children: import_prop_types.default.node,
      classes: import_prop_types.default.object,
      className: import_prop_types.default.string,
      color: import_prop_types.default.oneOfType([import_prop_types.default.oneOf(["inherit", "primary", "secondary", "success", "error", "info", "warning"]), import_prop_types.default.string]),
      component: import_prop_types.default.elementType,
      disabled: import_prop_types.default.bool,
      disableElevation: import_prop_types.default.bool,
      disableFocusRipple: import_prop_types.default.bool,
      disableRipple: import_prop_types.default.bool,
      endIcon: import_prop_types.default.node,
      focusVisibleClassName: import_prop_types.default.string,
      fullWidth: import_prop_types.default.bool,
      href: import_prop_types.default.string,
      size: import_prop_types.default.oneOfType([import_prop_types.default.oneOf(["small", "medium", "large"]), import_prop_types.default.string]),
      startIcon: import_prop_types.default.node,
      sx: import_prop_types.default.oneOfType([import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.object, import_prop_types.default.bool])), import_prop_types.default.func, import_prop_types.default.object]),
      type: import_prop_types.default.oneOfType([import_prop_types.default.oneOf(["button", "reset", "submit"]), import_prop_types.default.string]),
      variant: import_prop_types.default.oneOfType([import_prop_types.default.oneOf(["contained", "outlined", "text"]), import_prop_types.default.string])
    } : void 0;
    Button_default = Button;
  }
});

// node_modules/@mui/material/Button/index.js
var init_Button2 = __esm({
  "node_modules/@mui/material/Button/index.js"() {
    init_Button();
    init_buttonClasses();
    init_buttonClasses();
  }
});

// node_modules/@mui/material/Skeleton/skeletonClasses.js
function getSkeletonUtilityClass(slot) {
  return generateUtilityClass("MuiSkeleton", slot);
}
var skeletonClasses, skeletonClasses_default;
var init_skeletonClasses = __esm({
  "node_modules/@mui/material/Skeleton/skeletonClasses.js"() {
    init_esm();
    init_generateUtilityClass();
    skeletonClasses = generateUtilityClasses("MuiSkeleton", ["root", "text", "rectangular", "rounded", "circular", "pulse", "wave", "withChildren", "fitContent", "heightAuto"]);
    skeletonClasses_default = skeletonClasses;
  }
});

// node_modules/@mui/material/Skeleton/Skeleton.js
var React3, import_prop_types2, import_jsx_runtime3, _excluded2, _, _t, _t2, _t3, _t4, useUtilityClasses2, pulseKeyframe, waveKeyframe, SkeletonRoot, Skeleton, Skeleton_default;
var init_Skeleton = __esm({
  "node_modules/@mui/material/Skeleton/Skeleton.js"() {
    init_objectWithoutPropertiesLoose();
    init_extends();
    React3 = __toESM(require_react());
    init_clsx_m();
    import_prop_types2 = __toESM(require_prop_types());
    init_esm2();
    init_base();
    init_styles();
    init_styled();
    init_useThemeProps();
    init_skeletonClasses();
    import_jsx_runtime3 = __toESM(require_jsx_runtime());
    _excluded2 = ["animation", "className", "component", "height", "style", "variant", "width"];
    _ = (t) => t;
    useUtilityClasses2 = (ownerState) => {
      const {
        classes,
        variant,
        animation,
        hasChildren,
        width,
        height
      } = ownerState;
      const slots = {
        root: ["root", variant, animation, hasChildren && "withChildren", hasChildren && !width && "fitContent", hasChildren && !height && "heightAuto"]
      };
      return composeClasses(slots, getSkeletonUtilityClass, classes);
    };
    pulseKeyframe = keyframes(_t || (_t = _`
  0% {
    opacity: 1;
  }

  50% {
    opacity: 0.4;
  }

  100% {
    opacity: 1;
  }
`));
    waveKeyframe = keyframes(_t2 || (_t2 = _`
  0% {
    transform: translateX(-100%);
  }

  50% {
    /* +0.5s of delay between each loop */
    transform: translateX(100%);
  }

  100% {
    transform: translateX(100%);
  }
`));
    SkeletonRoot = styled_default("span", {
      name: "MuiSkeleton",
      slot: "Root",
      overridesResolver: (props, styles2) => {
        const {
          ownerState
        } = props;
        return [styles2.root, styles2[ownerState.variant], ownerState.animation !== false && styles2[ownerState.animation], ownerState.hasChildren && styles2.withChildren, ownerState.hasChildren && !ownerState.width && styles2.fitContent, ownerState.hasChildren && !ownerState.height && styles2.heightAuto];
      }
    })(({
      theme,
      ownerState
    }) => {
      const radiusUnit = getUnit(theme.shape.borderRadius) || "px";
      const radiusValue = toUnitless(theme.shape.borderRadius);
      return _extends({
        display: "block",
        backgroundColor: theme.vars ? theme.vars.palette.Skeleton.bg : alpha(theme.palette.text.primary, theme.palette.mode === "light" ? 0.11 : 0.13),
        height: "1.2em"
      }, ownerState.variant === "text" && {
        marginTop: 0,
        marginBottom: 0,
        height: "auto",
        transformOrigin: "0 55%",
        transform: "scale(1, 0.60)",
        borderRadius: `${radiusValue}${radiusUnit}/${Math.round(radiusValue / 0.6 * 10) / 10}${radiusUnit}`,
        "&:empty:before": {
          content: '"\\00a0"'
        }
      }, ownerState.variant === "circular" && {
        borderRadius: "50%"
      }, ownerState.variant === "rounded" && {
        borderRadius: (theme.vars || theme).shape.borderRadius
      }, ownerState.hasChildren && {
        "& > *": {
          visibility: "hidden"
        }
      }, ownerState.hasChildren && !ownerState.width && {
        maxWidth: "fit-content"
      }, ownerState.hasChildren && !ownerState.height && {
        height: "auto"
      });
    }, ({
      ownerState
    }) => ownerState.animation === "pulse" && css(_t3 || (_t3 = _`
      animation: ${0} 1.5s ease-in-out 0.5s infinite;
    `), pulseKeyframe), ({
      ownerState,
      theme
    }) => ownerState.animation === "wave" && css(_t4 || (_t4 = _`
      position: relative;
      overflow: hidden;

      /* Fix bug in Safari https://bugs.webkit.org/show_bug.cgi?id=68196 */
      -webkit-mask-image: -webkit-radial-gradient(white, black);

      &::after {
        animation: ${0} 1.6s linear 0.5s infinite;
        background: linear-gradient(
          90deg,
          transparent,
          ${0},
          transparent
        );
        content: '';
        position: absolute;
        transform: translateX(-100%); /* Avoid flash during server-side hydration */
        bottom: 0;
        left: 0;
        right: 0;
        top: 0;
      }
    `), waveKeyframe, (theme.vars || theme).palette.action.hover));
    Skeleton = React3.forwardRef(function Skeleton2(inProps, ref) {
      const props = useThemeProps({
        props: inProps,
        name: "MuiSkeleton"
      });
      const {
        animation = "pulse",
        className,
        component = "span",
        height,
        style,
        variant = "text",
        width
      } = props, other = _objectWithoutPropertiesLoose(props, _excluded2);
      const ownerState = _extends({}, props, {
        animation,
        component,
        variant,
        hasChildren: Boolean(other.children)
      });
      const classes = useUtilityClasses2(ownerState);
      return (0, import_jsx_runtime3.jsx)(SkeletonRoot, _extends({
        as: component,
        ref,
        className: clsx_m_default(classes.root, className),
        ownerState
      }, other, {
        style: _extends({
          width,
          height
        }, style)
      }));
    });
    true ? Skeleton.propTypes = {
      animation: import_prop_types2.default.oneOf(["pulse", "wave", false]),
      children: import_prop_types2.default.node,
      classes: import_prop_types2.default.object,
      className: import_prop_types2.default.string,
      component: import_prop_types2.default.elementType,
      height: import_prop_types2.default.oneOfType([import_prop_types2.default.number, import_prop_types2.default.string]),
      style: import_prop_types2.default.object,
      sx: import_prop_types2.default.oneOfType([import_prop_types2.default.arrayOf(import_prop_types2.default.oneOfType([import_prop_types2.default.func, import_prop_types2.default.object, import_prop_types2.default.bool])), import_prop_types2.default.func, import_prop_types2.default.object]),
      variant: import_prop_types2.default.oneOfType([import_prop_types2.default.oneOf(["circular", "rectangular", "rounded", "text"]), import_prop_types2.default.string]),
      width: import_prop_types2.default.oneOfType([import_prop_types2.default.number, import_prop_types2.default.string])
    } : void 0;
    Skeleton_default = Skeleton;
  }
});

// node_modules/@mui/material/Skeleton/index.js
var init_Skeleton2 = __esm({
  "node_modules/@mui/material/Skeleton/index.js"() {
    init_Skeleton();
    init_skeletonClasses();
    init_skeletonClasses();
  }
});

// node_modules/@mui/material/TabScrollButton/tabScrollButtonClasses.js
function getTabScrollButtonUtilityClass(slot) {
  return generateUtilityClass("MuiTabScrollButton", slot);
}
var tabScrollButtonClasses, tabScrollButtonClasses_default;
var init_tabScrollButtonClasses = __esm({
  "node_modules/@mui/material/TabScrollButton/tabScrollButtonClasses.js"() {
    init_esm();
    init_generateUtilityClass();
    tabScrollButtonClasses = generateUtilityClasses("MuiTabScrollButton", ["root", "vertical", "horizontal", "disabled"]);
    tabScrollButtonClasses_default = tabScrollButtonClasses;
  }
});

// node_modules/@mui/material/TabScrollButton/TabScrollButton.js
var React4, import_prop_types3, import_jsx_runtime4, _excluded3, useUtilityClasses3, TabScrollButtonRoot, TabScrollButton, TabScrollButton_default;
var init_TabScrollButton = __esm({
  "node_modules/@mui/material/TabScrollButton/TabScrollButton.js"() {
    init_objectWithoutPropertiesLoose();
    init_extends();
    React4 = __toESM(require_react());
    import_prop_types3 = __toESM(require_prop_types());
    init_clsx_m();
    init_base();
    init_KeyboardArrowLeft();
    init_KeyboardArrowRight();
    init_ButtonBase();
    init_useTheme();
    init_useThemeProps();
    init_styled();
    init_tabScrollButtonClasses();
    import_jsx_runtime4 = __toESM(require_jsx_runtime());
    _excluded3 = ["className", "slots", "slotProps", "direction", "orientation", "disabled"];
    useUtilityClasses3 = (ownerState) => {
      const {
        classes,
        orientation,
        disabled
      } = ownerState;
      const slots = {
        root: ["root", orientation, disabled && "disabled"]
      };
      return composeClasses(slots, getTabScrollButtonUtilityClass, classes);
    };
    TabScrollButtonRoot = styled_default(ButtonBase_default, {
      name: "MuiTabScrollButton",
      slot: "Root",
      overridesResolver: (props, styles2) => {
        const {
          ownerState
        } = props;
        return [styles2.root, ownerState.orientation && styles2[ownerState.orientation]];
      }
    })(({
      ownerState
    }) => _extends({
      width: 40,
      flexShrink: 0,
      opacity: 0.8,
      [`&.${tabScrollButtonClasses_default.disabled}`]: {
        opacity: 0
      }
    }, ownerState.orientation === "vertical" && {
      width: "100%",
      height: 40,
      "& svg": {
        transform: `rotate(${ownerState.isRtl ? -90 : 90}deg)`
      }
    }));
    TabScrollButton = React4.forwardRef(function TabScrollButton2(inProps, ref) {
      var _slots$StartScrollBut, _slots$EndScrollButto;
      const props = useThemeProps({
        props: inProps,
        name: "MuiTabScrollButton"
      });
      const {
        className,
        slots = {},
        slotProps = {},
        direction
      } = props, other = _objectWithoutPropertiesLoose(props, _excluded3);
      const theme = useTheme();
      const isRtl = theme.direction === "rtl";
      const ownerState = _extends({
        isRtl
      }, props);
      const classes = useUtilityClasses3(ownerState);
      const StartButtonIcon = (_slots$StartScrollBut = slots.StartScrollButtonIcon) != null ? _slots$StartScrollBut : KeyboardArrowLeft_default;
      const EndButtonIcon = (_slots$EndScrollButto = slots.EndScrollButtonIcon) != null ? _slots$EndScrollButto : KeyboardArrowRight_default;
      const startButtonIconProps = useSlotProps({
        elementType: StartButtonIcon,
        externalSlotProps: slotProps.startScrollButtonIcon,
        additionalProps: {
          fontSize: "small"
        },
        ownerState
      });
      const endButtonIconProps = useSlotProps({
        elementType: EndButtonIcon,
        externalSlotProps: slotProps.endScrollButtonIcon,
        additionalProps: {
          fontSize: "small"
        },
        ownerState
      });
      return (0, import_jsx_runtime4.jsx)(TabScrollButtonRoot, _extends({
        component: "div",
        className: clsx_m_default(classes.root, className),
        ref,
        role: null,
        ownerState,
        tabIndex: null
      }, other, {
        children: direction === "left" ? (0, import_jsx_runtime4.jsx)(StartButtonIcon, _extends({}, startButtonIconProps)) : (0, import_jsx_runtime4.jsx)(EndButtonIcon, _extends({}, endButtonIconProps))
      }));
    });
    true ? TabScrollButton.propTypes = {
      children: import_prop_types3.default.node,
      classes: import_prop_types3.default.object,
      className: import_prop_types3.default.string,
      direction: import_prop_types3.default.oneOf(["left", "right"]).isRequired,
      disabled: import_prop_types3.default.bool,
      orientation: import_prop_types3.default.oneOf(["horizontal", "vertical"]).isRequired,
      slotProps: import_prop_types3.default.shape({
        endScrollButtonIcon: import_prop_types3.default.oneOfType([import_prop_types3.default.func, import_prop_types3.default.object]),
        startScrollButtonIcon: import_prop_types3.default.oneOfType([import_prop_types3.default.func, import_prop_types3.default.object])
      }),
      slots: import_prop_types3.default.shape({
        EndScrollButtonIcon: import_prop_types3.default.elementType,
        StartScrollButtonIcon: import_prop_types3.default.elementType
      }),
      sx: import_prop_types3.default.oneOfType([import_prop_types3.default.arrayOf(import_prop_types3.default.oneOfType([import_prop_types3.default.func, import_prop_types3.default.object, import_prop_types3.default.bool])), import_prop_types3.default.func, import_prop_types3.default.object])
    } : void 0;
    TabScrollButton_default = TabScrollButton;
  }
});

// node_modules/@mui/material/TabScrollButton/index.js
var init_TabScrollButton2 = __esm({
  "node_modules/@mui/material/TabScrollButton/index.js"() {
    init_TabScrollButton();
    init_tabScrollButtonClasses();
    init_tabScrollButtonClasses();
  }
});

// node_modules/@mui/material/Tabs/tabsClasses.js
function getTabsUtilityClass(slot) {
  return generateUtilityClass("MuiTabs", slot);
}
var tabsClasses, tabsClasses_default;
var init_tabsClasses = __esm({
  "node_modules/@mui/material/Tabs/tabsClasses.js"() {
    init_esm();
    init_generateUtilityClass();
    tabsClasses = generateUtilityClasses("MuiTabs", ["root", "vertical", "flexContainer", "flexContainerVertical", "centered", "scroller", "fixed", "scrollableX", "scrollableY", "hideScrollbar", "scrollButtons", "scrollButtonsHideMobile", "indicator"]);
    tabsClasses_default = tabsClasses;
  }
});

// node_modules/@mui/material/utils/scrollLeft.js
var init_scrollLeft = __esm({
  "node_modules/@mui/material/utils/scrollLeft.js"() {
    init_esm();
  }
});

// node_modules/@mui/material/internal/animate.js
function easeInOutSin(time) {
  return (1 + Math.sin(Math.PI * time - Math.PI / 2)) / 2;
}
function animate(property, element, to, options = {}, cb = () => {
}) {
  const {
    ease = easeInOutSin,
    duration = 300
  } = options;
  let start = null;
  const from = element[property];
  let cancelled = false;
  const cancel = () => {
    cancelled = true;
  };
  const step = (timestamp) => {
    if (cancelled) {
      cb(new Error("Animation cancelled"));
      return;
    }
    if (start === null) {
      start = timestamp;
    }
    const time = Math.min(1, (timestamp - start) / duration);
    element[property] = ease(time) * (to - from) + from;
    if (time >= 1) {
      requestAnimationFrame(() => {
        cb(null);
      });
      return;
    }
    requestAnimationFrame(step);
  };
  if (from === to) {
    cb(new Error("Element already at target position"));
    return cancel;
  }
  requestAnimationFrame(step);
  return cancel;
}
var init_animate = __esm({
  "node_modules/@mui/material/internal/animate.js"() {
  }
});

// node_modules/@mui/material/Tabs/ScrollbarSize.js
function ScrollbarSize(props) {
  const {
    onChange
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded4);
  const scrollbarHeight = React5.useRef();
  const nodeRef = React5.useRef(null);
  const setMeasurements = () => {
    scrollbarHeight.current = nodeRef.current.offsetHeight - nodeRef.current.clientHeight;
  };
  React5.useEffect(() => {
    const handleResize = debounce_default(() => {
      const prevHeight = scrollbarHeight.current;
      setMeasurements();
      if (prevHeight !== scrollbarHeight.current) {
        onChange(scrollbarHeight.current);
      }
    });
    const containerWindow = ownerWindow_default(nodeRef.current);
    containerWindow.addEventListener("resize", handleResize);
    return () => {
      handleResize.clear();
      containerWindow.removeEventListener("resize", handleResize);
    };
  }, [onChange]);
  React5.useEffect(() => {
    setMeasurements();
    onChange(scrollbarHeight.current);
  }, [onChange]);
  return (0, import_jsx_runtime5.jsx)("div", _extends({
    style: styles,
    ref: nodeRef
  }, other));
}
var React5, import_prop_types4, import_jsx_runtime5, _excluded4, styles;
var init_ScrollbarSize = __esm({
  "node_modules/@mui/material/Tabs/ScrollbarSize.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    React5 = __toESM(require_react());
    import_prop_types4 = __toESM(require_prop_types());
    init_debounce();
    init_utils();
    import_jsx_runtime5 = __toESM(require_jsx_runtime());
    _excluded4 = ["onChange"];
    styles = {
      width: 99,
      height: 99,
      position: "absolute",
      top: -9999,
      overflow: "scroll"
    };
    true ? ScrollbarSize.propTypes = {
      onChange: import_prop_types4.default.func.isRequired
    } : void 0;
  }
});

// node_modules/@mui/material/Tabs/Tabs.js
var React6, import_react_is, import_prop_types5, import_jsx_runtime6, import_jsx_runtime7, _excluded5, nextItem, previousItem, moveFocus, useUtilityClasses4, TabsRoot, TabsScroller, FlexContainer, TabsIndicator, TabsScrollbarSize, defaultIndicatorStyle, warnedOnceTabPresent, Tabs, Tabs_default;
var init_Tabs = __esm({
  "node_modules/@mui/material/Tabs/Tabs.js"() {
    init_objectWithoutPropertiesLoose();
    init_extends();
    React6 = __toESM(require_react());
    import_react_is = __toESM(require_react_is());
    import_prop_types5 = __toESM(require_prop_types());
    init_clsx_m();
    init_esm();
    init_base();
    init_styled();
    init_useThemeProps();
    init_useTheme();
    init_debounce();
    init_scrollLeft();
    init_animate();
    init_ScrollbarSize();
    init_TabScrollButton2();
    init_useEventCallback();
    init_tabsClasses();
    init_ownerDocument();
    init_ownerWindow();
    import_jsx_runtime6 = __toESM(require_jsx_runtime());
    import_jsx_runtime7 = __toESM(require_jsx_runtime());
    _excluded5 = ["aria-label", "aria-labelledby", "action", "centered", "children", "className", "component", "allowScrollButtonsMobile", "indicatorColor", "onChange", "orientation", "ScrollButtonComponent", "scrollButtons", "selectionFollowsFocus", "slots", "slotProps", "TabIndicatorProps", "TabScrollButtonProps", "textColor", "value", "variant", "visibleScrollbar"];
    nextItem = (list, item) => {
      if (list === item) {
        return list.firstChild;
      }
      if (item && item.nextElementSibling) {
        return item.nextElementSibling;
      }
      return list.firstChild;
    };
    previousItem = (list, item) => {
      if (list === item) {
        return list.lastChild;
      }
      if (item && item.previousElementSibling) {
        return item.previousElementSibling;
      }
      return list.lastChild;
    };
    moveFocus = (list, currentFocus, traversalFunction) => {
      let wrappedOnce = false;
      let nextFocus = traversalFunction(list, currentFocus);
      while (nextFocus) {
        if (nextFocus === list.firstChild) {
          if (wrappedOnce) {
            return;
          }
          wrappedOnce = true;
        }
        const nextFocusDisabled = nextFocus.disabled || nextFocus.getAttribute("aria-disabled") === "true";
        if (!nextFocus.hasAttribute("tabindex") || nextFocusDisabled) {
          nextFocus = traversalFunction(list, nextFocus);
        } else {
          nextFocus.focus();
          return;
        }
      }
    };
    useUtilityClasses4 = (ownerState) => {
      const {
        vertical,
        fixed,
        hideScrollbar,
        scrollableX,
        scrollableY,
        centered,
        scrollButtonsHideMobile,
        classes
      } = ownerState;
      const slots = {
        root: ["root", vertical && "vertical"],
        scroller: ["scroller", fixed && "fixed", hideScrollbar && "hideScrollbar", scrollableX && "scrollableX", scrollableY && "scrollableY"],
        flexContainer: ["flexContainer", vertical && "flexContainerVertical", centered && "centered"],
        indicator: ["indicator"],
        scrollButtons: ["scrollButtons", scrollButtonsHideMobile && "scrollButtonsHideMobile"],
        scrollableX: [scrollableX && "scrollableX"],
        hideScrollbar: [hideScrollbar && "hideScrollbar"]
      };
      return composeClasses(slots, getTabsUtilityClass, classes);
    };
    TabsRoot = styled_default("div", {
      name: "MuiTabs",
      slot: "Root",
      overridesResolver: (props, styles2) => {
        const {
          ownerState
        } = props;
        return [{
          [`& .${tabsClasses_default.scrollButtons}`]: styles2.scrollButtons
        }, {
          [`& .${tabsClasses_default.scrollButtons}`]: ownerState.scrollButtonsHideMobile && styles2.scrollButtonsHideMobile
        }, styles2.root, ownerState.vertical && styles2.vertical];
      }
    })(({
      ownerState,
      theme
    }) => _extends({
      overflow: "hidden",
      minHeight: 48,
      WebkitOverflowScrolling: "touch",
      display: "flex"
    }, ownerState.vertical && {
      flexDirection: "column"
    }, ownerState.scrollButtonsHideMobile && {
      [`& .${tabsClasses_default.scrollButtons}`]: {
        [theme.breakpoints.down("sm")]: {
          display: "none"
        }
      }
    }));
    TabsScroller = styled_default("div", {
      name: "MuiTabs",
      slot: "Scroller",
      overridesResolver: (props, styles2) => {
        const {
          ownerState
        } = props;
        return [styles2.scroller, ownerState.fixed && styles2.fixed, ownerState.hideScrollbar && styles2.hideScrollbar, ownerState.scrollableX && styles2.scrollableX, ownerState.scrollableY && styles2.scrollableY];
      }
    })(({
      ownerState
    }) => _extends({
      position: "relative",
      display: "inline-block",
      flex: "1 1 auto",
      whiteSpace: "nowrap"
    }, ownerState.fixed && {
      overflowX: "hidden",
      width: "100%"
    }, ownerState.hideScrollbar && {
      scrollbarWidth: "none",
      "&::-webkit-scrollbar": {
        display: "none"
      }
    }, ownerState.scrollableX && {
      overflowX: "auto",
      overflowY: "hidden"
    }, ownerState.scrollableY && {
      overflowY: "auto",
      overflowX: "hidden"
    }));
    FlexContainer = styled_default("div", {
      name: "MuiTabs",
      slot: "FlexContainer",
      overridesResolver: (props, styles2) => {
        const {
          ownerState
        } = props;
        return [styles2.flexContainer, ownerState.vertical && styles2.flexContainerVertical, ownerState.centered && styles2.centered];
      }
    })(({
      ownerState
    }) => _extends({
      display: "flex"
    }, ownerState.vertical && {
      flexDirection: "column"
    }, ownerState.centered && {
      justifyContent: "center"
    }));
    TabsIndicator = styled_default("span", {
      name: "MuiTabs",
      slot: "Indicator",
      overridesResolver: (props, styles2) => styles2.indicator
    })(({
      ownerState,
      theme
    }) => _extends({
      position: "absolute",
      height: 2,
      bottom: 0,
      width: "100%",
      transition: theme.transitions.create()
    }, ownerState.indicatorColor === "primary" && {
      backgroundColor: (theme.vars || theme).palette.primary.main
    }, ownerState.indicatorColor === "secondary" && {
      backgroundColor: (theme.vars || theme).palette.secondary.main
    }, ownerState.vertical && {
      height: "100%",
      width: 2,
      right: 0
    }));
    TabsScrollbarSize = styled_default(ScrollbarSize, {
      name: "MuiTabs",
      slot: "ScrollbarSize"
    })({
      overflowX: "auto",
      overflowY: "hidden",
      scrollbarWidth: "none",
      "&::-webkit-scrollbar": {
        display: "none"
      }
    });
    defaultIndicatorStyle = {};
    warnedOnceTabPresent = false;
    Tabs = React6.forwardRef(function Tabs2(inProps, ref) {
      const props = useThemeProps({
        props: inProps,
        name: "MuiTabs"
      });
      const theme = useTheme();
      const isRtl = theme.direction === "rtl";
      const {
        "aria-label": ariaLabel,
        "aria-labelledby": ariaLabelledBy,
        action,
        centered = false,
        children: childrenProp,
        className,
        component = "div",
        allowScrollButtonsMobile = false,
        indicatorColor = "primary",
        onChange,
        orientation = "horizontal",
        ScrollButtonComponent = TabScrollButton_default,
        scrollButtons = "auto",
        selectionFollowsFocus,
        slots = {},
        slotProps = {},
        TabIndicatorProps = {},
        TabScrollButtonProps = {},
        textColor = "primary",
        value,
        variant = "standard",
        visibleScrollbar = false
      } = props, other = _objectWithoutPropertiesLoose(props, _excluded5);
      const scrollable = variant === "scrollable";
      const vertical = orientation === "vertical";
      const scrollStart = vertical ? "scrollTop" : "scrollLeft";
      const start = vertical ? "top" : "left";
      const end = vertical ? "bottom" : "right";
      const clientSize = vertical ? "clientHeight" : "clientWidth";
      const size = vertical ? "height" : "width";
      const ownerState = _extends({}, props, {
        component,
        allowScrollButtonsMobile,
        indicatorColor,
        orientation,
        vertical,
        scrollButtons,
        textColor,
        variant,
        visibleScrollbar,
        fixed: !scrollable,
        hideScrollbar: scrollable && !visibleScrollbar,
        scrollableX: scrollable && !vertical,
        scrollableY: scrollable && vertical,
        centered: centered && !scrollable,
        scrollButtonsHideMobile: !allowScrollButtonsMobile
      });
      const classes = useUtilityClasses4(ownerState);
      const startScrollButtonIconProps = useSlotProps({
        elementType: slots.StartScrollButtonIcon,
        externalSlotProps: slotProps.startScrollButtonIcon,
        ownerState
      });
      const endScrollButtonIconProps = useSlotProps({
        elementType: slots.EndScrollButtonIcon,
        externalSlotProps: slotProps.endScrollButtonIcon,
        ownerState
      });
      if (true) {
        if (centered && scrollable) {
          console.error('MUI: You can not use the `centered={true}` and `variant="scrollable"` properties at the same time on a `Tabs` component.');
        }
      }
      const [mounted, setMounted] = React6.useState(false);
      const [indicatorStyle, setIndicatorStyle] = React6.useState(defaultIndicatorStyle);
      const [displayScroll, setDisplayScroll] = React6.useState({
        start: false,
        end: false
      });
      const [scrollerStyle, setScrollerStyle] = React6.useState({
        overflow: "hidden",
        scrollbarWidth: 0
      });
      const valueToIndex = /* @__PURE__ */ new Map();
      const tabsRef = React6.useRef(null);
      const tabListRef = React6.useRef(null);
      const getTabsMeta = () => {
        const tabsNode = tabsRef.current;
        let tabsMeta;
        if (tabsNode) {
          const rect = tabsNode.getBoundingClientRect();
          tabsMeta = {
            clientWidth: tabsNode.clientWidth,
            scrollLeft: tabsNode.scrollLeft,
            scrollTop: tabsNode.scrollTop,
            scrollLeftNormalized: getNormalizedScrollLeft(tabsNode, theme.direction),
            scrollWidth: tabsNode.scrollWidth,
            top: rect.top,
            bottom: rect.bottom,
            left: rect.left,
            right: rect.right
          };
        }
        let tabMeta;
        if (tabsNode && value !== false) {
          const children2 = tabListRef.current.children;
          if (children2.length > 0) {
            const tab = children2[valueToIndex.get(value)];
            if (true) {
              if (!tab) {
                console.error([`MUI: The \`value\` provided to the Tabs component is invalid.`, `None of the Tabs' children match with "${value}".`, valueToIndex.keys ? `You can provide one of the following values: ${Array.from(valueToIndex.keys()).join(", ")}.` : null].join("\n"));
              }
            }
            tabMeta = tab ? tab.getBoundingClientRect() : null;
            if (true) {
              if (!warnedOnceTabPresent && tabMeta && tabMeta.width === 0 && tabMeta.height === 0 && tabsMeta.clientWidth !== 0) {
                tabsMeta = null;
                console.error(["MUI: The `value` provided to the Tabs component is invalid.", `The Tab with this \`value\` ("${value}") is not part of the document layout.`, "Make sure the tab item is present in the document or that it's not `display: none`."].join("\n"));
                warnedOnceTabPresent = true;
              }
            }
          }
        }
        return {
          tabsMeta,
          tabMeta
        };
      };
      const updateIndicatorState = useEventCallback_default(() => {
        const {
          tabsMeta,
          tabMeta
        } = getTabsMeta();
        let startValue = 0;
        let startIndicator;
        if (vertical) {
          startIndicator = "top";
          if (tabMeta && tabsMeta) {
            startValue = tabMeta.top - tabsMeta.top + tabsMeta.scrollTop;
          }
        } else {
          startIndicator = isRtl ? "right" : "left";
          if (tabMeta && tabsMeta) {
            const correction = isRtl ? tabsMeta.scrollLeftNormalized + tabsMeta.clientWidth - tabsMeta.scrollWidth : tabsMeta.scrollLeft;
            startValue = (isRtl ? -1 : 1) * (tabMeta[startIndicator] - tabsMeta[startIndicator] + correction);
          }
        }
        const newIndicatorStyle = {
          [startIndicator]: startValue,
          [size]: tabMeta ? tabMeta[size] : 0
        };
        if (isNaN(indicatorStyle[startIndicator]) || isNaN(indicatorStyle[size])) {
          setIndicatorStyle(newIndicatorStyle);
        } else {
          const dStart = Math.abs(indicatorStyle[startIndicator] - newIndicatorStyle[startIndicator]);
          const dSize = Math.abs(indicatorStyle[size] - newIndicatorStyle[size]);
          if (dStart >= 1 || dSize >= 1) {
            setIndicatorStyle(newIndicatorStyle);
          }
        }
      });
      const scroll = (scrollValue, {
        animation = true
      } = {}) => {
        if (animation) {
          animate(scrollStart, tabsRef.current, scrollValue, {
            duration: theme.transitions.duration.standard
          });
        } else {
          tabsRef.current[scrollStart] = scrollValue;
        }
      };
      const moveTabsScroll = (delta) => {
        let scrollValue = tabsRef.current[scrollStart];
        if (vertical) {
          scrollValue += delta;
        } else {
          scrollValue += delta * (isRtl ? -1 : 1);
          scrollValue *= isRtl && detectScrollType() === "reverse" ? -1 : 1;
        }
        scroll(scrollValue);
      };
      const getScrollSize = () => {
        const containerSize = tabsRef.current[clientSize];
        let totalSize = 0;
        const children2 = Array.from(tabListRef.current.children);
        for (let i = 0; i < children2.length; i += 1) {
          const tab = children2[i];
          if (totalSize + tab[clientSize] > containerSize) {
            if (i === 0) {
              totalSize = containerSize;
            }
            break;
          }
          totalSize += tab[clientSize];
        }
        return totalSize;
      };
      const handleStartScrollClick = () => {
        moveTabsScroll(-1 * getScrollSize());
      };
      const handleEndScrollClick = () => {
        moveTabsScroll(getScrollSize());
      };
      const handleScrollbarSizeChange = React6.useCallback((scrollbarWidth) => {
        setScrollerStyle({
          overflow: null,
          scrollbarWidth
        });
      }, []);
      const getConditionalElements = () => {
        const conditionalElements2 = {};
        conditionalElements2.scrollbarSizeListener = scrollable ? (0, import_jsx_runtime6.jsx)(TabsScrollbarSize, {
          onChange: handleScrollbarSizeChange,
          className: clsx_m_default(classes.scrollableX, classes.hideScrollbar)
        }) : null;
        const scrollButtonsActive = displayScroll.start || displayScroll.end;
        const showScrollButtons = scrollable && (scrollButtons === "auto" && scrollButtonsActive || scrollButtons === true);
        conditionalElements2.scrollButtonStart = showScrollButtons ? (0, import_jsx_runtime6.jsx)(ScrollButtonComponent, _extends({
          slots: {
            StartScrollButtonIcon: slots.StartScrollButtonIcon
          },
          slotProps: {
            startScrollButtonIcon: startScrollButtonIconProps
          },
          orientation,
          direction: isRtl ? "right" : "left",
          onClick: handleStartScrollClick,
          disabled: !displayScroll.start
        }, TabScrollButtonProps, {
          className: clsx_m_default(classes.scrollButtons, TabScrollButtonProps.className)
        })) : null;
        conditionalElements2.scrollButtonEnd = showScrollButtons ? (0, import_jsx_runtime6.jsx)(ScrollButtonComponent, _extends({
          slots: {
            EndScrollButtonIcon: slots.EndScrollButtonIcon
          },
          slotProps: {
            endScrollButtonIcon: endScrollButtonIconProps
          },
          orientation,
          direction: isRtl ? "left" : "right",
          onClick: handleEndScrollClick,
          disabled: !displayScroll.end
        }, TabScrollButtonProps, {
          className: clsx_m_default(classes.scrollButtons, TabScrollButtonProps.className)
        })) : null;
        return conditionalElements2;
      };
      const scrollSelectedIntoView = useEventCallback_default((animation) => {
        const {
          tabsMeta,
          tabMeta
        } = getTabsMeta();
        if (!tabMeta || !tabsMeta) {
          return;
        }
        if (tabMeta[start] < tabsMeta[start]) {
          const nextScrollStart = tabsMeta[scrollStart] + (tabMeta[start] - tabsMeta[start]);
          scroll(nextScrollStart, {
            animation
          });
        } else if (tabMeta[end] > tabsMeta[end]) {
          const nextScrollStart = tabsMeta[scrollStart] + (tabMeta[end] - tabsMeta[end]);
          scroll(nextScrollStart, {
            animation
          });
        }
      });
      const updateScrollButtonState = useEventCallback_default(() => {
        if (scrollable && scrollButtons !== false) {
          const {
            scrollTop,
            scrollHeight,
            clientHeight,
            scrollWidth,
            clientWidth
          } = tabsRef.current;
          let showStartScroll;
          let showEndScroll;
          if (vertical) {
            showStartScroll = scrollTop > 1;
            showEndScroll = scrollTop < scrollHeight - clientHeight - 1;
          } else {
            const scrollLeft = getNormalizedScrollLeft(tabsRef.current, theme.direction);
            showStartScroll = isRtl ? scrollLeft < scrollWidth - clientWidth - 1 : scrollLeft > 1;
            showEndScroll = !isRtl ? scrollLeft < scrollWidth - clientWidth - 1 : scrollLeft > 1;
          }
          if (showStartScroll !== displayScroll.start || showEndScroll !== displayScroll.end) {
            setDisplayScroll({
              start: showStartScroll,
              end: showEndScroll
            });
          }
        }
      });
      React6.useEffect(() => {
        const handleResize = debounce_default(() => {
          if (tabsRef.current) {
            updateIndicatorState();
            updateScrollButtonState();
          }
        });
        const win = ownerWindow_default(tabsRef.current);
        win.addEventListener("resize", handleResize);
        let resizeObserver;
        if (typeof ResizeObserver !== "undefined") {
          resizeObserver = new ResizeObserver(handleResize);
          Array.from(tabListRef.current.children).forEach((child) => {
            resizeObserver.observe(child);
          });
        }
        return () => {
          handleResize.clear();
          win.removeEventListener("resize", handleResize);
          if (resizeObserver) {
            resizeObserver.disconnect();
          }
        };
      }, [updateIndicatorState, updateScrollButtonState]);
      const handleTabsScroll = React6.useMemo(() => debounce_default(() => {
        updateScrollButtonState();
      }), [updateScrollButtonState]);
      React6.useEffect(() => {
        return () => {
          handleTabsScroll.clear();
        };
      }, [handleTabsScroll]);
      React6.useEffect(() => {
        setMounted(true);
      }, []);
      React6.useEffect(() => {
        updateIndicatorState();
        updateScrollButtonState();
      });
      React6.useEffect(() => {
        scrollSelectedIntoView(defaultIndicatorStyle !== indicatorStyle);
      }, [scrollSelectedIntoView, indicatorStyle]);
      React6.useImperativeHandle(action, () => ({
        updateIndicator: updateIndicatorState,
        updateScrollButtons: updateScrollButtonState
      }), [updateIndicatorState, updateScrollButtonState]);
      const indicator = (0, import_jsx_runtime6.jsx)(TabsIndicator, _extends({}, TabIndicatorProps, {
        className: clsx_m_default(classes.indicator, TabIndicatorProps.className),
        ownerState,
        style: _extends({}, indicatorStyle, TabIndicatorProps.style)
      }));
      let childIndex = 0;
      const children = React6.Children.map(childrenProp, (child) => {
        if (!React6.isValidElement(child)) {
          return null;
        }
        if (true) {
          if ((0, import_react_is.isFragment)(child)) {
            console.error(["MUI: The Tabs component doesn't accept a Fragment as a child.", "Consider providing an array instead."].join("\n"));
          }
        }
        const childValue = child.props.value === void 0 ? childIndex : child.props.value;
        valueToIndex.set(childValue, childIndex);
        const selected = childValue === value;
        childIndex += 1;
        return React6.cloneElement(child, _extends({
          fullWidth: variant === "fullWidth",
          indicator: selected && !mounted && indicator,
          selected,
          selectionFollowsFocus,
          onChange,
          textColor,
          value: childValue
        }, childIndex === 1 && value === false && !child.props.tabIndex ? {
          tabIndex: 0
        } : {}));
      });
      const handleKeyDown = (event) => {
        const list = tabListRef.current;
        const currentFocus = ownerDocument_default(list).activeElement;
        const role = currentFocus.getAttribute("role");
        if (role !== "tab") {
          return;
        }
        let previousItemKey = orientation === "horizontal" ? "ArrowLeft" : "ArrowUp";
        let nextItemKey = orientation === "horizontal" ? "ArrowRight" : "ArrowDown";
        if (orientation === "horizontal" && isRtl) {
          previousItemKey = "ArrowRight";
          nextItemKey = "ArrowLeft";
        }
        switch (event.key) {
          case previousItemKey:
            event.preventDefault();
            moveFocus(list, currentFocus, previousItem);
            break;
          case nextItemKey:
            event.preventDefault();
            moveFocus(list, currentFocus, nextItem);
            break;
          case "Home":
            event.preventDefault();
            moveFocus(list, null, nextItem);
            break;
          case "End":
            event.preventDefault();
            moveFocus(list, null, previousItem);
            break;
          default:
            break;
        }
      };
      const conditionalElements = getConditionalElements();
      return (0, import_jsx_runtime7.jsxs)(TabsRoot, _extends({
        className: clsx_m_default(classes.root, className),
        ownerState,
        ref,
        as: component
      }, other, {
        children: [conditionalElements.scrollButtonStart, conditionalElements.scrollbarSizeListener, (0, import_jsx_runtime7.jsxs)(TabsScroller, {
          className: classes.scroller,
          ownerState,
          style: {
            overflow: scrollerStyle.overflow,
            [vertical ? `margin${isRtl ? "Left" : "Right"}` : "marginBottom"]: visibleScrollbar ? void 0 : -scrollerStyle.scrollbarWidth
          },
          ref: tabsRef,
          onScroll: handleTabsScroll,
          children: [(0, import_jsx_runtime6.jsx)(FlexContainer, {
            "aria-label": ariaLabel,
            "aria-labelledby": ariaLabelledBy,
            "aria-orientation": orientation === "vertical" ? "vertical" : null,
            className: classes.flexContainer,
            ownerState,
            onKeyDown: handleKeyDown,
            ref: tabListRef,
            role: "tablist",
            children
          }), mounted && indicator]
        }), conditionalElements.scrollButtonEnd]
      }));
    });
    true ? Tabs.propTypes = {
      action: refType_default,
      allowScrollButtonsMobile: import_prop_types5.default.bool,
      "aria-label": import_prop_types5.default.string,
      "aria-labelledby": import_prop_types5.default.string,
      centered: import_prop_types5.default.bool,
      children: import_prop_types5.default.node,
      classes: import_prop_types5.default.object,
      className: import_prop_types5.default.string,
      component: import_prop_types5.default.elementType,
      indicatorColor: import_prop_types5.default.oneOfType([import_prop_types5.default.oneOf(["primary", "secondary"]), import_prop_types5.default.string]),
      onChange: import_prop_types5.default.func,
      orientation: import_prop_types5.default.oneOf(["horizontal", "vertical"]),
      ScrollButtonComponent: import_prop_types5.default.elementType,
      scrollButtons: import_prop_types5.default.oneOf(["auto", false, true]),
      selectionFollowsFocus: import_prop_types5.default.bool,
      slotProps: import_prop_types5.default.shape({
        endScrollButtonIcon: import_prop_types5.default.oneOfType([import_prop_types5.default.func, import_prop_types5.default.object]),
        startScrollButtonIcon: import_prop_types5.default.oneOfType([import_prop_types5.default.func, import_prop_types5.default.object])
      }),
      slots: import_prop_types5.default.shape({
        EndScrollButtonIcon: import_prop_types5.default.elementType,
        StartScrollButtonIcon: import_prop_types5.default.elementType
      }),
      sx: import_prop_types5.default.oneOfType([import_prop_types5.default.arrayOf(import_prop_types5.default.oneOfType([import_prop_types5.default.func, import_prop_types5.default.object, import_prop_types5.default.bool])), import_prop_types5.default.func, import_prop_types5.default.object]),
      TabIndicatorProps: import_prop_types5.default.object,
      TabScrollButtonProps: import_prop_types5.default.object,
      textColor: import_prop_types5.default.oneOf(["inherit", "primary", "secondary"]),
      value: import_prop_types5.default.any,
      variant: import_prop_types5.default.oneOf(["fullWidth", "scrollable", "standard"]),
      visibleScrollbar: import_prop_types5.default.bool
    } : void 0;
    Tabs_default = Tabs;
  }
});

// node_modules/@mui/material/Tabs/index.js
var init_Tabs2 = __esm({
  "node_modules/@mui/material/Tabs/index.js"() {
    init_Tabs();
    init_tabsClasses();
    init_tabsClasses();
  }
});

export {
  getButtonUtilityClass,
  buttonClasses_default,
  ButtonGroupContext_default,
  init_ButtonGroupContext,
  Button_default,
  init_Button2 as init_Button,
  getSkeletonUtilityClass,
  skeletonClasses_default,
  Skeleton_default,
  init_Skeleton2 as init_Skeleton,
  getTabScrollButtonUtilityClass,
  tabScrollButtonClasses_default,
  TabScrollButton_default,
  init_TabScrollButton2 as init_TabScrollButton,
  getTabsUtilityClass,
  tabsClasses_default,
  Tabs_default,
  init_Tabs2 as init_Tabs
};
//# sourceMappingURL=chunk-NMTW2ZOF.js.map
