import "./chunk-J43GMYXM.js";

// node_modules/rambda/src/add.js
function add(a, b) {
  if (arguments.length === 1)
    return (_b) => add(a, _b);
  return Number(a) + Number(b);
}

// node_modules/rambda/src/_internals/cloneList.js
var cloneList = (list) => Array.prototype.slice.call(list);

// node_modules/rambda/src/curry.js
function curry(fn, args = []) {
  return (..._args) => ((rest) => rest.length >= fn.length ? fn(...rest) : curry(fn, rest))([
    ...args,
    ..._args
  ]);
}

// node_modules/rambda/src/adjust.js
function adjustFn(index, replaceFn2, list) {
  const actualIndex = index < 0 ? list.length + index : index;
  if (index >= list.length || actualIndex < 0)
    return list;
  const clone2 = cloneList(list);
  clone2[actualIndex] = replaceFn2(clone2[actualIndex]);
  return clone2;
}
var adjust = curry(adjustFn);

// node_modules/rambda/src/all.js
function all(predicate, list) {
  if (arguments.length === 1)
    return (_list) => all(predicate, _list);
  for (let i = 0; i < list.length; i++) {
    if (!predicate(list[i]))
      return false;
  }
  return true;
}

// node_modules/rambda/src/allPass.js
function allPass(predicates) {
  return (...input) => {
    let counter = 0;
    while (counter < predicates.length) {
      if (!predicates[counter](...input)) {
        return false;
      }
      counter++;
    }
    return true;
  };
}

// node_modules/rambda/src/always.js
function always(x) {
  return (_) => x;
}

// node_modules/rambda/src/and.js
function and(a, b) {
  if (arguments.length === 1)
    return (_b) => and(a, _b);
  return a && b;
}

// node_modules/rambda/src/any.js
function any(predicate, list) {
  if (arguments.length === 1)
    return (_list) => any(predicate, _list);
  let counter = 0;
  while (counter < list.length) {
    if (predicate(list[counter], counter)) {
      return true;
    }
    counter++;
  }
  return false;
}

// node_modules/rambda/src/anyPass.js
function anyPass(predicates) {
  return (...input) => {
    let counter = 0;
    while (counter < predicates.length) {
      if (predicates[counter](...input)) {
        return true;
      }
      counter++;
    }
    return false;
  };
}

// node_modules/rambda/src/append.js
function append(x, input) {
  if (arguments.length === 1)
    return (_input) => append(x, _input);
  if (typeof input === "string")
    return input.split("").concat(x);
  const clone2 = cloneList(input);
  clone2.push(x);
  return clone2;
}

// node_modules/rambda/src/apply.js
function apply(fn, args) {
  if (arguments.length === 1) {
    return (_args) => apply(fn, _args);
  }
  return fn.apply(this, args);
}

// node_modules/rambda/src/_internals/isArray.js
var { isArray } = Array;

// node_modules/rambda/src/applySpec.js
function __findHighestArity(spec, max2 = 0) {
  for (const key in spec) {
    if (spec.hasOwnProperty(key) === false || key === "constructor")
      continue;
    if (typeof spec[key] === "object") {
      max2 = Math.max(max2, __findHighestArity(spec[key]));
    }
    if (typeof spec[key] === "function") {
      max2 = Math.max(max2, spec[key].length);
    }
  }
  return max2;
}
function __filterUndefined() {
  const defined = [];
  let i = 0;
  const l = arguments.length;
  while (i < l) {
    if (typeof arguments[i] === "undefined")
      break;
    defined[i] = arguments[i];
    i++;
  }
  return defined;
}
function __applySpecWithArity(spec, arity, cache) {
  const remaining = arity - cache.length;
  if (remaining === 1)
    return (x) => __applySpecWithArity(
      spec,
      arity,
      __filterUndefined(...cache, x)
    );
  if (remaining === 2)
    return (x, y) => __applySpecWithArity(
      spec,
      arity,
      __filterUndefined(
        ...cache,
        x,
        y
      )
    );
  if (remaining === 3)
    return (x, y, z) => __applySpecWithArity(
      spec,
      arity,
      __filterUndefined(
        ...cache,
        x,
        y,
        z
      )
    );
  if (remaining === 4)
    return (x, y, z, a) => __applySpecWithArity(
      spec,
      arity,
      __filterUndefined(
        ...cache,
        x,
        y,
        z,
        a
      )
    );
  if (remaining > 4)
    return (...args) => __applySpecWithArity(
      spec,
      arity,
      __filterUndefined(...cache, ...args)
    );
  if (isArray(spec)) {
    const ret2 = [];
    let i = 0;
    const l = spec.length;
    for (; i < l; i++) {
      if (typeof spec[i] === "object" || isArray(spec[i])) {
        ret2[i] = __applySpecWithArity(
          spec[i],
          arity,
          cache
        );
      }
      if (typeof spec[i] === "function") {
        ret2[i] = spec[i](...cache);
      }
    }
    return ret2;
  }
  const ret = {};
  for (const key in spec) {
    if (spec.hasOwnProperty(key) === false || key === "constructor")
      continue;
    if (typeof spec[key] === "object") {
      ret[key] = __applySpecWithArity(
        spec[key],
        arity,
        cache
      );
      continue;
    }
    if (typeof spec[key] === "function") {
      ret[key] = spec[key](...cache);
    }
  }
  return ret;
}
function applySpec(spec, ...args) {
  const arity = __findHighestArity(spec);
  if (arity === 0) {
    return () => ({});
  }
  const toReturn = __applySpecWithArity(
    spec,
    arity,
    args
  );
  return toReturn;
}

// node_modules/rambda/src/assoc.js
function assocFn(prop2, newValue, obj) {
  return Object.assign(
    {},
    obj,
    { [prop2]: newValue }
  );
}
var assoc = curry(assocFn);

// node_modules/rambda/src/_internals/isInteger.js
function _isInteger(n) {
  return n << 0 === n;
}
var isInteger = Number.isInteger || _isInteger;

// node_modules/rambda/src/assocPath.js
function assocPathFn(path2, newValue, input) {
  const pathArrValue = typeof path2 === "string" ? path2.split(".").map((x) => isInteger(Number(x)) ? Number(x) : x) : path2;
  if (pathArrValue.length === 0) {
    return newValue;
  }
  const index = pathArrValue[0];
  if (pathArrValue.length > 1) {
    const condition = typeof input !== "object" || input === null || !input.hasOwnProperty(index);
    const nextInput = condition ? isInteger(pathArrValue[1]) ? [] : {} : input[index];
    newValue = assocPathFn(
      Array.prototype.slice.call(pathArrValue, 1),
      newValue,
      nextInput
    );
  }
  if (isInteger(index) && isArray(input)) {
    const arr = cloneList(input);
    arr[index] = newValue;
    return arr;
  }
  return assoc(
    index,
    newValue,
    input
  );
}
var assocPath = curry(assocPathFn);

// node_modules/rambda/src/curryN.js
function _curryN(n, cache, fn) {
  return function() {
    let ci = 0;
    let ai = 0;
    const cl = cache.length;
    const al = arguments.length;
    const args = new Array(cl + al);
    while (ci < cl) {
      args[ci] = cache[ci];
      ci++;
    }
    while (ai < al) {
      args[cl + ai] = arguments[ai];
      ai++;
    }
    const remaining = n - args.length;
    return args.length >= n ? fn.apply(this, args) : _arity(remaining, _curryN(
      n,
      args,
      fn
    ));
  };
}
function _arity(n, fn) {
  switch (n) {
    case 0:
      return function() {
        return fn.apply(this, arguments);
      };
    case 1:
      return function(_1) {
        return fn.apply(this, arguments);
      };
    case 2:
      return function(_1, _2) {
        return fn.apply(this, arguments);
      };
    case 3:
      return function(_1, _2, _3) {
        return fn.apply(this, arguments);
      };
    case 4:
      return function(_1, _2, _3, _4) {
        return fn.apply(this, arguments);
      };
    case 5:
      return function(_1, _2, _3, _4, _5) {
        return fn.apply(this, arguments);
      };
    case 6:
      return function(_1, _2, _3, _4, _5, _6) {
        return fn.apply(this, arguments);
      };
    case 7:
      return function(_1, _2, _3, _4, _5, _6, _7) {
        return fn.apply(this, arguments);
      };
    case 8:
      return function(_1, _2, _3, _4, _5, _6, _7, _8) {
        return fn.apply(this, arguments);
      };
    case 9:
      return function(_1, _2, _3, _4, _5, _6, _7, _8, _9) {
        return fn.apply(this, arguments);
      };
    default:
      return function(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10) {
        return fn.apply(this, arguments);
      };
  }
}
function curryN(n, fn) {
  if (arguments.length === 1)
    return (_fn) => curryN(n, _fn);
  if (n > 10) {
    throw new Error("First argument to _arity must be a non-negative integer no greater than ten");
  }
  return _arity(n, _curryN(
    n,
    [],
    fn
  ));
}

// node_modules/rambda/src/bind.js
function bind(fn, thisObj) {
  if (arguments.length === 1) {
    return (_thisObj) => bind(fn, _thisObj);
  }
  return curryN(fn.length, (...args) => fn.apply(thisObj, args));
}

// node_modules/rambda/src/both.js
function both(f, g) {
  if (arguments.length === 1)
    return (_g) => both(f, _g);
  return (...input) => f(...input) && g(...input);
}

// node_modules/rambda/src/chain.js
function chain(fn, list) {
  if (arguments.length === 1) {
    return (_list) => chain(fn, _list);
  }
  return [].concat(...list.map(fn));
}

// node_modules/rambda/src/clamp.js
function clampFn(min2, max2, input) {
  if (min2 > max2) {
    throw new Error("min must not be greater than max in clamp(min, max, value)");
  }
  if (input >= min2 && input <= max2)
    return input;
  if (input > max2)
    return max2;
  if (input < min2)
    return min2;
}
var clamp = curry(clampFn);

// node_modules/rambda/src/clone.js
function clone(input) {
  const out = isArray(input) ? Array(input.length) : {};
  if (input && input.getTime)
    return new Date(input.getTime());
  for (const key in input) {
    const v = input[key];
    out[key] = typeof v === "object" && v !== null ? v.getTime ? new Date(v.getTime()) : clone(v) : v;
  }
  return out;
}

// node_modules/rambda/src/complement.js
function complement(fn) {
  return (...input) => !fn(...input);
}

// node_modules/rambda/src/reduce.js
var ReduceStopper = class {
  constructor(value) {
    this.value = value;
  }
};
function reduceFn(reducer, acc, list) {
  if (!isArray(list)) {
    throw new TypeError("reduce: list must be array or iterable");
  }
  let index = 0;
  const len = list.length;
  while (index < len) {
    acc = reducer(
      acc,
      list[index],
      index,
      list
    );
    if (acc instanceof ReduceStopper) {
      return acc.value;
    }
    index++;
  }
  return acc;
}
var reduce = curry(reduceFn);
var reduceStopper = (value) => new ReduceStopper(value);

// node_modules/rambda/src/pipe.js
function _arity2(n, fn) {
  switch (n) {
    case 0:
      return function() {
        return fn.apply(this, arguments);
      };
    case 1:
      return function(a0) {
        return fn.apply(this, arguments);
      };
    case 2:
      return function(a0, a1) {
        return fn.apply(this, arguments);
      };
    case 3:
      return function(a0, a1, a2) {
        return fn.apply(this, arguments);
      };
    case 4:
      return function(a0, a1, a2, a3) {
        return fn.apply(this, arguments);
      };
    case 5:
      return function(a0, a1, a2, a3, a4) {
        return fn.apply(this, arguments);
      };
    case 6:
      return function(a0, a1, a2, a3, a4, a5) {
        return fn.apply(this, arguments);
      };
    case 7:
      return function(a0, a1, a2, a3, a4, a5, a6) {
        return fn.apply(this, arguments);
      };
    case 8:
      return function(a0, a1, a2, a3, a4, a5, a6, a7) {
        return fn.apply(this, arguments);
      };
    case 9:
      return function(a0, a1, a2, a3, a4, a5, a6, a7, a8) {
        return fn.apply(this, arguments);
      };
    case 10:
      return function(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
        return fn.apply(this, arguments);
      };
    default:
      throw new Error("First argument to _arity must be a non-negative integer no greater than ten");
  }
}
function _pipe(f, g) {
  return function() {
    return g.call(this, f.apply(this, arguments));
  };
}
function pipe() {
  if (arguments.length === 0) {
    throw new Error("pipe requires at least one argument");
  }
  return _arity2(
    arguments[0].length,
    reduceFn(
      _pipe,
      arguments[0],
      Array.prototype.slice.call(
        arguments,
        1,
        Infinity
      )
    )
  );
}

// node_modules/rambda/src/compose.js
function compose() {
  if (arguments.length === 0) {
    throw new Error("compose requires at least one argument");
  }
  return pipe.apply(this, Array.prototype.slice.call(arguments, 0).reverse());
}

// node_modules/rambda/src/concat.js
function concat(x, y) {
  if (arguments.length === 1)
    return (_y) => concat(x, _y);
  return typeof x === "string" ? `${x}${y}` : [...x, ...y];
}

// node_modules/rambda/src/cond.js
function cond(conditions) {
  return (input) => {
    let done = false;
    let toReturn;
    conditions.forEach(([predicate, resultClosure]) => {
      if (!done && predicate(input)) {
        done = true;
        toReturn = resultClosure(input);
      }
    });
    return toReturn;
  };
}

// node_modules/rambda/src/_internals/constants.js
var INCORRECT_ITERABLE_INPUT = "Incorrect iterable input";

// node_modules/rambda/src/_internals/keys.js
var { keys } = Object;

// node_modules/rambda/src/map.js
function mapArray(fn, list, isIndexed = false) {
  let index = 0;
  const willReturn = Array(list.length);
  while (index < list.length) {
    willReturn[index] = isIndexed ? fn(list[index], index) : fn(list[index]);
    index++;
  }
  return willReturn;
}
function mapObject(fn, obj) {
  if (arguments.length === 1) {
    return (_obj) => mapObject(fn, _obj);
  }
  let index = 0;
  const objKeys = keys(obj);
  const len = objKeys.length;
  const willReturn = {};
  while (index < len) {
    const key = objKeys[index];
    willReturn[key] = fn(
      obj[key],
      key,
      obj
    );
    index++;
  }
  return willReturn;
}
var mapObjIndexed = mapObject;
function map(fn, iterable) {
  if (arguments.length === 1)
    return (_iterable) => map(fn, _iterable);
  if (!iterable) {
    throw new Error(INCORRECT_ITERABLE_INPUT);
  }
  if (isArray(iterable))
    return mapArray(fn, iterable);
  return mapObject(fn, iterable);
}

// node_modules/rambda/src/max.js
function max(x, y) {
  if (arguments.length === 1)
    return (_y) => max(x, _y);
  return y > x ? y : x;
}

// node_modules/rambda/src/converge.js
function converge(fn, transformers) {
  if (arguments.length === 1)
    return (_transformers) => converge(fn, _transformers);
  const highestArity = reduce(
    (a, b) => max(a, b.length),
    0,
    transformers
  );
  return curryN(highestArity, function() {
    return fn.apply(
      this,
      map((g) => g.apply(this, arguments), transformers)
    );
  });
}

// node_modules/rambda/src/count.js
function count(predicate, list) {
  if (arguments.length === 1) {
    return (_list) => count(predicate, _list);
  }
  if (!isArray(list))
    return 0;
  return list.filter((x) => predicate(x)).length;
}

// node_modules/rambda/src/countBy.js
function countBy(fn, list) {
  if (arguments.length === 1) {
    return (_list) => countBy(fn, _list);
  }
  const willReturn = {};
  list.forEach((item) => {
    const key = fn(item);
    if (!willReturn[key]) {
      willReturn[key] = 1;
    } else {
      willReturn[key]++;
    }
  });
  return willReturn;
}

// node_modules/rambda/src/dec.js
var dec = (x) => x - 1;

// node_modules/rambda/src/defaultTo.js
function isFalsy(input) {
  return input === void 0 || input === null || Number.isNaN(input) === true;
}
function defaultTo(defaultArgument, input) {
  if (arguments.length === 1) {
    return (_input) => defaultTo(defaultArgument, _input);
  }
  return isFalsy(input) ? defaultArgument : input;
}

// node_modules/rambda/src/type.js
function type(input) {
  if (input === null) {
    return "Null";
  } else if (input === void 0) {
    return "Undefined";
  } else if (Number.isNaN(input)) {
    return "NaN";
  }
  const typeResult = Object.prototype.toString.call(input).slice(8, -1);
  return typeResult === "AsyncFunction" ? "Promise" : typeResult;
}

// node_modules/rambda/src/equals.js
function _lastIndexOf(valueToFind, list) {
  if (!isArray(list)) {
    throw new Error(`Cannot read property 'indexOf' of ${list}`);
  }
  const typeOfValue = type(valueToFind);
  if (!["Object", "Array", "NaN", "RegExp"].includes(typeOfValue))
    return list.lastIndexOf(valueToFind);
  const { length: length2 } = list;
  let index = length2;
  let foundIndex = -1;
  while (--index > -1 && foundIndex === -1) {
    if (equals(list[index], valueToFind)) {
      foundIndex = index;
    }
  }
  return foundIndex;
}
function _indexOf(valueToFind, list) {
  if (!isArray(list)) {
    throw new Error(`Cannot read property 'indexOf' of ${list}`);
  }
  const typeOfValue = type(valueToFind);
  if (!["Object", "Array", "NaN", "RegExp"].includes(typeOfValue))
    return list.indexOf(valueToFind);
  let index = -1;
  let foundIndex = -1;
  const { length: length2 } = list;
  while (++index < length2 && foundIndex === -1) {
    if (equals(list[index], valueToFind)) {
      foundIndex = index;
    }
  }
  return foundIndex;
}
function _arrayFromIterator(iter) {
  const list = [];
  let next;
  while (!(next = iter.next()).done) {
    list.push(next.value);
  }
  return list;
}
function _equalsSets(a, b) {
  if (a.size !== b.size) {
    return false;
  }
  const aList = _arrayFromIterator(a.values());
  const bList = _arrayFromIterator(b.values());
  const filtered = aList.filter((aInstance) => _indexOf(aInstance, bList) === -1);
  return filtered.length === 0;
}
function parseError(maybeError) {
  const typeofError = maybeError.__proto__.toString();
  if (!["Error", "TypeError"].includes(typeofError))
    return [];
  return [typeofError, maybeError.message];
}
function parseDate(maybeDate) {
  if (!maybeDate.toDateString)
    return [false];
  return [true, maybeDate.getTime()];
}
function parseRegex(maybeRegex) {
  if (maybeRegex.constructor !== RegExp)
    return [false];
  return [true, maybeRegex.toString()];
}
function equals(a, b) {
  if (arguments.length === 1)
    return (_b) => equals(a, _b);
  const aType = type(a);
  if (aType !== type(b))
    return false;
  if (aType === "Function") {
    return a.name === void 0 ? false : a.name === b.name;
  }
  if (["NaN", "Undefined", "Null"].includes(aType))
    return true;
  if (aType === "Number") {
    if (Object.is(-0, a) !== Object.is(-0, b))
      return false;
    return a.toString() === b.toString();
  }
  if (["String", "Boolean"].includes(aType)) {
    return a.toString() === b.toString();
  }
  if (aType === "Array") {
    const aClone = Array.from(a);
    const bClone = Array.from(b);
    if (aClone.toString() !== bClone.toString()) {
      return false;
    }
    let loopArrayFlag = true;
    aClone.forEach((aCloneInstance, aCloneIndex) => {
      if (loopArrayFlag) {
        if (aCloneInstance !== bClone[aCloneIndex] && !equals(aCloneInstance, bClone[aCloneIndex])) {
          loopArrayFlag = false;
        }
      }
    });
    return loopArrayFlag;
  }
  const aRegex = parseRegex(a);
  const bRegex = parseRegex(b);
  if (aRegex[0]) {
    return bRegex[0] ? aRegex[1] === bRegex[1] : false;
  } else if (bRegex[0])
    return false;
  const aDate = parseDate(a);
  const bDate = parseDate(b);
  if (aDate[0]) {
    return bDate[0] ? aDate[1] === bDate[1] : false;
  } else if (bDate[0])
    return false;
  const aError = parseError(a);
  const bError = parseError(b);
  if (aError[0]) {
    return bError[0] ? aError[0] === bError[0] && aError[1] === bError[1] : false;
  }
  if (aType === "Set") {
    return _equalsSets(a, b);
  }
  if (aType === "Object") {
    const aKeys = Object.keys(a);
    if (aKeys.length !== Object.keys(b).length) {
      return false;
    }
    let loopObjectFlag = true;
    aKeys.forEach((aKeyInstance) => {
      if (loopObjectFlag) {
        const aValue = a[aKeyInstance];
        const bValue = b[aKeyInstance];
        if (aValue !== bValue && !equals(aValue, bValue)) {
          loopObjectFlag = false;
        }
      }
    });
    return loopObjectFlag;
  }
  return false;
}

// node_modules/rambda/src/includes.js
function includes(valueToFind, iterable) {
  if (arguments.length === 1)
    return (_iterable) => includes(valueToFind, _iterable);
  if (typeof iterable === "string") {
    return iterable.includes(valueToFind);
  }
  if (!iterable) {
    throw new TypeError(`Cannot read property 'indexOf' of ${iterable}`);
  }
  if (!isArray(iterable))
    return false;
  return _indexOf(valueToFind, iterable) > -1;
}

// node_modules/rambda/src/_internals/set.js
var _Set = class {
  constructor() {
    this.set = /* @__PURE__ */ new Set();
    this.items = {};
  }
  checkUniqueness(item) {
    const type2 = type(item);
    if (["Null", "Undefined", "NaN"].includes(type2)) {
      if (type2 in this.items) {
        return false;
      }
      this.items[type2] = true;
      return true;
    }
    if (!["Object", "Array"].includes(type2)) {
      const prevSize = this.set.size;
      this.set.add(item);
      return this.set.size !== prevSize;
    }
    if (!(type2 in this.items)) {
      this.items[type2] = [item];
      return true;
    }
    if (_indexOf(item, this.items[type2]) === -1) {
      this.items[type2].push(item);
      return true;
    }
    return false;
  }
};

// node_modules/rambda/src/uniq.js
function uniq(list) {
  const set2 = new _Set();
  const willReturn = [];
  list.forEach((item) => {
    if (set2.checkUniqueness(item)) {
      willReturn.push(item);
    }
  });
  return willReturn;
}

// node_modules/rambda/src/difference.js
function difference(a, b) {
  if (arguments.length === 1)
    return (_b) => difference(a, _b);
  return uniq(a).filter((aInstance) => !includes(aInstance, b));
}

// node_modules/rambda/src/dissoc.js
function dissoc(prop2, obj) {
  if (arguments.length === 1)
    return (_obj) => dissoc(prop2, _obj);
  if (obj === null || obj === void 0)
    return {};
  const willReturn = {};
  for (const p in obj) {
    willReturn[p] = obj[p];
  }
  delete willReturn[prop2];
  return willReturn;
}

// node_modules/rambda/src/divide.js
function divide(a, b) {
  if (arguments.length === 1)
    return (_b) => divide(a, _b);
  return a / b;
}

// node_modules/rambda/src/drop.js
function drop(howManyToDrop, listOrString) {
  if (arguments.length === 1)
    return (_list) => drop(howManyToDrop, _list);
  return listOrString.slice(howManyToDrop > 0 ? howManyToDrop : 0);
}

// node_modules/rambda/src/dropLast.js
function dropLast(howManyToDrop, listOrString) {
  if (arguments.length === 1) {
    return (_listOrString) => dropLast(howManyToDrop, _listOrString);
  }
  return howManyToDrop > 0 ? listOrString.slice(0, -howManyToDrop) : listOrString.slice();
}

// node_modules/rambda/src/dropLastWhile.js
function dropLastWhile(predicate, iterable) {
  if (arguments.length === 1) {
    return (_iterable) => dropLastWhile(predicate, _iterable);
  }
  if (iterable.length === 0)
    return iterable;
  const isArray2 = isArray(iterable);
  if (typeof predicate !== "function") {
    throw new Error(`'predicate' is from wrong type ${typeof predicate}`);
  }
  if (!isArray2 && typeof iterable !== "string") {
    throw new Error(`'iterable' is from wrong type ${typeof iterable}`);
  }
  const toReturn = [];
  let counter = iterable.length;
  while (counter) {
    const item = iterable[--counter];
    if (!predicate(item)) {
      toReturn.push(item);
      break;
    }
  }
  while (counter) {
    toReturn.push(iterable[--counter]);
  }
  return isArray2 ? toReturn.reverse() : toReturn.reverse().join("");
}

// node_modules/rambda/src/dropRepeats.js
function dropRepeats(list) {
  if (!isArray(list)) {
    throw new Error(`${list} is not a list`);
  }
  const toReturn = [];
  list.reduce((prev, current) => {
    if (!equals(prev, current)) {
      toReturn.push(current);
    }
    return current;
  }, void 0);
  return toReturn;
}

// node_modules/rambda/src/dropRepeatsWith.js
function dropRepeatsWith(predicate, list) {
  if (arguments.length === 1) {
    return (_iterable) => dropRepeatsWith(predicate, _iterable);
  }
  if (!isArray(list)) {
    throw new Error(`${list} is not a list`);
  }
  const toReturn = [];
  list.reduce((prev, current) => {
    if (prev === void 0) {
      toReturn.push(current);
      return current;
    }
    if (!predicate(prev, current)) {
      toReturn.push(current);
    }
    return current;
  }, void 0);
  return toReturn;
}

// node_modules/rambda/src/dropWhile.js
function dropWhile(predicate, iterable) {
  if (arguments.length === 1) {
    return (_iterable) => dropWhile(predicate, _iterable);
  }
  const isArray2 = isArray(iterable);
  if (!isArray2 && typeof iterable !== "string") {
    throw new Error("`iterable` is neither list nor a string");
  }
  const toReturn = [];
  let counter = 0;
  while (counter < iterable.length) {
    const item = iterable[counter++];
    if (!predicate(item)) {
      toReturn.push(item);
      break;
    }
  }
  while (counter < iterable.length) {
    toReturn.push(iterable[counter++]);
  }
  return isArray2 ? toReturn : toReturn.join("");
}

// node_modules/rambda/src/either.js
function either(firstPredicate, secondPredicate) {
  if (arguments.length === 1) {
    return (_secondPredicate) => either(firstPredicate, _secondPredicate);
  }
  return (...input) => Boolean(firstPredicate(...input) || secondPredicate(...input));
}

// node_modules/rambda/src/endsWith.js
function endsWith(target, iterable) {
  if (arguments.length === 1)
    return (_iterable) => endsWith(target, _iterable);
  if (typeof iterable === "string") {
    return iterable.endsWith(target);
  }
  if (!isArray(target))
    return false;
  const diff = iterable.length - target.length;
  let correct = true;
  const filtered = target.filter((x, index) => {
    if (!correct)
      return false;
    const result = equals(x, iterable[index + diff]);
    if (!result)
      correct = false;
    return result;
  });
  return filtered.length === target.length;
}

// node_modules/rambda/src/prop.js
function prop(propToFind, obj) {
  if (arguments.length === 1)
    return (_obj) => prop(propToFind, _obj);
  if (!obj)
    return void 0;
  return obj[propToFind];
}

// node_modules/rambda/src/eqProps.js
function eqPropsFn(property, objA, objB) {
  return equals(prop(property, objA), prop(property, objB));
}
var eqProps = curry(eqPropsFn);

// node_modules/rambda/src/evolve.js
function evolveArray(rules, list) {
  return mapArray(
    (x, i) => {
      if (type(rules[i]) === "Function") {
        return rules[i](x);
      }
      return x;
    },
    list,
    true
  );
}
function evolveObject(rules, iterable) {
  return mapObject((x, prop2) => {
    if (type(x) === "Object") {
      const typeRule = type(rules[prop2]);
      if (typeRule === "Function") {
        return rules[prop2](x);
      }
      if (typeRule === "Object") {
        return evolve(rules[prop2], x);
      }
      return x;
    }
    if (type(rules[prop2]) === "Function") {
      return rules[prop2](x);
    }
    return x;
  }, iterable);
}
function evolve(rules, iterable) {
  if (arguments.length === 1) {
    return (_iterable) => evolve(rules, _iterable);
  }
  const rulesType = type(rules);
  const iterableType = type(iterable);
  if (iterableType !== rulesType) {
    throw new Error("iterableType !== rulesType");
  }
  if (!["Object", "Array"].includes(rulesType)) {
    throw new Error(`'iterable' and 'rules' are from wrong type ${rulesType}`);
  }
  if (iterableType === "Object") {
    return evolveObject(rules, iterable);
  }
  return evolveArray(rules, iterable);
}

// node_modules/rambda/src/F.js
function F() {
  return false;
}

// node_modules/rambda/src/filter.js
function filterObject(predicate, obj) {
  const willReturn = {};
  for (const prop2 in obj) {
    if (predicate(
      obj[prop2],
      prop2,
      obj
    )) {
      willReturn[prop2] = obj[prop2];
    }
  }
  return willReturn;
}
function filterArray(predicate, list, indexed = false) {
  let index = 0;
  const len = list.length;
  const willReturn = [];
  while (index < len) {
    const predicateResult = indexed ? predicate(list[index], index) : predicate(list[index]);
    if (predicateResult) {
      willReturn.push(list[index]);
    }
    index++;
  }
  return willReturn;
}
function filter(predicate, iterable) {
  if (arguments.length === 1)
    return (_iterable) => filter(predicate, _iterable);
  if (!iterable) {
    throw new Error("Incorrect iterable input");
  }
  if (isArray(iterable))
    return filterArray(
      predicate,
      iterable,
      false
    );
  return filterObject(predicate, iterable);
}

// node_modules/rambda/src/find.js
function find(predicate, list) {
  if (arguments.length === 1)
    return (_list) => find(predicate, _list);
  let index = 0;
  const len = list.length;
  while (index < len) {
    const x = list[index];
    if (predicate(x)) {
      return x;
    }
    index++;
  }
}

// node_modules/rambda/src/findIndex.js
function findIndex(predicate, list) {
  if (arguments.length === 1)
    return (_list) => findIndex(predicate, _list);
  const len = list.length;
  let index = -1;
  while (++index < len) {
    if (predicate(list[index])) {
      return index;
    }
  }
  return -1;
}

// node_modules/rambda/src/findLast.js
function findLast(predicate, list) {
  if (arguments.length === 1)
    return (_list) => findLast(predicate, _list);
  let index = list.length;
  while (--index >= 0) {
    if (predicate(list[index])) {
      return list[index];
    }
  }
  return void 0;
}

// node_modules/rambda/src/findLastIndex.js
function findLastIndex(fn, list) {
  if (arguments.length === 1)
    return (_list) => findLastIndex(fn, _list);
  let index = list.length;
  while (--index >= 0) {
    if (fn(list[index])) {
      return index;
    }
  }
  return -1;
}

// node_modules/rambda/src/flatten.js
function flatten(list, input) {
  const willReturn = input === void 0 ? [] : input;
  for (let i = 0; i < list.length; i++) {
    if (isArray(list[i])) {
      flatten(list[i], willReturn);
    } else {
      willReturn.push(list[i]);
    }
  }
  return willReturn;
}

// node_modules/rambda/src/flip.js
function flipFn(fn) {
  return (...input) => {
    if (input.length === 1) {
      return (holder) => fn(holder, input[0]);
    } else if (input.length === 2) {
      return fn(input[1], input[0]);
    } else if (input.length === 3) {
      return fn(
        input[1],
        input[0],
        input[2]
      );
    } else if (input.length === 4) {
      return fn(
        input[1],
        input[0],
        input[2],
        input[3]
      );
    }
    throw new Error("R.flip doesn't work with arity > 4");
  };
}
function flip(fn) {
  return flipFn(fn);
}

// node_modules/rambda/src/forEach.js
function forEach(fn, list) {
  if (arguments.length === 1)
    return (_list) => forEach(fn, _list);
  if (list === void 0) {
    return;
  }
  if (isArray(list)) {
    let index = 0;
    const len = list.length;
    while (index < len) {
      fn(list[index]);
      index++;
    }
  } else {
    let index = 0;
    const listKeys = keys(list);
    const len = listKeys.length;
    while (index < len) {
      const key = listKeys[index];
      fn(
        list[key],
        key,
        list
      );
      index++;
    }
  }
  return list;
}

// node_modules/rambda/src/fromPairs.js
function fromPairs(listOfPairs) {
  const toReturn = {};
  listOfPairs.forEach(([prop2, value]) => toReturn[prop2] = value);
  return toReturn;
}

// node_modules/rambda/src/groupBy.js
function groupBy(groupFn, list) {
  if (arguments.length === 1)
    return (_list) => groupBy(groupFn, _list);
  const result = {};
  for (let i = 0; i < list.length; i++) {
    const item = list[i];
    const key = groupFn(item);
    if (!result[key]) {
      result[key] = [];
    }
    result[key].push(item);
  }
  return result;
}

// node_modules/rambda/src/groupWith.js
function groupWith(compareFn, list) {
  if (!isArray(list))
    throw new TypeError("list.reduce is not a function");
  const clone2 = cloneList(list);
  if (list.length === 1)
    return [clone2];
  const toReturn = [];
  let holder = [];
  clone2.reduce((prev, current, i) => {
    if (i === 0)
      return current;
    const okCompare = compareFn(prev, current);
    const holderIsEmpty = holder.length === 0;
    const lastCall = i === list.length - 1;
    if (okCompare) {
      if (holderIsEmpty)
        holder.push(prev);
      holder.push(current);
      if (lastCall)
        toReturn.push(holder);
      return current;
    }
    if (holderIsEmpty) {
      toReturn.push([prev]);
      if (lastCall)
        toReturn.push([current]);
      return current;
    }
    toReturn.push(holder);
    if (lastCall)
      toReturn.push([current]);
    holder = [];
    return current;
  }, void 0);
  return toReturn;
}

// node_modules/rambda/src/has.js
function has(prop2, obj) {
  if (arguments.length === 1)
    return (_obj) => has(prop2, _obj);
  if (!obj)
    return false;
  return obj.hasOwnProperty(prop2);
}

// node_modules/rambda/src/_internals/createPath.js
function createPath(path2, delimiter = ".") {
  return typeof path2 === "string" ? path2.split(delimiter) : path2;
}

// node_modules/rambda/src/path.js
function path(pathInput, obj) {
  if (arguments.length === 1)
    return (_obj) => path(pathInput, _obj);
  if (obj === null || obj === void 0) {
    return void 0;
  }
  let willReturn = obj;
  let counter = 0;
  const pathArrValue = createPath(pathInput);
  while (counter < pathArrValue.length) {
    if (willReturn === null || willReturn === void 0) {
      return void 0;
    }
    if (willReturn[pathArrValue[counter]] === null)
      return void 0;
    willReturn = willReturn[pathArrValue[counter]];
    counter++;
  }
  return willReturn;
}

// node_modules/rambda/src/hasPath.js
function hasPath(pathInput, obj) {
  if (arguments.length === 1) {
    return (objHolder) => hasPath(pathInput, objHolder);
  }
  return path(pathInput, obj) !== void 0;
}

// node_modules/rambda/src/head.js
function head(listOrString) {
  if (typeof listOrString === "string")
    return listOrString[0] || "";
  return listOrString[0];
}

// node_modules/rambda/src/_internals/objectIs.js
function _objectIs(a, b) {
  if (a === b) {
    return a !== 0 || 1 / a === 1 / b;
  }
  return a !== a && b !== b;
}
var objectIs = Object.is || _objectIs;

// node_modules/rambda/src/identical.js
function identical(a, b) {
  if (arguments.length === 1)
    return (_b) => identical(a, _b);
  return objectIs(a, b);
}

// node_modules/rambda/src/identity.js
function identity(x) {
  return x;
}

// node_modules/rambda/src/ifElse.js
function ifElseFn(condition, onTrue, onFalse) {
  return (...input) => {
    const conditionResult = typeof condition === "boolean" ? condition : condition(...input);
    if (conditionResult === true) {
      return onTrue(...input);
    }
    return onFalse(...input);
  };
}
var ifElse = curry(ifElseFn);

// node_modules/rambda/src/inc.js
var inc = (x) => x + 1;

// node_modules/rambda/src/indexBy.js
function indexByPath(pathInput, list) {
  const toReturn = {};
  for (let i = 0; i < list.length; i++) {
    const item = list[i];
    toReturn[path(pathInput, item)] = item;
  }
  return toReturn;
}
function indexBy(condition, list) {
  if (arguments.length === 1) {
    return (_list) => indexBy(condition, _list);
  }
  if (typeof condition === "string") {
    return indexByPath(condition, list);
  }
  const toReturn = {};
  for (let i = 0; i < list.length; i++) {
    const item = list[i];
    toReturn[condition(item)] = item;
  }
  return toReturn;
}

// node_modules/rambda/src/indexOf.js
function indexOf(valueToFind, list) {
  if (arguments.length === 1) {
    return (_list) => _indexOf(valueToFind, _list);
  }
  return _indexOf(valueToFind, list);
}

// node_modules/rambda/src/_internals/baseSlice.js
function baseSlice(array, start, end) {
  let index = -1;
  let { length: length2 } = array;
  end = end > length2 ? length2 : end;
  if (end < 0) {
    end += length2;
  }
  length2 = start > end ? 0 : end - start >>> 0;
  start >>>= 0;
  const result = Array(length2);
  while (++index < length2) {
    result[index] = array[index + start];
  }
  return result;
}

// node_modules/rambda/src/init.js
function init(listOrString) {
  if (typeof listOrString === "string")
    return listOrString.slice(0, -1);
  return listOrString.length ? baseSlice(
    listOrString,
    0,
    -1
  ) : [];
}

// node_modules/rambda/src/intersection.js
function intersection(listA, listB) {
  if (arguments.length === 1)
    return (_list) => intersection(listA, _list);
  return filter((x) => includes(x, listA), listB);
}

// node_modules/rambda/src/intersperse.js
function intersperse(separator, list) {
  if (arguments.length === 1)
    return (_list) => intersperse(separator, _list);
  let index = -1;
  const len = list.length;
  const willReturn = [];
  while (++index < len) {
    if (index === len - 1) {
      willReturn.push(list[index]);
    } else {
      willReturn.push(list[index], separator);
    }
  }
  return willReturn;
}

// node_modules/rambda/src/is.js
function is(targetPrototype, x) {
  if (arguments.length === 1)
    return (_x) => is(targetPrototype, _x);
  return x != null && x.constructor === targetPrototype || x instanceof targetPrototype;
}

// node_modules/rambda/src/isEmpty.js
function isEmpty(input) {
  const inputType = type(input);
  if (["Undefined", "NaN", "Number", "Null"].includes(inputType))
    return false;
  if (!input)
    return true;
  if (inputType === "Object") {
    return Object.keys(input).length === 0;
  }
  if (inputType === "Array") {
    return input.length === 0;
  }
  return false;
}

// node_modules/rambda/src/isNil.js
function isNil(x) {
  return x === void 0 || x === null;
}

// node_modules/rambda/src/join.js
function join(glue, list) {
  if (arguments.length === 1)
    return (_list) => join(glue, _list);
  return list.join(glue);
}

// node_modules/rambda/src/juxt.js
function juxt(listOfFunctions) {
  return (...args) => listOfFunctions.map((fn) => fn(...args));
}

// node_modules/rambda/src/keys.js
function keys2(x) {
  return Object.keys(x);
}

// node_modules/rambda/src/last.js
function last(listOrString) {
  if (typeof listOrString === "string") {
    return listOrString[listOrString.length - 1] || "";
  }
  return listOrString[listOrString.length - 1];
}

// node_modules/rambda/src/lastIndexOf.js
function lastIndexOf(valueToFind, list) {
  if (arguments.length === 1) {
    return (_list) => _lastIndexOf(valueToFind, _list);
  }
  return _lastIndexOf(valueToFind, list);
}

// node_modules/rambda/src/length.js
function length(x) {
  if (isArray(x))
    return x.length;
  if (typeof x === "string")
    return x.length;
  return NaN;
}

// node_modules/rambda/src/lens.js
function lens(getter, setter) {
  return function(functor) {
    return function(target) {
      return functor(getter(target)).map((focus) => setter(focus, target));
    };
  };
}

// node_modules/rambda/src/nth.js
function nth(index, input) {
  if (arguments.length === 1)
    return (_input) => nth(index, _input);
  const idx = index < 0 ? input.length + index : index;
  return Object.prototype.toString.call(input) === "[object String]" ? input.charAt(idx) : input[idx];
}

// node_modules/rambda/src/update.js
function updateFn(index, newValue, list) {
  const clone2 = cloneList(list);
  if (index === -1)
    return clone2.fill(newValue, index);
  return clone2.fill(
    newValue,
    index,
    index + 1
  );
}
var update = curry(updateFn);

// node_modules/rambda/src/lensIndex.js
function lensIndex(index) {
  return lens(nth(index), update(index));
}

// node_modules/rambda/src/lensPath.js
function lensPath(key) {
  return lens(path(key), assocPath(key));
}

// node_modules/rambda/src/lensProp.js
function lensProp(key) {
  return lens(prop(key), assoc(key));
}

// node_modules/rambda/src/match.js
function match(pattern, input) {
  if (arguments.length === 1)
    return (_input) => match(pattern, _input);
  const willReturn = input.match(pattern);
  return willReturn === null ? [] : willReturn;
}

// node_modules/rambda/src/mathMod.js
function mathMod(x, y) {
  if (arguments.length === 1)
    return (_y) => mathMod(x, _y);
  if (!isInteger(x) || !isInteger(y) || y < 1)
    return NaN;
  return (x % y + y) % y;
}

// node_modules/rambda/src/maxBy.js
function maxByFn(compareFn, x, y) {
  return compareFn(y) > compareFn(x) ? y : x;
}
var maxBy = curry(maxByFn);

// node_modules/rambda/src/sum.js
function sum(list) {
  return list.reduce((prev, current) => prev + current, 0);
}

// node_modules/rambda/src/mean.js
function mean(list) {
  return sum(list) / list.length;
}

// node_modules/rambda/src/median.js
function median(list) {
  const len = list.length;
  if (len === 0)
    return NaN;
  const width = 2 - len % 2;
  const idx = (len - width) / 2;
  return mean(Array.prototype.slice.call(list, 0).sort((a, b) => {
    if (a === b)
      return 0;
    return a < b ? -1 : 1;
  }).slice(idx, idx + width));
}

// node_modules/rambda/src/mergeRight.js
function mergeRight(target, newProps) {
  if (arguments.length === 1)
    return (_newProps) => mergeRight(target, _newProps);
  return Object.assign(
    {},
    target || {},
    newProps || {}
  );
}

// node_modules/rambda/src/mergeAll.js
function mergeAll(arr) {
  let willReturn = {};
  map((val) => {
    willReturn = mergeRight(willReturn, val);
  }, arr);
  return willReturn;
}

// node_modules/rambda/src/mergeDeepRight.js
function mergeDeepRight(target, source) {
  if (arguments.length === 1) {
    return (sourceHolder) => mergeDeepRight(target, sourceHolder);
  }
  const willReturn = clone(target);
  Object.keys(source).forEach((key) => {
    if (type(source[key]) === "Object") {
      if (type(target[key]) === "Object") {
        willReturn[key] = mergeDeepRight(target[key], source[key]);
      } else {
        willReturn[key] = source[key];
      }
    } else {
      willReturn[key] = source[key];
    }
  });
  return willReturn;
}

// node_modules/rambda/src/mergeLeft.js
function mergeLeft(x, y) {
  if (arguments.length === 1)
    return (_y) => mergeLeft(x, _y);
  return mergeRight(y, x);
}

// node_modules/rambda/src/mergeWith.js
function mergeWithFn(mergeFn, a, b) {
  const willReturn = {};
  Object.keys(a).forEach((key) => {
    if (b[key] === void 0) {
      willReturn[key] = a[key];
    } else {
      willReturn[key] = mergeFn(a[key], b[key]);
    }
  });
  Object.keys(b).forEach((key) => {
    if (willReturn[key] !== void 0)
      return;
    if (a[key] === void 0) {
      willReturn[key] = b[key];
    } else {
      willReturn[key] = mergeFn(a[key], b[key]);
    }
  });
  return willReturn;
}
var mergeWith = curry(mergeWithFn);

// node_modules/rambda/src/min.js
function min(x, y) {
  if (arguments.length === 1)
    return (_y) => min(x, _y);
  return y < x ? y : x;
}

// node_modules/rambda/src/minBy.js
function minByFn(compareFn, x, y) {
  return compareFn(y) < compareFn(x) ? y : x;
}
var minBy = curry(minByFn);

// node_modules/rambda/src/_internals/isIterable.js
function isIterable(input) {
  return Array.isArray(input) || type(input) === "Object";
}

// node_modules/rambda/src/modify.js
function modifyFn(property, fn, iterable) {
  if (!isIterable(iterable))
    return iterable;
  if (iterable[property] === void 0)
    return iterable;
  if (isArray(iterable)) {
    return updateFn(
      property,
      fn(iterable[property]),
      iterable
    );
  }
  return {
    ...iterable,
    [property]: fn(iterable[property])
  };
}
var modify = curry(modifyFn);

// node_modules/rambda/src/modifyPath.js
function modifyPathFn(pathInput, fn, object) {
  const path2 = createPath(pathInput);
  if (path2.length === 1) {
    return {
      ...object,
      [path2[0]]: fn(object[path2[0]])
    };
  }
  if (path(path2, object) === void 0)
    return object;
  const val = modifyPath(
    Array.prototype.slice.call(path2, 1),
    fn,
    object[path2[0]]
  );
  if (val === object[path2[0]]) {
    return object;
  }
  return assoc(
    path2[0],
    val,
    object
  );
}
var modifyPath = curry(modifyPathFn);

// node_modules/rambda/src/modulo.js
function modulo(x, y) {
  if (arguments.length === 1)
    return (_y) => modulo(x, _y);
  return x % y;
}

// node_modules/rambda/src/move.js
function moveFn(fromIndex, toIndex, list) {
  if (fromIndex < 0 || toIndex < 0) {
    throw new Error("Rambda.move does not support negative indexes");
  }
  if (fromIndex > list.length - 1 || toIndex > list.length - 1)
    return list;
  const clone2 = cloneList(list);
  clone2[fromIndex] = list[toIndex];
  clone2[toIndex] = list[fromIndex];
  return clone2;
}
var move = curry(moveFn);

// node_modules/rambda/src/multiply.js
function multiply(x, y) {
  if (arguments.length === 1)
    return (_y) => multiply(x, _y);
  return x * y;
}

// node_modules/rambda/src/negate.js
function negate(x) {
  return -x;
}

// node_modules/rambda/src/none.js
function none(predicate, list) {
  if (arguments.length === 1)
    return (_list) => none(predicate, _list);
  for (let i = 0; i < list.length; i++) {
    if (predicate(list[i]))
      return false;
  }
  return true;
}

// node_modules/rambda/src/nop.js
function nop() {
}

// node_modules/rambda/src/not.js
function not(input) {
  return !input;
}

// node_modules/rambda/src/objOf.js
function objOf(key, value) {
  if (arguments.length === 1) {
    return (_value) => objOf(key, _value);
  }
  return { [key]: value };
}

// node_modules/rambda/src/of.js
function of(value) {
  return [value];
}

// node_modules/rambda/src/omit.js
function omit(propsToOmit, obj) {
  if (arguments.length === 1)
    return (_obj) => omit(propsToOmit, _obj);
  if (obj === null || obj === void 0) {
    return void 0;
  }
  const propsToOmitValue = createPath(propsToOmit, ",");
  const willReturn = {};
  for (const key in obj) {
    if (!propsToOmitValue.includes(key)) {
      willReturn[key] = obj[key];
    }
  }
  return willReturn;
}

// node_modules/rambda/src/on.js
function on(binaryFn, unaryFn, a, b) {
  if (arguments.length === 3) {
    return (_b) => on(
      binaryFn,
      unaryFn,
      a,
      _b
    );
  }
  if (arguments.length === 2) {
    return (_a, _b) => on(
      binaryFn,
      unaryFn,
      _a,
      _b
    );
  }
  return binaryFn(unaryFn(a), unaryFn(b));
}

// node_modules/rambda/src/once.js
function onceFn(fn, context) {
  let result;
  return function() {
    if (fn) {
      result = fn.apply(context || this, arguments);
      fn = null;
    }
    return result;
  };
}
function once(fn, context) {
  if (arguments.length === 1) {
    const wrap = onceFn(fn, context);
    return curry(wrap);
  }
  return onceFn(fn, context);
}

// node_modules/rambda/src/or.js
function or(a, b) {
  if (arguments.length === 1)
    return (_b) => or(a, _b);
  return a || b;
}

// node_modules/rambda/src/over.js
var Identity = (x) => ({
  x,
  map: (fn) => Identity(fn(x))
});
function overFn(lens2, fn, object) {
  return lens2((x) => Identity(fn(x)))(object).x;
}
var over = curry(overFn);

// node_modules/rambda/src/partial.js
function partial(fn, ...args) {
  const len = fn.length;
  return (...rest) => {
    if (args.length + rest.length >= len) {
      return fn(...args, ...rest);
    }
    return partial(fn, ...[...args, ...rest]);
  };
}

// node_modules/rambda/src/partialObject.js
function partialObject(fn, input) {
  return (nextInput) => fn(mergeDeepRight(nextInput, input));
}

// node_modules/rambda/src/partition.js
function partitionObject(predicate, iterable) {
  const yes = {};
  const no = {};
  Object.entries(iterable).forEach(([prop2, value]) => {
    if (predicate(value, prop2)) {
      yes[prop2] = value;
    } else {
      no[prop2] = value;
    }
  });
  return [yes, no];
}
function partitionArray(predicate, list, indexed = false) {
  const yes = [];
  const no = [];
  let counter = -1;
  while (counter++ < list.length - 1) {
    if (indexed ? predicate(list[counter], counter) : predicate(list[counter])) {
      yes.push(list[counter]);
    } else {
      no.push(list[counter]);
    }
  }
  return [yes, no];
}
function partition(predicate, iterable) {
  if (arguments.length === 1) {
    return (listHolder) => partition(predicate, listHolder);
  }
  if (!isArray(iterable))
    return partitionObject(predicate, iterable);
  return partitionArray(predicate, iterable);
}

// node_modules/rambda/src/pathEq.js
function pathEqFn(pathToSearch, target, input) {
  return equals(path(pathToSearch, input), target);
}
var pathEq = curry(pathEqFn);

// node_modules/rambda/src/pathOr.js
function pathOrFn(defaultValue, pathInput, obj) {
  return defaultTo(defaultValue, path(pathInput, obj));
}
var pathOr = curry(pathOrFn);

// node_modules/rambda/src/paths.js
function paths(pathsToSearch, obj) {
  if (arguments.length === 1) {
    return (_obj) => paths(pathsToSearch, _obj);
  }
  return pathsToSearch.map((singlePath) => path(singlePath, obj));
}

// node_modules/rambda/src/pick.js
function pick(propsToPick, input) {
  if (arguments.length === 1)
    return (_input) => pick(propsToPick, _input);
  if (input === null || input === void 0) {
    return void 0;
  }
  const keys3 = createPath(propsToPick, ",");
  const willReturn = {};
  let counter = 0;
  while (counter < keys3.length) {
    if (keys3[counter] in input) {
      willReturn[keys3[counter]] = input[keys3[counter]];
    }
    counter++;
  }
  return willReturn;
}

// node_modules/rambda/src/pickAll.js
function pickAll(propsToPick, obj) {
  if (arguments.length === 1)
    return (_obj) => pickAll(propsToPick, _obj);
  if (obj === null || obj === void 0) {
    return void 0;
  }
  const keysValue = createPath(propsToPick, ",");
  const willReturn = {};
  let counter = 0;
  while (counter < keysValue.length) {
    if (keysValue[counter] in obj) {
      willReturn[keysValue[counter]] = obj[keysValue[counter]];
    } else {
      willReturn[keysValue[counter]] = void 0;
    }
    counter++;
  }
  return willReturn;
}

// node_modules/rambda/src/pluck.js
function pluck(property, list) {
  if (arguments.length === 1)
    return (_list) => pluck(property, _list);
  const willReturn = [];
  map((x) => {
    if (x[property] !== void 0) {
      willReturn.push(x[property]);
    }
  }, list);
  return willReturn;
}

// node_modules/rambda/src/prepend.js
function prepend(x, input) {
  if (arguments.length === 1)
    return (_input) => prepend(x, _input);
  if (typeof input === "string")
    return [x].concat(input.split(""));
  return [x].concat(input);
}

// node_modules/rambda/src/product.js
var product = reduce(multiply, 1);

// node_modules/rambda/src/propEq.js
function propEqFn(propToFind, valueToMatch, obj) {
  if (!obj)
    return false;
  return equals(valueToMatch, prop(propToFind, obj));
}
var propEq = curry(propEqFn);

// node_modules/rambda/src/propIs.js
function propIsFn(targetPrototype, property, obj) {
  return is(targetPrototype, obj[property]);
}
var propIs = curry(propIsFn);

// node_modules/rambda/src/propOr.js
function propOrFn(defaultValue, property, obj) {
  if (!obj)
    return defaultValue;
  return defaultTo(defaultValue, obj[property]);
}
var propOr = curry(propOrFn);

// node_modules/rambda/src/props.js
function props(propsToPick, obj) {
  if (arguments.length === 1) {
    return (_obj) => props(propsToPick, _obj);
  }
  if (!isArray(propsToPick)) {
    throw new Error("propsToPick is not a list");
  }
  return mapArray((prop2) => obj[prop2], propsToPick);
}

// node_modules/rambda/src/propSatisfies.js
function propSatisfiesFn(predicate, property, obj) {
  return predicate(prop(property, obj));
}
var propSatisfies = curry(propSatisfiesFn);

// node_modules/rambda/src/range.js
function range(start, end) {
  if (arguments.length === 1)
    return (_end) => range(start, _end);
  if (Number.isNaN(Number(start)) || Number.isNaN(Number(end))) {
    throw new TypeError("Both arguments to range must be numbers");
  }
  if (end < start)
    return [];
  const len = end - start;
  const willReturn = Array(len);
  for (let i = 0; i < len; i++) {
    willReturn[i] = start + i;
  }
  return willReturn;
}

// node_modules/rambda/src/reject.js
function reject(predicate, list) {
  if (arguments.length === 1)
    return (_list) => reject(predicate, _list);
  return filter((x) => !predicate(x), list);
}

// node_modules/rambda/src/repeat.js
function repeat(x, timesToRepeat) {
  if (arguments.length === 1) {
    return (_timesToRepeat) => repeat(x, _timesToRepeat);
  }
  return Array(timesToRepeat).fill(x);
}

// node_modules/rambda/src/replace.js
function replaceFn(pattern, replacer, str) {
  return str.replace(pattern, replacer);
}
var replace = curry(replaceFn);

// node_modules/rambda/src/reverse.js
function reverse(listOrString) {
  if (typeof listOrString === "string") {
    return listOrString.split("").reverse().join("");
  }
  const clone2 = listOrString.slice();
  return clone2.reverse();
}

// node_modules/rambda/src/set.js
function setFn(lens2, replacer, x) {
  return over(
    lens2,
    always(replacer),
    x
  );
}
var set = curry(setFn);

// node_modules/rambda/src/slice.js
function sliceFn(from, to, list) {
  return list.slice(from, to);
}
var slice = curry(sliceFn);

// node_modules/rambda/src/sort.js
function sort(sortFn, list) {
  if (arguments.length === 1)
    return (_list) => sort(sortFn, _list);
  return cloneList(list).sort(sortFn);
}

// node_modules/rambda/src/sortBy.js
function sortBy(sortFn, list) {
  if (arguments.length === 1)
    return (_list) => sortBy(sortFn, _list);
  const clone2 = cloneList(list);
  return clone2.sort((a, b) => {
    const aSortResult = sortFn(a);
    const bSortResult = sortFn(b);
    if (aSortResult === bSortResult)
      return 0;
    return aSortResult < bSortResult ? -1 : 1;
  });
}

// node_modules/rambda/src/split.js
function split(separator, str) {
  if (arguments.length === 1)
    return (_str) => split(separator, _str);
  return str.split(separator);
}

// node_modules/rambda/src/maybe.js
function maybe(ifRule, whenIf, whenElse) {
  const whenIfInput = ifRule && type(whenIf) === "Function" ? whenIf() : whenIf;
  const whenElseInput = !ifRule && type(whenElse) === "Function" ? whenElse() : whenElse;
  return ifRule ? whenIfInput : whenElseInput;
}

// node_modules/rambda/src/take.js
function take(howMany, listOrString) {
  if (arguments.length === 1)
    return (_listOrString) => take(howMany, _listOrString);
  if (howMany < 0)
    return listOrString.slice();
  if (typeof listOrString === "string")
    return listOrString.slice(0, howMany);
  return baseSlice(
    listOrString,
    0,
    howMany
  );
}

// node_modules/rambda/src/splitAt.js
function splitAt(index, input) {
  if (arguments.length === 1) {
    return (_list) => splitAt(index, _list);
  }
  if (!input)
    throw new TypeError(`Cannot read property 'slice' of ${input}`);
  if (!isArray(input) && typeof input !== "string")
    return [[], []];
  const correctIndex = maybe(
    index < 0,
    input.length + index < 0 ? 0 : input.length + index,
    index
  );
  return [take(correctIndex, input), drop(correctIndex, input)];
}

// node_modules/rambda/src/splitEvery.js
function splitEvery(sliceLength, listOrString) {
  if (arguments.length === 1) {
    return (_listOrString) => splitEvery(sliceLength, _listOrString);
  }
  if (sliceLength < 1) {
    throw new Error("First argument to splitEvery must be a positive integer");
  }
  const willReturn = [];
  let counter = 0;
  while (counter < listOrString.length) {
    willReturn.push(listOrString.slice(counter, counter += sliceLength));
  }
  return willReturn;
}

// node_modules/rambda/src/splitWhen.js
function splitWhen(predicate, input) {
  if (arguments.length === 1) {
    return (_input) => splitWhen(predicate, _input);
  }
  if (!input)
    throw new TypeError(`Cannot read property 'length' of ${input}`);
  const preFound = [];
  const postFound = [];
  let found = false;
  let counter = -1;
  while (counter++ < input.length - 1) {
    if (found) {
      postFound.push(input[counter]);
    } else if (predicate(input[counter])) {
      postFound.push(input[counter]);
      found = true;
    } else {
      preFound.push(input[counter]);
    }
  }
  return [preFound, postFound];
}

// node_modules/rambda/src/startsWith.js
function startsWith(target, iterable) {
  if (arguments.length === 1)
    return (_iterable) => startsWith(target, _iterable);
  if (typeof iterable === "string") {
    return iterable.startsWith(target);
  }
  if (!isArray(target))
    return false;
  let correct = true;
  const filtered = target.filter((x, index) => {
    if (!correct)
      return false;
    const result = equals(x, iterable[index]);
    if (!result)
      correct = false;
    return result;
  });
  return filtered.length === target.length;
}

// node_modules/rambda/src/subtract.js
function subtract(a, b) {
  if (arguments.length === 1)
    return (_b) => subtract(a, _b);
  return a - b;
}

// node_modules/rambda/src/symmetricDifference.js
function symmetricDifference(x, y) {
  if (arguments.length === 1) {
    return (_y) => symmetricDifference(x, _y);
  }
  return concat(
    filter((value) => !includes(value, y), x),
    filter((value) => !includes(value, x), y)
  );
}

// node_modules/rambda/src/T.js
function T() {
  return true;
}

// node_modules/rambda/src/tail.js
function tail(listOrString) {
  return drop(1, listOrString);
}

// node_modules/rambda/src/takeLast.js
function takeLast(howMany, listOrString) {
  if (arguments.length === 1)
    return (_listOrString) => takeLast(howMany, _listOrString);
  const len = listOrString.length;
  if (howMany < 0)
    return listOrString.slice();
  let numValue = howMany > len ? len : howMany;
  if (typeof listOrString === "string")
    return listOrString.slice(len - numValue);
  numValue = len - numValue;
  return baseSlice(
    listOrString,
    numValue,
    len
  );
}

// node_modules/rambda/src/takeLastWhile.js
function takeLastWhile(predicate, input) {
  if (arguments.length === 1) {
    return (_input) => takeLastWhile(predicate, _input);
  }
  if (input.length === 0)
    return input;
  const toReturn = [];
  let counter = input.length;
  while (counter) {
    const item = input[--counter];
    if (!predicate(item)) {
      break;
    }
    toReturn.push(item);
  }
  return isArray(input) ? toReturn.reverse() : toReturn.reverse().join("");
}

// node_modules/rambda/src/takeWhile.js
function takeWhile(predicate, iterable) {
  if (arguments.length === 1) {
    return (_iterable) => takeWhile(predicate, _iterable);
  }
  const isArray2 = isArray(iterable);
  if (!isArray2 && typeof iterable !== "string") {
    throw new Error("`iterable` is neither list nor a string");
  }
  const toReturn = [];
  let counter = 0;
  while (counter < iterable.length) {
    const item = iterable[counter++];
    if (!predicate(item)) {
      break;
    }
    toReturn.push(item);
  }
  return isArray2 ? toReturn : toReturn.join("");
}

// node_modules/rambda/src/tap.js
function tap(fn, x) {
  if (arguments.length === 1)
    return (_x) => tap(fn, _x);
  fn(x);
  return x;
}

// node_modules/rambda/src/test.js
function test(pattern, str) {
  if (arguments.length === 1)
    return (_str) => test(pattern, _str);
  if (typeof pattern === "string") {
    throw new TypeError(`R.test requires a value of type RegExp as its first argument; received "${pattern}"`);
  }
  return str.search(pattern) !== -1;
}

// node_modules/rambda/src/times.js
function times(fn, howMany) {
  if (arguments.length === 1)
    return (_howMany) => times(fn, _howMany);
  if (!isInteger(howMany) || howMany < 0) {
    throw new RangeError("n must be an integer");
  }
  return map(fn, range(0, howMany));
}

// node_modules/rambda/src/toLower.js
function toLower(str) {
  return str.toLowerCase();
}

// node_modules/rambda/src/toPairs.js
function toPairs(obj) {
  return Object.entries(obj);
}

// node_modules/rambda/src/toString.js
function toString(x) {
  return x.toString();
}

// node_modules/rambda/src/toUpper.js
function toUpper(str) {
  return str.toUpperCase();
}

// node_modules/rambda/src/transpose.js
function transpose(array) {
  return array.reduce((acc, el) => {
    el.forEach((nestedEl, i) => isArray(acc[i]) ? acc[i].push(nestedEl) : acc.push([nestedEl]));
    return acc;
  }, []);
}

// node_modules/rambda/src/trim.js
function trim(str) {
  return str.trim();
}

// node_modules/rambda/src/tryCatch.js
var isFunction = (x) => ["Promise", "Function"].includes(type(x));
function tryCatch(fn, fallback) {
  if (!isFunction(fn)) {
    throw new Error(`R.tryCatch | fn '${fn}'`);
  }
  const passFallback = isFunction(fallback);
  return (...inputs) => {
    try {
      return fn(...inputs);
    } catch (e) {
      return passFallback ? fallback(e, ...inputs) : fallback;
    }
  };
}

// node_modules/rambda/src/unapply.js
function unapply(fn) {
  return function(...args) {
    return fn.call(this, args);
  };
}

// node_modules/rambda/src/union.js
function union(x, y) {
  if (arguments.length === 1)
    return (_y) => union(x, _y);
  const toReturn = cloneList(x);
  y.forEach((yInstance) => {
    if (!includes(yInstance, x))
      toReturn.push(yInstance);
  });
  return toReturn;
}

// node_modules/rambda/src/uniqBy.js
function uniqBy(fn, list) {
  if (arguments.length === 1) {
    return (_list) => uniqBy(fn, _list);
  }
  const set2 = new _Set();
  return list.filter((item) => set2.checkUniqueness(fn(item)));
}

// node_modules/rambda/src/uniqWith.js
function includesWith(predicate, target, list) {
  let willReturn = false;
  let index = -1;
  while (++index < list.length && !willReturn) {
    const value = list[index];
    if (predicate(target, value)) {
      willReturn = true;
    }
  }
  return willReturn;
}
function uniqWith(predicate, list) {
  if (arguments.length === 1)
    return (_list) => uniqWith(predicate, _list);
  let index = -1;
  const willReturn = [];
  while (++index < list.length) {
    const value = list[index];
    if (!includesWith(
      predicate,
      value,
      willReturn
    )) {
      willReturn.push(value);
    }
  }
  return willReturn;
}

// node_modules/rambda/src/unless.js
function unless(predicate, whenFalse) {
  if (arguments.length === 1) {
    return (_whenFalse) => unless(predicate, _whenFalse);
  }
  return (input) => predicate(input) ? input : whenFalse(input);
}

// node_modules/rambda/src/unnest.js
function unnest(list) {
  return list.reduce((acc, item) => {
    if (Array.isArray(item)) {
      return [...acc, ...item];
    }
    return [...acc, item];
  }, []);
}

// node_modules/rambda/src/unwind.js
function unwind(property, obj) {
  if (arguments.length === 1) {
    return (_obj) => unwind(property, _obj);
  }
  if (!isArray(obj[property]))
    return [obj];
  return mapArray(
    (x) => ({
      ...obj,
      [property]: x
    }),
    obj[property]
  );
}

// node_modules/rambda/src/values.js
function values(obj) {
  if (type(obj) !== "Object")
    return [];
  return Object.values(obj);
}

// node_modules/rambda/src/view.js
var Const = (x) => ({
  x,
  map: (fn) => Const(x)
});
function view(lens2, target) {
  if (arguments.length === 1)
    return (_target) => view(lens2, _target);
  return lens2(Const)(target).x;
}

// node_modules/rambda/src/when.js
function whenFn(predicate, whenTrueFn, input) {
  if (!predicate(input))
    return input;
  return whenTrueFn(input);
}
var when = curry(whenFn);

// node_modules/rambda/src/where.js
function where(conditions, input) {
  if (input === void 0) {
    return (_input) => where(conditions, _input);
  }
  let flag = true;
  for (const prop2 in conditions) {
    if (!flag)
      continue;
    const result = conditions[prop2](input[prop2]);
    if (flag && result === false) {
      flag = false;
    }
  }
  return flag;
}

// node_modules/rambda/src/whereAny.js
function whereAny(conditions, input) {
  if (input === void 0) {
    return (_input) => whereAny(conditions, _input);
  }
  for (const prop2 in conditions) {
    if (conditions[prop2](input[prop2])) {
      return true;
    }
  }
  return false;
}

// node_modules/rambda/src/whereEq.js
function whereEq(condition, input) {
  if (arguments.length === 1) {
    return (_input) => whereEq(condition, _input);
  }
  const result = filter(
    (conditionValue, conditionProp) => equals(conditionValue, input[conditionProp]),
    condition
  );
  return Object.keys(result).length === Object.keys(condition).length;
}

// node_modules/rambda/src/without.js
function without(matchAgainst, source) {
  if (source === void 0) {
    return (_source) => without(matchAgainst, _source);
  }
  return reduce(
    (prev, current) => _indexOf(current, matchAgainst) > -1 ? prev : prev.concat(current),
    [],
    source
  );
}

// node_modules/rambda/src/xor.js
function xor(a, b) {
  if (arguments.length === 1)
    return (_b) => xor(a, _b);
  return Boolean(a) && !b || Boolean(b) && !a;
}

// node_modules/rambda/src/zip.js
function zip(left, right) {
  if (arguments.length === 1)
    return (_right) => zip(left, _right);
  const result = [];
  const length2 = Math.min(left.length, right.length);
  for (let i = 0; i < length2; i++) {
    result[i] = [left[i], right[i]];
  }
  return result;
}

// node_modules/rambda/src/zipObj.js
function zipObj(keys3, values2) {
  if (arguments.length === 1)
    return (yHolder) => zipObj(keys3, yHolder);
  return take(values2.length, keys3).reduce((prev, xInstance, i) => {
    prev[xInstance] = values2[i];
    return prev;
  }, {});
}

// node_modules/rambda/src/zipWith.js
function zipWithFn(fn, x, y) {
  return take(x.length > y.length ? y.length : x.length, x).map((xInstance, i) => fn(xInstance, y[i]));
}
var zipWith = curry(zipWithFn);
export {
  F,
  T,
  __findHighestArity,
  _arity2 as _arity,
  _indexOf,
  _lastIndexOf,
  _pipe,
  add,
  adjust,
  all,
  allPass,
  always,
  and,
  any,
  anyPass,
  append,
  apply,
  applySpec,
  assoc,
  assocPath,
  bind,
  both,
  chain,
  clamp,
  clone,
  complement,
  compose,
  concat,
  cond,
  converge,
  count,
  countBy,
  curry,
  curryN,
  dec,
  defaultTo,
  difference,
  dissoc,
  divide,
  drop,
  dropLast,
  dropLastWhile,
  dropRepeats,
  dropRepeatsWith,
  dropWhile,
  either,
  endsWith,
  eqProps,
  equals,
  evolve,
  evolveArray,
  evolveObject,
  filter,
  filterArray,
  filterObject,
  find,
  findIndex,
  findLast,
  findLastIndex,
  flatten,
  flip,
  forEach,
  fromPairs,
  groupBy,
  groupWith,
  has,
  hasPath,
  head,
  identical,
  identity,
  ifElse,
  inc,
  includes,
  indexBy,
  indexOf,
  init,
  intersection,
  intersperse,
  is,
  isEmpty,
  isNil,
  join,
  juxt,
  keys2 as keys,
  last,
  lastIndexOf,
  length,
  lens,
  lensIndex,
  lensPath,
  lensProp,
  map,
  mapArray,
  mapObjIndexed,
  mapObject,
  match,
  mathMod,
  max,
  maxBy,
  maxByFn,
  mean,
  median,
  mergeRight as merge,
  mergeAll,
  mergeDeepRight,
  mergeLeft,
  mergeRight,
  mergeWith,
  min,
  minBy,
  minByFn,
  modify,
  modifyPath,
  modifyPathFn,
  modulo,
  move,
  multiply,
  negate,
  none,
  nop,
  not,
  nth,
  objOf,
  of,
  omit,
  on,
  once,
  or,
  over,
  partial,
  partialObject,
  partition,
  partitionArray,
  partitionObject,
  path,
  pathEq,
  pathOr,
  paths,
  pick,
  pickAll,
  pipe,
  pluck,
  prepend,
  product,
  prop,
  propEq,
  propIs,
  propOr,
  propSatisfies,
  props,
  range,
  reduce,
  reduceFn,
  reduceStopper,
  reject,
  repeat,
  replace,
  reverse,
  set,
  slice,
  sort,
  sortBy,
  split,
  splitAt,
  splitEvery,
  splitWhen,
  startsWith,
  subtract,
  sum,
  symmetricDifference,
  tail,
  take,
  takeLast,
  takeLastWhile,
  takeWhile,
  tap,
  test,
  times,
  toLower,
  toPairs,
  toString,
  toUpper,
  transpose,
  trim,
  tryCatch,
  type,
  unapply,
  union,
  uniq,
  uniqBy,
  uniqWith,
  unless,
  unnest,
  unwind,
  update,
  updateFn,
  values,
  view,
  when,
  where,
  whereAny,
  whereEq,
  without,
  xor,
  zip,
  zipObj,
  zipWith
};
//# sourceMappingURL=rambda.js.map
